```
LIP: 0039
Title: Introduce sparse Merkle trees
Author: Alessandro Ricottone <alessandro.ricottone@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-sparse-merkle-trees
Status: Draft
Type: Informational
Created: 2021-04-22
Updated: 2021-12-01
```

## Abstract

In this LIP, we specify the sparse Merkle tree implementation for the Lisk protocol and the format for inclusion proofs. A sparse Merkle tree is an authenticated data structure that allows to validate a key-value dataset with a single hash value, the Merkle root. It differs from a regular Merkle tree in that every element of the dataset occupies a fixed position in the tree, given by its key, and the resulting Merkle root depends only on the final dataset and not on the order of insertion.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

A sparse Merkle tree (SMT) is a data structure used to accumulate a key-value dataset into a single root [1].  The main differences between SMTs and regular Merkle trees are that in a SMT the final Merkle root does not depend on the order of insertion of the data, since all elements occupy a fixed position in the tree structure (given by the key). SMTs allow for efficient proofs-of-non-inclusion, where the Prover can convince the Verifier that a certain key-value pair is not part of the underlying dataset.

In this LIP, we specify the SMT data structure for the Lisk protocol. We do not describe specific use-cases, which will be presented in other LIPs. We describe the format for inclusion proofs, the verification protocol, and the proof serialization.

## Rationale

### General Description and Properties

For the rest of the LIP, we indicate with `N` the number of elements present in the tree, with `L` the binary length of a key, and with `Log` the base 2 logarithm.

A sparse Merkle tree is an authenticated data structure organized as a tree. Unlike regular Merkle trees (specified in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md) for the Lisk protocol), a SMT contains a distinct leaf node for every possible key. Therefore, the size of the tree is exponential in the length of the keys. For example, for 32-byte keys, a SMT contains 2<sup>256</sup> leaves and 256 layers. Such an enormous number of nodes cannot actually be generated and stored, hence the tree is only ''simulated''.

The defining property of a SMT is:

1. **History independence**: the Merkle root is independent of the insertion history and depends only on the final dataset.

The goal of our specification of a SMT is to have the following properties:

2. **Dynamic**: the tree can be updated efficiently, i.e. with `O(Log(N))` operations.
3. **Universal**: the implementation supports efficient inclusion and non-inclusion proofs.
4. **Efficient storage**: only `O(N)` elements are stored explicitly.

It is sufficient that these properties hold when the keys are randomly distributed, but not necessarily attained in general (for example when the keys are chosen adversarially).

We apply the following optimizations, similar to the one defined in the Diem protocol [2]:

1. Each subtree with exactly one non-empty leaf is replaced by the leaf itself.
2. Each subtree containing only empty nodes is replaced by a constant node with hash value equal to `EMPTY_HASH`.

Here, an empty node is a node storing no value (or value=0). A new tree is initialized with all empty nodes. An example of a tree resulting from these optimizations is given in Figure 1.

<img alt="Sparse Merkle tree" src="lip-0039/sparse_merkle_tree.png" width="400">

*Figure 1: a tree consisting of 11 non-empty leaves. Leaf keys (indicated in green) have a length of 1 byte. We show only the first 4 bytes of the node hashes for convenience and we display the keys in their binary representation. âˆ… denotes default empty nodes. Branch nodes do not have a key, but here we indicate in red the common prefix of the leaf nodes below the branch.*

As mentioned, the tree height is `O(Log(N))` if the keys are randomly distributed. It is easy to fulfill this condition by hashing the keys prior to insertion in the tree. The average number of operations needed to update the tree after inserting a node approaches `Log(N)`, while it equals `L` (256 for 32-byte keys) in the worst case (two consecutive leaf nodes differing only on the last binary digit of their key). The additional introduction of extension nodes could eliminate empty nodes and therefore bring the number of operations down to `O(Log(N))` also for the worst case. However, this optimization introduces extra complexity in the non-inclusion proof protocol, and as explained, this drawback is not relevant for randomly distributed keys.

We use proof compression to guarantee that the proof size also scales as `O(Log(N))`.
We only pass non-empty hashes as part of the proof, and include an extra bitmap to indicate which nodes in the proof path are non default empty nodes.
In summary, this construction supports update, proof generation, and verification in `O(Log(N))` operations, with height, number of nodes, and proof length also scaling as `O(Log(N))`.

### Inclusion Proof Protocols

In this section, we introduce some terminology and explain two general protocols for inclusion proofs. The Verifier holds `merkleRoot`, the Merkle root of the tree built from the dataset, and a set of keys, `queryKeys`, for which they wish to obtain an inclusion proof.

An inclusion proof is characterized by the following properties:

*   `queryKeys`: An array of keys whose presence in the dataset has to be verified.
*   `proof`: The proof itself, consisting of 2 parts: `siblingHashes`, `queries`:
    *   `siblingHashes`: An array of bytes necessary to compute the Merkle root.
    *   `queries`: An array of objects, one per key in `queryKeys`. Each object describes the inclusion proof of the corresponding key and contains the following properties:
        *   `key`: A byte value indicating the presence or not of the corresponding key in the tree.
        *   `bitmap`: A byte value whose binary expansion indicates the presence of a branch or leaf node (digit 1) or an empty node (digit 0) in the path from the leaf node to the root (see Figure 2).
        *   `value`: A byte value giving the value of the node associated with `key.`

The protocol for an inclusion proof is similar to the [one specified for regular Merkle trees](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md#proof-of-inclusion-protocol):

*   Verifier: The Verifier knows `merkleRoot` and sends the Prover an array of keys, `queryKeys`, for which they wish to obtain a proof-of-inclusion;
*   Prover:
    *   The Prover finds the leaf node corresponding to each key `k` in `queryKeys` and assigns to each a `query` object with a key, a bitmap, and a value. The bitmap indicates the presence of default empty nodes along the path to the Merkle root. If the node exists, `query.key` is set to `k` and `query.value` to the node value; if the node does not exist, the Prover returns an inclusion proof for another leaf or a default empty node in the path of the `k`. In this case, `query.key` and `query.value` are set to the leaf key and leaf value or to `k` and empty value, respectively.  
    *   The Prover generates `siblingHashes` by merging together the sibling hashes of the single paths in the correct order of application, and transmits the complete proof to the Verifier. The complete proof contains a common array `siblingHashes` and an array `queries`, containing a query object for each key in `queryKeys`, respecting the same order.
*   Verifier: 
    *   The Verifier uses `siblingHashes` to recalculate the Merkle root starting from the leaf nodes derived from `queryKeys` and `queries`, and checks that it equals `merkleRoot`. 
    *   By comparing the original array of `queryKeys` with the keys in the `proof.queries` array, the Verifier checks that all keys in `queryKeys` are present in the tree.

As shown, a non-inclusion proof is generated by providing a proof of inclusion for another leaf or a default empty node in the path of the target leaf node, indicating that there are no other leaves in the subtree (see Figure 2). The protocol for a non-inclusion proof is thus exactly the same as for an inclusion proof, except that in the last step, where:

*   Verifier: 
    *   By comparing the original array of `queryKeys` with the keys in the `proof.queries` array, the Verifier checks that no keys in `queryKeys` are present in the tree.


```python
@dataclass
class SubTree(object):
    structure: list[int]
    nodes: list[TreeNode]
```

## Specification

For the rest of this proposal, we define the following constants:

| Name             | Type    | Value       |
| ---------------- |---------| ------------|
| EMPTY_HASH       | bytes   | SHA-256("") |
| LEAF_PREFIX      | bytes   | ascii encoding of "LSK_SMTL_"  |
| BRANCH_PREFIX    | bytes   | ascii encoding of "LSK_SMTB_"  |
| KEY_LENGTH_BYTES | integer | Length of keys in bytes. Set when initializing the data structure |

Each node in the tree has a `data` and a `hash` property. Leaf nodes store the key and value in their data property, while branch nodes store the hashes of the child nodes. Default empty nodes have a constant hash `EMPTY_HASH`.  In summary, we define 3 different node types:

```python
@dataclass
class LeafNode:
    key: bytes
    value: bytes

    @property
    def hash(self) -> bytes:
        return hash(LEAF_PREFIX + self.key + self.value)
```
```python
@dataclass
class BranchNode:
    left_hash: bytes
    right_hash: bytes

    @property
    def hash(self) -> bytes:
        return hash(BRANCH_PREFIX + self.left_hash + self.right_hash)
```
```python
@dataclass
class EmptyNode:
    @property
    def hash(self) -> bytes:
        return EMPTY_HASH
```

Here the function `hash` returns the SHA-256 hash of the input. Similar to what we do for regular Merkle trees, we use a different hash function for leaf and branch nodes to protect against second preimage attacks and prefix the hashed data with different constants.
Leaf nodes are ''hardened'' by hashing their keys together with their values; otherwise, in a subtree with only one non-empty node several keys would correspond to the same leaf node.

The Merkle tree is built on top of an underlying dataset consisting of a set of (key, value) tuples. The key fixes the position of each dataset element in the tree: starting from the root, each digit in the binary expansion indicates whether we should follow the left child (next digit is 0) or the right child (next digit is 1), see Figure 1. The length of the key (in bytes) is a fixed constant of the tree, `KEY_LENGTH_BYTES`, larger than 0. The value property must be non-empty.

As explained in the rationale, rather than explicitly creating a full tree, we simulate it by inserting only non-zero leaves into the tree whenever a new data block (a key-value pair) is added to the dataset, using the two optimizations:

1. Each subtree with exactly one non-empty leaf is replaced by the leaf itself.
2. Each subtree containing only empty nodes is replaced by a constant node with hash value equal to `EMPTY_HASH`.


The functions defined in the following sections are methods of the tree, i.e. we assume that the tree is a global data structure that can be modified by these functions.

### Root Hash Calculation

The Merkle root of a dataset is computed as follows:

1. The Merkle root of an empty dataset is set to the constant value `EMPTY_HASH`.
2. The Merkle root of a dataset with a single element is set to the leaf hash of that element.
3. Otherwise, the Merkle root is the root of the tree resulting from inserting each key-value pair in the dataset using the update protocol outlined here.

```python
def update(
    self,
    keys: list[bytes],
    values: list[bytes],
) -> LeafNode | BranchNode | EmptyNode:

    assert len(keys) == len(values)

    if len(keys) == 0:
        return self.root

    # We sort the data by their key, so that we can easily split them
    # into two lists later on.
    sorted_data = sorted(zip(keys, values), key=lambda d: d[0])
    keys = [key for key, _ in sorted_data]
    values = [value for _, value in sorted_data]

    self.root = self._update(keys, values, self.root, 0)
    return self.root

def _update(
    self,
    keys: list[bytes],
    values: list[bytes],
    current_node: LeafNode | BranchNode | EmptyNode,
    height: int,
) -> LeafNode | BranchNode | EmptyNode:
    
    if len(keys) == 0:
        return current_node
    
    # If there is a single key to update, we return a new leaf node if the current node
    # is an empty node or if the current node is a leaf node and with the same key.
    if len(keys) == 1:
        if isinstance(current_node, EmptyNode):
            return LeafNode(keys[0], values[0])
        elif isinstance(current_node, LeafNode) and current_node.key == keys[0]:
            return LeafNode(keys[0], values[0])

    # We split the keys into two lists, depending on whether the key bit at index 
    # equal to height is 0 or 1.
    idx = split_index(keys, height)
    left_keys = keys[:idx] 
    left_values = values[:idx]
    right_keys = keys[idx:] 
    right_values = values[idx:]

    # We 
    if isinstance(current_node, EmptyNode):
        left_node = self._update(left_keys, left_values, EmptyNode(), height + 1)
        right_node = self._update(right_keys, right_values, EmptyNode(), height + 1)
    elif isinstance(current_node, LeafNode):
        if is_bit_set(current_node.key, height):
            left_node = self._update(left_keys, left_values, EmptyNode(), height + 1)
            right_node = self._update(right_keys, right_values, current_node, height + 1)
        else:
            left_node = self._update(left_keys, left_values, current_node, height + 1)
            right_node = self._update(right_keys, right_values, EmptyNode(), height + 1)
    elif isinstance(current_node, BranchNode):
        left_node = get_node(current_node.left_hash)
        right_node = get_node(current_node.right_hash)
        left_node = self._update(left_keys, left_values, left_node, height + 1)
        right_node = self._update(right_keys, right_values, right_node, height + 1)

    return BranchNode(left_node.hash, right_node.hash)
```

Here the function `get_node` returns the node corresponding to the given hash value, for instance by fetching it from a database.
We use the following utility function.

```python
def split_index(keys: list[bytes], height: int) -> int:
    '''
    This function returns the index of the first key with bit at index height set to 1.
    '''
    for idx, key in enumerate(keys):
        if is_bit_set(key, height):
            return idx
    return len(keys)
```

```python
def is_bit_set(bits: bytes, i: int) -> bool:
    '''
    This function returns true if the i-th bit of bits is 1, false otherwise.
    '''

    shifted = bits[i // 8] << (i % 8)
    BIT_COMP = int.from_bytes(b"\x80", "big")

    return (shifted & BIT_COMP) == BIT_COMP
```

### Removing a Leaf Node

A certain key-value pair can be removed from the tree by deleting the corresponding leaf node and rearranging the affected nodes in the tree. The following protocol can be used to remove a key `key` from the tree.

```python
def remove(self, key: bytes) -> LeafNode | BranchNode | EmptyNode:

    ancestor_nodes: list[BranchNode] = []
    current_node = self.root
    h = 0
    current_node_sibling = EmptyNode()

    # Collect all ancestor nodes through traversing the binary expansion by height
    # End of the loop ancestor_nodes has all the branch nodes
    # current_node will be the leaf/node we are looking to remove
    while isinstance(current_node, BranchNode):
        ancestor_nodes.append(current_node)
        if is_bit_set(key, h):
            current_node_sibling = get_node(current_node.left_hash)
            current_node = get_node(current_node.right_hash)
        else:
            current_node_sibling = get_node(current_node.right_hash)
            current_node = get_node(current_node.left_hash)
        h += 1

    # When current_node is empty, nothing to remove
    if isinstance(current_node, EmptyNode):
        return current_node

    # When the input key does not match node key, nothing to remove
    if current_node.key != key:
        return current_node

    bottom_node = EmptyNode()

    if isinstance(current_node_sibling, LeafNode):
        # current_node has a leaf sibling,
        # remove the leaf and move sibling up the tree
        bottom_node = current_node_sibling
        h -= 1
        while h > 0:
            p = ancestor_nodes[h - 1]

            # if one of the children is empty then break the condition
            if p.left_hash != EmptyNode.hash and p.right_hash != EmptyNode.hash:
                break
            h -= 1

    # finally update all branch nodes in ancestor_nodes.
    # note that h now is set to the correct height from which
    # nodes have to be updated
    while h > 0:
        p = ancestor_nodes[h - 1]
        h -= 1

        if is_bit_set(key, h):
            p.right_hash = bottom_node.hash
        else:
            p.left_hash = bottom_node.hash

        bottom_node = p

    self.root = bottom_node
    return self.root
```

### Inclusion Proof Construction and Serialization

<img alt="Sparse Merkle tree with proofs" src="lip-0039/sparse_merkle_tree_with_proofs.png" width="400">

*Figure 2: the inclusion proof for <code>queryKeys=[00110101, 00111111, 01011010, 10111000]</code>. Elements of <code>proof.queries</code> are indicated in bold, while elements of <code>proof.siblingHashes</code> are highlighted in red. The complete proof is given by (hash values are shortened to the first 4 bytes and key and bitmap values are hex-encoded):*

```
proof={siblingHashes:[cc956a85, 3c516152, e041e1c0, 6400721e, 3c32b131],
       queries: [
           {key:33, value:4e074085, bitmap:17},
           {key:3f, value:8a8de823, bitmap:37},
           {key:5a, value:bbeebd87, bitmap:07},
           {key:a9, value:9e8e8c37, bitmap:07}]}.
```

*Given these keys and values, the hash of the node can be recomputed. For example, to the leaf node with <code>key=00110011</code> corresponds the hash  <code>leafHash(33 || 4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce) = 00be9f2ec46f47e14965f0cb9903f09bc6fe30244109c7c5310180a2251c75cc</code>.*


#### Proof Construction

The properties and protocol for an inclusion proof have been introduced in the Rationale section, above. In this section, we specify how these properties are calculated. We assume that the queried keys have a fixed length `KEY_LENGTH_BYTES`.

The following function generates the query response to a single key, including the sibling hashes and the hash of the visited nodes.

```java
function generateQueryProof(queryKey):
    let ancestorHashes be an empty array
    let siblingHashes be an empty array
    let queryBitmap be an empty string
    let currentNode be the tree root node
    if currentNode is defaultEmptyNode:
        let response be a data structure with:
            {key=queryKey,
             value=empty buffer,
             binaryBitmap=empty string,
             siblingHashes=siblingHashes,
             ancestorHashes=ancestorHashes}
        return response

    let binaryKey=binaryExpansion(queryKey)
    let h = 0

    while currentNode is branch:
        append currentNode.hash to ancestorHashes
        let d be the digit at position h of binaryKey
        if d == 0:
            set currentNode to the left child of currentNode
            set currentNodeSibling to the right child of currentNode
        else if d == 1:
            set currentNode to the right child of currentNode
            set currentNodeSibling to the left child of currentNode
        if currentNodeSibling is defaultEmptyNode:
            prepend 0 to queryBitmap
        else:
            prepend 1 to queryBitmap
            append currentNodeSibling.hash to siblingHashes
        set h to h+1

    // currentNode is an empty default node or a leaf node
    if currentNode is defaultEmptyNode:
        // queryKey is not part of the tree
        let response be a data structure with:
            {key=queryKey,
            value=empty buffer,
            binaryBitmap=queryBitmap,
            siblingHashes=siblingHashes,
            ancestorHashes=ancestorHashes}
    else:
        let response be a data structure with:
            {key=currentNode.key,
            value=currentNode.value,
            binaryBitmap=queryBitmap,
            siblingHashes=siblingHashes,
            ancestorHashes=ancestorHashes}
    return response
```

Note that the first digit of `queryBitmap` is always a 1, else the tree would have been invalidly constructed. As a consequence, the hex encoded value of `queryBitmap` corresponds to a unique series of digits.
To generate a complete inclusion proof, several query responses are combined together, and their sibling hashes are merged in a single array. We first define the utility function `sortByBitmapAndKey`.

```java
function sortByBitmapAndKey(queries):
    sort queries by the longest binaryBitmap, breaking ties by smaller key.
    // this corresponds to a bottom-up left-right ordering of the corresponding leaf nodes
```

Given an array of keys `queryKeys`, the inclusion proof is obtained from the function `generateProof(queryKeys)`.

```java
function generateProof(queryKeys):
    // queries hold the individual responses, respecting
    // the same order of queryKeys
    let queries be an empty array
    // sortedQueries is used to merge together the siblingHashes
    let sortedQueries be an empty array
    let ancestorHashes be an empty array
    for each key k in queryKeys:
        let r=generateQueryProof(k)
        append r to sortedQueries
        let q be a data structure with:
            {key=r.key,
            value=r.value,
            bitmap=r.binaryBitmap encoded as byte array}
        append q to queries
        append r.ancestorHashes to ancestorHashes

    let siblingHashes be an empty array
    while sortedQueries is non-empty:
        sortedQueries = sortByBitmapAndKey(sortedQueries)
        let q be the first element of sortedQueries
        if q.binaryBitmap is empty string:
            remove p from sortedQueries
            continue

        let b to the first digit of q.binaryBitmap
        remove the first digit of q.binaryBitmap
        if b == 1:
            let siblingHash be the last element of q.siblingHashes
            remove the last element from q.siblingHashes
            // only append to siblingHashes if it cannot be computed
            if siblingHash not in union(siblingHashes, ancestorHashes):
                append siblingHash to siblingHashes

    let proof be a data structure with:
        {siblingHashes=siblingHashes,
        queries=queries}
    return proof
```

#### Proof Verification

To check the proof, the Verifier calls the `verify(queryKeys, proof, merkleRoot)` function. This function is not a method of the tree, and can be run just by holding the Merkle root. Here, `queryKeys` is the same array of keys used to generate `proof`, while `merkleRoot` is the root of the SMT, known to the Verifier.

We define the utility functions `filterQueries`, `areSiblingQueries`, and `calculateRoot`. The general strategy is to recompute the Merkle root using `proof` and `queryKeys` in `calculateRoot`. The `verify` function then checks if the provided proof is valid against `queryKeys` and that the calculated root equals `merkleRoot`.

```java
// This function filters the array of queries by keeping only those
// with a different key prefix, i.e., by removing queries that have
// merged together
function filterQueries(queries):
    for each query q in queries:
        let h=length of q.binaryBitmap
        let binaryKey=binaryExpansion(q.key)
        let q.keyPrefix be the first h digits of binaryKey

        if there exists another p in queries s.t. p.keyPrefix == q.keyPrefix:
            if p.hash != q.hash:
                // the two merging queries have mismatching hashes
                throw error
            // filter queries by keeping only unique values of q.keyPrefix
            remove p from queries

    return queries
```

```java
// This function checks whether two queries correspond to nodes that are
// children of the same branch node, with q1 and q2 the left and right
// child respectively
function areSiblingQueries(q1, q2):
    if length of q1.binaryBitmap != length of q2.binaryBitmap:
        return false
    let h=length of q1.binaryBitmap
    let binaryKey1=binaryExpansion(q1.key)
    let binaryKey2=binaryExpansion(q2.key)
    let keyPrefix1 be the first (h-1) digits of binaryKey1
    let keyPrefix2 be the first (h-1) digits of binaryKey2
    if keyPrefix1 != keyPrefix2:
        return false
    let d1 be the digit at position h of binaryKey1
    let d2 be the digit at position h of binaryKey2
    return d1==0 and d2==1
```

```java
function calculateRoot(siblingHashes, queries):
    // we add the hash property to each query, used to recompute the tree root
    for each query q in queries:
        set q.binaryBitmap to binaryExpansion(q.bitmap) without leading zeros
        // if value is empty, it is a defaultEmptyNode
        if q.value is empty bytes:
            set q.hash to EMPTY_HASH
        else:
            let qLeaf=leafNode(q.key,q.value)
            set q.hash to qLeaf.hash

    let sortedQueries=sortByBitmapAndKey(queries)
    sortedQueries=filterQueries(sortedQueries)
    while sortedQueries is non-empty:
        let q be the first element of sortedQueries
        // if the binaryBitmap is empty string, we reached the top of the tree
        if q.binaryBitmap is empty string:
            return q.hash

        let b to the first digit of q.binaryBitmap
        // h equals the height of the node; e.g., the root has h=0
        let h=length of q.binaryBitmap
        let binaryKey=binaryExpansion(q.key)

        // we distinguish three cases for the sibling hash:
        // 1. sibling is next element of sortedQueries
        let nextQuery = next element of sortedQueries
        if nextQuery exists and areSiblingQueries(q, nextQuery):
            set siblingHash to nextQuery.hash
            remove nextQuery from sortedQueries
        // 2. sibling is default empty node
        else if b == 0:
            set siblingHash to EMPTY_HASH
        // 3. sibling hash comes from siblingHashes
        else if b == 1:
            set siblingHash to the first element of siblingHashes
            remove the first element of siblingHashes

        let d be the digit at position (h-1) of binaryKey
        if d == 0:
            update q.hash to branchHash(q.hash, siblingHash)
        else if d == 1:
            update q.hash to branchHash(siblingHash, q.hash)

        remove the first digit of q.binaryBitmap
        sortedQueries=sortByBitmapAndKey(sortedQueries)
        sortedQueries=filterQueries(sortedQueries)

    throw error
```

```java
function verify(queryKeys, proof, merkleRoot):
    // check that the proof is valid with respect to queryKeys
    if length of queryKeys != length of proof.queries:
        return false
    for each query q in proof.queries:
        let k be the corresponding key in queryKeys (the element of queryKeys with same index)
        // q is an inclusion proof for k or a default empty node
        if q.key == k:
            continue
        // q is an inclusion proof for another leaf node
        let binaryResponseBitmap = binaryExpansion(q.bitmap) without leading zeros
        let binaryResponseKey=binaryExpansion(q.key)
        let binaryQueryKey=binaryExpansion(k)
        let sharedPrefix = the common prefix of binaryResponseKey and binaryQueryKey
        if length of binaryResponseBitmap > length of sharedPrefix:
            // q does not give an non-inclusion proof for k
            return false

    // calculate the new Merkle root from the proof
    let calculatedRoot = calculateRoot(proof.siblingHashes, proof.queries)
    return calculatedRoot == merkleRoot
```
#### Proof Serialization

The inclusion proof is serialized according to the specifications defined in [LIP 0027](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0027.md) using the following JSON schema:

```java
proof = {
  "type": "object",
  "required": ["siblingHashes", "queries"],
  "properties": {
    "siblingHashes": {
      "type": "array",
      "items": {"dataType": "bytes"},
      "fieldNumber": 1 },
    "queries": {
      "type": "array",
      "items": {
        "type": "object",
        "fieldNumber": 2,
        "required": ["key", "value", "bitmap"],
        "properties": {
          "key": {
            "dataType": "bytes",
            "fieldNumber": 1 },
          "value": {
            "dataType": "bytes",
            "fieldNumber": 2 },
          "bitmap": {
            "dataType": "bytes",
            "fieldNumber": 3 },
        }
      }
    }
  }
}
```

## Backwards Compatibility

This proposal does not introduce any fork(s) in the network, as it only defines the specification of sparse Merkle trees in the Lisk protocol.

## References

[1] Rasmus Dahlberg, Tobias Pulls, and Roel Peeters, [Efficient Sparse Merkle Trees](https://eprint.iacr.org/2016/683.pdf)

[2] Jellyfish Merkle tree, github.com/diem/diem/tree/master/storage/jellyfish-merkle/src
