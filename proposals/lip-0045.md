```
LIP: 0045
Title: Introduce Interoperability module
Author: Alessandro Ricottone <alessandro.ricottone@lightcurve.io>
        Mitsuaki Uchimoto <mitsuaki.uchimoto@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-interoperability-module/290
Status: Draft
Type: Standards Track
Created: 2021-05-21
Updated: 2021-12-01
```

## Abstract

The Interoperability module provides basic functionalities to transmit information between interoperable chains in the Lisk ecosystem using cross-chain messages. In this LIP the properties, serialization, and initial values of this module are specified. Additionally, this LIP also provides a broad overview of the Lisk interoperability solution, motivating several design choices and presenting the new commands that are part of the Interoperability module.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

Interoperability has the potential to solve the scaling issue of blockchains: Instead of deploying applications and their corresponding commands onto a single blockchain, these are implemented into separate blockchains which then communicate with each other using an interoperability protocol.

To achieve interoperability, chains in the Lisk ecosystem (the mainchain and the sidechains participating in interoperability) exchange information via _cross-chain transactions_. As an example, a user can issue a cross-chain transaction to transfer part of its mainchain LSK balance to a sidechain, and subsequently use it to issue one of the sidechain custom commands.

In the Lisk protocol, cross-chain transactions are special in that, after being included in their origin ledger, some new data structures, the _cross-chain messages_ (CCMs), are created, which are transmitted to other chains via special commands called _cross-chain update_ (CCU) commands. CCUs also contain information about the chain, in the form of a _certificate_.

One of the main motivations for proposing a [certificate-based communication](https://lisk.com/blog/research/introduction-blockchain-interoperability) between chains is the ability for all chains in the ecosystem to remain state machines. This means that all information needed to validate and advance a chain to the next block is present on the chain itself.  In the Lisk interoperability solution, the only information that needs social consensus is information about the initial validators of the other chain. On the mainchain, this information is received via the sidechain registration command; on sidechains, in a similar way, via the mainchain registration command.

The Interoperability module provides the data structures and functionalities necessary for interoperability between chains of the Lisk ecosystem. In this LIP, we specify the properties, serialization, and initial values of the Interoperability module.

## Rationale

### Interoperability Commands

The Interoperability module stores the properties necessary to validate and process the following new commands.

#### [Sidechain Registration Command][lip-0043]

The sidechain registration command is used to register a sidechain on the Lisk mainchain. When this command is processed, a new account for the sidechain is created in the mainchain state under the interoperability store. The account is initialized with an empty inbox and outbox, while the sidechain name and the initial validators set are given in the command parameters. The network ID is calculated from the address of the command sender and the genesis block ID, also given in the command parameters.

#### [Mainchain Registration Command][lip-0043]

The mainchain registration command is used to register the Lisk mainchain on a sidechain. When this command is processed, a new account for the mainchain is created in the sidechain state under the interoperability store. The account is initialized with an empty inbox and outbox, while the initial validators set is given in the command parameters. The name and network ID of the mainchain are global protocol constants in the whole ecosystem.

This command also initializes another data structure in the interoperability store, containing some information about the sidechain itself. In particular, it sets the sidechain name and chain ID to the ones that have been previously registered on the mainchain via the sidechain registration command.

#### [Cross-Chain Update Commands][lip-0053]

<img src="lip-0045/ccu.png" width="80%">

_Figure 1: A sketch of an interoperability interaction between the Lisk mainchain and a sidechain. Information (cross-chain messages and updated state) from mainchain blocks (light blue) is collected into a cross-chain update command by the relayer, which then posts it on the sidechain._

CCUs are used to post the updated state of the sending chain on the receiving chain. Furthermore, they transmit the cross-chain messages that need to be sent to the receiving chain (see Figure 1). We introduce two different CCUs, one for posting on the Lisk mainchain, and the other for posting on sidechains. They differ in the way the included messages are handled: on the mainchain, messages targeting another sidechain are forwarded to that sidechain outbox, while messages targeting the mainchain are simply processed. On the other hand, a CCU posted on a sidechain can only contain CCMs targeting that sidechain, being invalid otherwise.


#### [State Recovery Command][lip-0054]

This command is used to recover a certain state (for example fungible and non-fungible tokens) from a sidechain that has been terminated. The user proves the existence of an entry in the terminated state substore with an inclusion proof. The proof is validated against the current state root stored in the terminated chain account. The recovery of the state is then handled by the relevant module (for example the token module would refund the user).

#### [Message Recovery Command][lip-0054]

This command is used to recover a pending message from the outbox of a terminated chain. The user proves with an inclusion proof that the message is in the terminated sidechain outbox. The proof is validated against the outbox root stored in the terminated outbox account. The recovered message is then bounced back to the original sending chain or processed directly (if the sending chain is the mainchain).

#### [State Recovery Initialization Command][lip-0054]

This command is used to initialize a terminated state account on a sidechain. The user proves with an inclusion proof that the target chain state on the mainchain implies that that chain is terminated (either the status is set to 'terminated' or the liveness condition is violated). Once the terminated state account has been initialized, the state recovery command can be issued in the sidechain.

#### [Message Recovery Initialization Command][lip-0054]

This command is used to initialize a terminated outbox account and can only be issued after the corresponding terminated state account has been created. This command contains the chain account of the current chain as stored in the state of the terminated chain and an inclusion proof for it against the state root stored in the corresponding terminated state account. Once the terminated outbox account has been initialized, the message recovery command can be issued.

### Liveness Condition

Active sidechains are required to prove their liveness to the mainchain at least once every 30 days. This is done by including a CCU on the mainchain. If a sidechain does not post a CCU within 30 days, the sidechain account is terminated. This rule guarantees that users do not send funds to inactive sidechains and that users who have tokens in a sidechain which stops communicating with the ecosystem can recover their tokens.

### Life Cycle of a Sidechain

The life cycle of a sidechain can be split into 3 parts, corresponding to the 3 values of the account status property: ''registered'', ''active'', and ''terminated''.

A sidechain registers on the mainchain with a [sidechain registration command][lip-0043]. This command creates the sidechain account on the mainchain. In particular, it creates an entry in the chain data substore, with initial status set to 'registered'; an entry in the channel data substore, with empty inbox and outbox; and an entry in the validators data substore, holding the initial sidechain validators set. Thereafter, the mainchain account is similarly created on a sidechain with a [mainchain registration command][lip-0043].

After a sidechain has been registered on the mainchain, it cannot receive any cross-chain message and does not need to follow the liveness rule, until the first sidechain CCU has been included in the mainchain. At this point, the status of the sidechain account on the mainchain is updated to ''active'' and the liveness requirement is enforced.

If no CCU is received within 30 days, the [chain account is terminated](#terminateChain) and no more CCMs can be sent to or received from the sidechain. A sidechain account can also be terminated if the sidechain posts a CCU containing a CCM with an invalid schema or with an invalid sending chain ID. A message targeting a terminated chain is bounced on the mainchain instead of being forwarded. When this happens, a ''terminated sidechain'' message is emitted by the mainchain, targeting the original sending chain. When this message is processed, the chain is also terminated in the sending chain, blocking future messages.

When a chain is terminated, a 'terminated state' account is created, storing the last certified state root of the terminated chain. Then, users can recover tokens from the terminated sidechain with a state recovery command or proceed with the message recovery initialization command to kick-off the recovery of pending cross-chain messages.

### Properties of the Interoperability Module

Each interoperable sidechain maintains a chain account, channel, and the chain validators for the mainchain, while the mainchain maintains these data structures for each registered sidechain. Correspondingly, on a sidechain we denote with ''partner chain'' the mainchain, while on the mainchain we denote with ''partner chain'' the relevant sidechain.

Each chain also includes an account storing the chain name and ID in the ecosystem as well as the current chain nonce. This ''own chain'' account is present by default in the mainchain, while on a sidechain is created by the mainchain registration command.

<img src="lip-0045/interoperability_store.png" width="80%">

_Figure 2: A summary of the Interoperability module store: Each box represents a substore, where we indicate the `storeKey --> storeValue` relation. The Interoperability module defines 7 substores on a sidechain: the outbox substore for outbox roots, the chain data substore for partner chain accounts and the own chain data substore for the own chain account, the channel data substore keeping track of the inbox and outbox, the validators data substore storing the partner-chain validators set, and the terminated state and terminated outbox substores to allow for recovery commands. The name and network ID stores, keeping track of the names and network IDs of registered sidechains, are present only on the mainchain._

### Message Forwarding and the Role of the Lisk Mainchain

In the Lisk ecosystem, the Lisk mainchain plays a central role, distinct from any other chain. It acts as an intermediary chain, [relaying cross-chain messages between sidechains][lip-0053]. This has a few notable advantages:

1. Relayers only need to follow the chosen sidechain and the mainchain. All CCMs sent to a given chain will go through the sidechain outbox on the mainchain.
2. The mainchain guarantees that messages are available and can be delivered to active sidechains. In the case in which the receiving sidechain is not active, the messages are returned to their sending chain. This allows the sidechain protocol to remain simple and agnostic to the state of other sidechains. In particular, transaction handling does not require knowledge of all potential receiving chains.

### Inbox and Outbox

As explained above, inbox and outbox are organized as regular Merkle trees. Since the root of the tree depends on the order of insertion, all cross-chain messages have to be inserted in the receiving chain in the same order in which they were included in the sending chain, guaranteeing that they are processed in the correct order.

Using a Merkle tree also guarantees that the number of sibling hashes that are part of inclusion proofs grows only logarithmically with the number of elements in the tree. In particular, this means that the number of sibling hashes required to validate the cross-chain messages in a CCU against the partner chain `lastCertificate.stateRoot` grows logarithmically with the number of processed messages.

#### Storage of the Outbox Root

The outbox root property is duplicated and additionally stored separately from all other properties of the chain account. The store prefix of the outbox root is the constant `STORE_PREFIX_OUTBOX_ROOT` and the store key is the hash of the chain ID of the partner chain. Storing the outbox root with a different store prefix allows to separate the subtree corresponding to the outbox roots from the rest of the data in the interoperability store. This choice allows for shorter inclusion proofs for the outbox root, as the other properties of the Interoperability module are not needed to recalculate the state root if the outbox root is known. In particular, the inclusion proof contained in a CCU from a sidechain posted on the mainchain will contain only one hash.

### Storage of Auxiliary Data

In order to process sidechain registration commands more efficiently, it is convenient to store on the mainchain auxiliary data that can be used to check the uniqueness of the sidechain name and network ID. For instance, if an entry is already present in the name auxiliary data, it means that a chain with that name is already registered in the ecosystem.  

## Specification

In this section, we specify the substores that are part of the Interoperability module store and the functions exposed to other modules. The Interoperability module has module ID `MODULE_ID_INTEROPERABILITY` (see the [table below](#Notation-and-Constants)).

### Notation and Constants

We define the following constants:

| Name                                          | Type   | Value            | Description                                           |
|-----------------------------------------------|--------|------------------|-------------------------------------------------------|
| **Interoperability Constants**                |        |                  |                                                       |
| `MODULE_ID_INTEROPERABILITY`                  | uint32 | 64               | ID of the Interoperability module.                    |
| `MAINCHAIN_ID`                                | uint32 | 1                | Chain ID of the Lisk mainchain.                       |
| `MAINCHAIN_NAME`                              | string | "lisk-mainchain" | Name of the Lisk mainchain.                           |
| `MAINCHAIN_NETWORK_ID`                        | bytes  | TBD              | Network identifier of the Lisk mainchain.             |
| **Interoperability Store**                    |        |                  |                                                       |
| `STORE_PREFIX_OUTBOX_ROOT`                    | bytes  | 0x0000           | Store prefix of the outbox root substore.             |
| `STORE_PREFIX_CHAIN_DATA`                     | bytes  | 0x8000           | Store prefix of the chain data substore.              |
| `STORE_PREFIX_OWN_CHAIN_DATA`                 | bytes  | 0xb000           | Store prefix of the own chain data substore.          |
| `STORE_PREFIX_CHANNEL_DATA`                   | bytes  | 0xa000           | Store prefix of the channel data substore.            |
| `STORE_PREFIX_CHAIN_VALIDATORS`               | bytes  | 0x9000           | Store prefix of the chain validators substore.        |
| `STORE_PREFIX_TERMINATED_STATE`               | bytes  | 0xc000           | Store prefix of the terminated state substore.        |
| `STORE_PREFIX_TERMINATED_OUTBOX`              | bytes  | 0xd000           | Store prefix of the terminated outbox substore.       |
| `STORE_PREFIX_REGISTERED_NAMES`               | bytes  | 0xe000           | Store prefix of the chain names substore.             |
| `STORE_PREFIX_REGISTERED_NETWORK_IDS`         | bytes  | 0xf000           | Store prefix of the chain network IDs substore.       |
| **Interoperability Command IDs**              |        |                  |                                                       |
| `COMMAND_ID_SIDECHAIN_REG`                    | uint32 | 0                | Command ID of sidechain registration command.         |
| `COMMAND_ID_MAINCHAIN_REG`                    | uint32 | 1                | Command ID of mainchain registration command.         |
| `COMMAND_ID_SIDECHAIN_CCU`                    | uint32 | 2                | Command ID of sidechain cross-chain update command.   |
| `COMMAND_ID_MAINCHAIN_CCU`                    | uint32 | 3                | Command ID of mainchain cross-chain update command.   |
| `COMMAND_ID_STATE_RECOVERY`                   | uint32 | 4                | Command ID of state recovery initialization command.  |
| `COMMAND_ID_MESSAGE_RECOVERY`                 | uint32 | 5                | Command ID of message recovery command.               |
| `COMMAND_ID_STATE_RECOVERY_INITIALIZATION`    | uint32 | 6                | Command ID of message recovery initialization command.|
| `COMMAND_ID_MESSAGE_RECOVERY_INITIALIZATION`  | uint32 | 7                | Command ID of initiate recovery command.              |
| `CROSS_CHAIN_COMMAND_ID_REGISTRATION`         | uint32 | 0                | Cross-chain command ID of chain registration CCM.     |
| `CROSS_CHAIN_COMMAND_ID_CHANNEL_TERMINATED`   | uint32 | 1                | Cross-chain command ID of channel terminated CCM.     |
| `CROSS_CHAIN_COMMAND_ID_SIDECHAIN_TERMINATED` | uint32 | 2                | Cross-chain command ID of sidechain terminated CCM.   |
| **Chain Status**                              |        |                  |                                                       |
| `CHAIN_REGISTERED`                            | uint32 | 0                | Chain registered status.                              |
| `CHAIN_ACTIVE`                                | uint32 | 1                | Chain active status.                                  |
| `CHAIN_TERMINATED`                            | uint32 | 2                | Chain terminated status.                              |
| **Message Status and Errors**                 |        |                  |                                                       |
| `CCM_STATUS_OK`                               | uint32 | 0                | Regular message status.                               |
| `CCM_STATUS_MODULE_NOT_SUPPORTED`             | uint32 | 1                | Status assigned to CCMs when module is not supported. |
| `CCM_STATUS_CROSS_CHAIN_COMMAND_NOT_SUPPORTED`| uint32 | 2                | Status assigned to CCMs when command is not supported.|
| `CCM_STATUS_CHANNEL_UNAVAILABLE`              | uint32 | 3                | Status assigned to CCMs when channel is unavailable.  |
| `CCM_STATUS_RECOVERED`                        | uint32 | 4                | Status assigned to CCMs after recovery.               |
| **General Constants**                         |        |                  |                                                       |
| `EMPTY_HASH`                                  | bytes  | SHA-256("")      | Hash of empty bytes.                                  |
| `LIVENESS_LIMIT`                              | uint32 | 30x24x3600       | The maximum time interval for the liveness condition. |
| `MAX_NUM_VALIDATORS`                          | uint32 | 199              | The maximum number of validators that can be registered.|
| `MAX_UINT64`                                  | uint64 | 18446744073709551615  | The maximum value that can be encoded in a uint64.|
| `MAX_RESERVED_ERROR_STATUS`                   | uint64 | 63               | The largest error code reserved for the Interoperability module.|
| `EMPTY_BYTES`                                 | bytes  | ""               | The empty byte string. |
| `EMPTY_FEE_ADDRESS`                           | bytes  | ""               | The empty byte string. |

#### uint32be Function

The function `uint32be(x)` returns the big endian uint32 serialization of an integer `x`, with `0 <= x < 2^32`. This serialization is always 4 bytes long.

### Interoperability Module Store

The key-value pairs in the module store are organized in the following substores.

#### Outbox Root Substore

The outbox root substore holds the root of the outbox of each partner chain.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_OUTBOX_ROOT`.
* Each store key is set to `uint32be(chainID)`, where `chainID` is the ID of the partner chain.
* Each store value is the serialization of an object following the JSON schema `outboxRootSchema` presented below.
* Notation: For the rest of this proposal let `outboxRoot(chainID)` be the outbox root identified by the store key `chainID`.

##### JSON Schema

```java
outboxRootSchema = {
    "type": "object",
    "required": ["root"],
    "properties": {
        "root": {
            "dataType": "bytes",
            "fieldNumber": 1
        }
    }
}
```

##### Properties and Default values

* `root`: The root of the underlying Merkle tree of the partner chain outbox. This value is initialized to `EMPTY_HASH`.

#### Chain Data Substore

The chain data substore holds information about other partner chains.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_CHAIN_DATA`.
* Each store key is set to `uint32be(chainID)`, where `chainID` is the ID of the partner chain.
* Each store value is the serialization of an object following the JSON schema `chainAccountSchema` presented below.
* Notation: For the rest of this proposal let `chainAccount(chainID)` be the chain account identified by the store key `chainID`.

##### JSON Schema

```java
chainAccountSchema = {
    "type": "object",
    "required": ["name", "networkID", "lastCertificate", "status"],
    "properties": {
        "name": {
            "dataType": "string",
            "fieldNumber": 1
        },
        "networkID": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "lastCertificate": {
            "type": "object",
            "fieldNumber": 3,
            "required": ["height", "timestamp", "stateRoot", "validatorsHash"],
            "properties": {
                "height": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "timestamp": {
                    "dataType": "uint32",
                    "fieldNumber": 2
                },
                "stateRoot": {
                    "dataType": "bytes",
                    "fieldNumber": 3
                },
                "validatorsHash": {
                    "dataType": "bytes",
                    "fieldNumber": 4
                }
            }
        },
        "status": {
            "dataType": "uint32",
            "fieldNumber": 4
        }
    }
}
```

##### Properties and Default values

In this section, we describe the properties of a chain account and specify their default values.

* `name`: This property corresponds to the name of the sidechain as a string of characters. It has to be unique in the ecosystem. For the mainchain account on a sidechain, this property is initialized to the string `MAINCHAIN_NAME`. For a sidechain account on the mainchain, this property is set by the sidechain registration command.
* `networkID`: This property corresponds to the network identifier, or network ID, of the partner chain. For a sidechain account on the mainchain, it is set by the [sidechain registration command][lip-0043]. For the mainchain account on sidechains, it is a protocol constant, set to `MAINCHAIN_NETWORK_ID`.
* `lastCertificate`: This property holds some information from the certificate posted contained in the last CCU from the partner chain. It is an object containing the following properties:
    * `height`: The height contained in the last certificate from the partner chain. It is used to [validate a certificate][lip-0053] (certificates must contain block headers with increasing heights). The default value of this property is 0.
    * `timestamp`: The timestamp contained in the last certificate from the partner chain. On the mainchain, it is used to check that the sidechain chain fulfills the liveness requirement (see [above](#Liveness-Condition)). The default value of this property is 0.
    * `stateRoot`: The state root contained in the last certificate from the partner chain. It is used to validate the inclusion proof of the cross-chain messages contained in a CCU and to verify the validity of the token recovery command. The default value of this property is the constant `EMPTY_HASH`.
    * `validatorsHash`: The value of this property is set to the validators hash contained in the last certificate from the partner chain. This value always corresponds to the hash calculated from the validators data substore entry for the partner chain. The default value of this property is the constant `EMPTY_HASH`.
* `status`: This property stores the current status of the partner chain account. As explained [above](#Life-Cycle-of-a-Sidechain), there are 3 possible statuses: ''active'', ''registered'', and ''terminated''. The default value of this property is `CHAIN_REGISTERED`, corresponding to the "registered" status.

#### Channel Data Substore

The channel data substore holds information about the inbox and outbox with other partner chains.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_CHANNEL_DATA`.
* Each store key is set to `uint32be(chainID)`, where `chainID` is the ID of the partner chain.
* Each store value is the serialization of an object following the JSON schema `channelSchema` presented below.
* Notation: For the rest of this proposal let `channel(chainID)` be the channel identified by the store key `chainID`.

##### JSON Schema

```java
channelSchema = {
    "type": "object",
    "required": ["inbox", "outbox", "partnerChainOutboxRoot", "messageFeeTokenID"],
    "properties": {
        "inbox": {
            "type": "object",
            "fieldNumber": 1,
            "required": ["appendPath", "size", "root"],
            "properties": {
                "appendPath": {
                    "type": "array",
                    "items": {
                        "dataType": "bytes"
                    },
                    "fieldNumber": 1
                },
                "size": {
                    "dataType": "uint64",
                    "fieldNumber": 2
                },
                "root": {
                    "dataType": "bytes",
                    "fieldNumber": 3
                }
            }
        },
        "outbox": {
            "type": "object",
            "fieldNumber": 2,
            "required": ["appendPath", "size", "root"],
            "properties": {
                "appendPath": {
                    "type": "array",
                    "items": {
                        "dataType": "bytes"
                    },
                    "fieldNumber": 1
                },
                "size": {
                    "dataType": "uint64",
                    "fieldNumber": 2
                },
                "root": {
                    "dataType": "bytes",
                    "fieldNumber": 3
                }
            }
        },
        "partnerChainOutboxRoot": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "messageFeeTokenID": {
            "type": "object",
            "fieldNumber": 4,
            "required": ["chainID", "localID"],
            "properties": {
                "chainID": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "localID": {
                    "dataType": "uint32",
                    "fieldNumber": 2
                }
            }
        }
    }
}
```

##### Properties and Default values

In this section, we describe the properties of a channel and specify their default values.

* `inbox`: The data structure containing information about the cross-chain messages received from the partner chain, organized in a regular Merkle tree (specified for the Lisk protocol in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md#regular-merkle-trees)). The underlying Merkle tree of the inbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md). It contains the following properties:
  * `root`:  The root of the Merkle tree. The default value of this property is `EMPTY_HASH`.
  * `appendPath`: An array of hashes necessary to append new data to the tree efficiently. The default value of this property is an empty array.
  * `size`: The current size of the tree, i.e. the number of cross-chain messages received from the partner chain and processed. The default value of this property is 0.
* `outbox`: The data structure containing information about the cross-chain messages sent to the partner chain, organized in a regular Merkle tree. The underlying Merkle tree of the outbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md). It contains the following properties:
  * `root`:  The root of the Merkle tree. The default value of this property is `EMPTY_HASH`.
  * `appendPath`: An array of hashes necessary to append new data to the tree efficiently. The default value of this property is an empty array.
  * `size`: The current size of the tree, i.e. the number of cross-chain messages sent to the partner chain. The default value of this property is 0.
* `partnerChainOutboxRoot`: The value of this property is set to the outbox root computed from the last CCU from the partner chain. It is used to validate the cross-chain messages contained in a future CCU when the CCU does not certify a new outbox root. The default value of this property is the constant `EMPTY_HASH`.
* `messageFeeTokenID`: This property is an object storing a `chainID` and a `localID`. These values together form the token ID of the token used to pay for the cross-chain message fees. The default values are `chainID = 1` and `localID = 0`, corresponding to the LSK token. 

#### Chain Validators Substore

The chain validators substore holds information about the validators of other partner chains.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_CHAIN_VALIDATORS`.
* Each store key is set to `uint32be(chainID)`, where `chainID` is the ID of the partner chain.
* Each store value is the serialization of an object following the JSON schema `validatorsSchema` presented below.
* Notation: For the rest of this proposal let `validators(chainID)` be the set of active validators for the chain identified by the store key `chainID`.

##### JSON Schema

```java
validatorsSchema = {
    "type": "object",
    "required": ["activeValidators", "certificateThreshold"],
    "properties": {
        "activeValidators": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["blsKey", "bftWeight"],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "certificateThreshold": {
            "dataType": "uint64",
            "fieldNumber": 2
        }
    }
}
```

##### Properties and Default values

In this section, we describe the properties of a chain account and specify their default values.

* `inbox`: The data structure containing information about the cross-chain messages received from the partner chain, organized in a regular Merkle tree (specified for the Lisk protocol in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md#regular-merkle-trees)). The underlying Merkle tree of the inbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md). It contains the following properties:
  * `root`:  The root of the Merkle tree. The default value of this property is `EMPTY_HASH`.
  * `appendPath`: An array of hashes necessary to append new data to the tree efficiently. The default value of this property is an empty array.
  * `size`: The current size of the tree, i.e. the number of cross-chain messages received from the partner chain and processed. The default value of this property is 0.
* `outbox`: The data structure containing information about the cross-chain messages sent to the partner chain, organized in a regular Merkle tree. The underlying Merkle tree of the outbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md). It contains the following properties:
  * `root`:  The root of the Merkle tree. The default value of this property is `EMPTY_HASH`.
  * `appendPath`: An array of hashes necessary to append new data to the tree efficiently. The default value of this property is an empty array.
  * `size`: The current size of the tree, i.e. the number of cross-chain messages sent to the partner chain. The default value of this property is 0.
* `networkID`: This property corresponds to the network identifier, or network ID, of the partner chain. For a sidechain account on the mainchain, it is set by the [sidechain registration command][research:chain-registration]. For the mainchain account on sidechains, it is a protocol constant, set to `MAINCHAIN_NETWORK_ID`.
* `lastCertifiedStateRoot`: The value of this property is set to the state root contained in the last CCU from the partner chain. It is used to validate the inclusion proof of the cross-chain messages contained in a CCU and to verify the validity of the token recovery command. The default value of this property is the constant `EMPTY_HASH`.
* `lastCertifiedTimestamp`: The value of this property is set to the timestamp contained in the last CCU from the partner chain. On the mainchain, it is used to check that the sidechain chain fulfills the liveness requirement (see [above](#Liveness-Condition)). The default value of this property is 0.
* `lastCertifiedHeight`: The value of this property is set to the height contained in the last certificate from the partner chain. It is used to [validate a certificate][research:ccu] (certificates must contain block headers with increasing heights). The default value of this property is 0.
* `partnerChainOutboxRoot`: The value of this property is set to the outbox root computed from the last CCU from the partner chain. It is used to validate the cross-chain messages contained in a future CCU when the CCU does not certify a new outbox root. The default value of this property is the constant `EMPTY_HASH`.
* `partnerChainOutboxSize`: This property corresponds to the size of the outbox tree of the partner chain, i.e. the number of cross-chain messages sent from the partner chain. This property is updated by the [`inboxUpdate property`][research:ccu] contained in CCUs from the partner chain. The default value of this property is 0.
* `partnerChainInboxSize`: This property corresponds to the size of the inbox tree of the partner chain, i.e. the number of cross-chain messages received and processed by the partner chain. This property is used to verify the validity of the message recovery command and it is updated by a [cross-chain update receipt message][research:ccm] from the partner chain. The default value of this property is 0.
* `name`: This property corresponds to the name of the sidechain as a string of characters. It has to be unique in the ecosystem. For the mainchain account on a sidechain, this property is initialized to the string `MAINCHAIN_NAME`. For a sidechain account on the mainchain, this property is set by the sidechain registration command.
* `status`: This property stores the current status of the partner chain account. As explained [above](#Life-Cycle-of-a-Sidechain), there are 3 possible statuses: ''active'', ''registered'', and ''terminated''. The default value of this property is `CHAIN_REGISTERED`, corresponding to the "registered" status.
* `activeValidators`: An array of objects corresponding to the set of validators eligible to sign the certificates from the partner chain. Each entry contains the following properties:
  * `blsKey`: The BLS public key used to sign certificates.
  * `bftWeight`: An integer indicating the weight of the corresponding BLS public key for signing a certificate. For DPoS chains, this value is usually 1, as every active validator has the same consensus weight for the signing of the next certificate.
* `certificateThreshold`: An integer setting the required cumulative weight needed for the certificate signature to be valid.
For the mainchain account on a sidechain, the `activeValidators` and `certificateThreshold` properties are initialized by the mainchain registration command. For a sidechain account on the mainchain, they are set by the sidechain registration command.


#### Own Chain Data

The own chain data substore stores the name and ID of the chain.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_OWN_CHAIN_DATA`.
* The store key is set to `EMPTY_BYTES`.
* The store value is the serialization of an object following the JSON schema `ownChainAccountSchema` presented below.
* Notation: For the rest of this proposal let `ownChainAccount` be the own chain account.

##### JSON Schema

```java
ownChainAccountSchema = {
    "type": "object",
    "required": ["name", "ID", "nonce"],
    "properties": {
        "name": {
            "dataType": "string",
            "fieldNumber": 1
        },
        "ID": {
            "dataType": "uint32",
            "fieldNumber": 2
        },
        "nonce": {
            "dataType": "uint64",
            "fieldNumber": 3
        }
    }
}
```

##### Properties and Default values

* `name`: The name of the sidechain registered on the mainchain with the sidechain registration command.
* `chainID`: The chain ID assigned to the sidechain on the mainchain after processing the sidechain registration command.
* `nonce`: The chain nonce, an incremental integer indicating the total number of CCMs sent from the chain.

On the manchain, the own chain account is present by default, set to an object with properties:

* `name=MAINCHAIN_NAME`,
* `ID=MAINCHAIN_ID`,
* `nonce=0`,

serialized with the JSON schema `ownChainAccountSchema`.

On a sidechain, the own chain account is initialized as part of the mainchain registration command processing.

#### Terminated State Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_TERMINATED_STATE`.
* The store key is set to `uint32be(chainID)`, where `chainID` is the ID of the terminated chain.
* The store value is the serialization of an object following the JSON schema `terminatedStateSchema` presented below.
* Notation: For the rest of this proposal let `terminatedStateAccount(chainID)` be the terminated state account corresponding to the store key `chainID`.

##### JSON Schema

```java
terminatedStateSchema = {
    "type": "object",
    "required": ["stateRoot"],
    "properties": {
        "stateRoot": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "mainchainStateRoot": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "initialized": {
            "dataType": "boolean",
            "fieldNumber": 3
        }
    }
}
```
##### Properties and Default values

* `stateRoot`: The state root of the terminated chain, initialized to `chainAccount(chainID).lastCertificate.stateRoot`, where `chainID` is the chain ID of the terminated chain. If the account is not initialized, it is set to `EMPTY_BYTES` instead.
* `mainchainStateRoot`: The state root of the mainchain at the moment in which the chain was terminated, set to `chainAccount(MAINCHAIN_ID).lastCertificate.stateRoot` for non-initialized terminated state accounts. If the account is initialized, it is set to `EMPTY_BYTES` instead.
* `initialized`: A boolean value, indicating whether the terminated state account has been initialized, i.e. if the `stateRoot` property has been set.
  
A terminated state account is created as part of the `terminateChainInternal` internal function, as part of the processing of a sidechain terminated CCM or as part of the processing of a state recovery initialization command.

#### Terminated Outbox Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_TERMINATED_OUTBOX`.
* The store key is set to `uint32be(chainID)`, where `chainID` is the ID of the terminated chain.
* The store value is the serialization of an object following the JSON schema `terminatedOutboxSchema` presented below.
* Notation: For the rest of this proposal let `terminatedOutboxAccount(chainID)` be the terminated outbox account corresponding to the store key `chainID`.

##### JSON Schema

```java
terminatedOutboxSchema = {
    "type": "object",
    "required": ["outboxRoot", "outboxSize", "partnerChainInboxSize"],
    "properties": {
        "outboxRoot": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "outboxSize": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "partnerChainInboxSize": {
            "dataType": "uint64",
            "fieldNumber": 3
        }
    }
}
```
##### Properties and Default values

* `outboxRoot`: The outbox root of the terminated chain, initialized to `channel(chainID).outbox.root`, where `chainID` is the chain ID of the terminated chain.
* `outboxSize`: The outbox size of the terminated chain, set to `channel(chainID).outbox.size`, where `chainID` is the chain ID of the terminated chain.
* `partnerChainInboxSize`: The number of cross-chain messages  processed in the terminated chain, set to the `partnerChainInboxSize` property contained in the message recovery initialization command.

A terminated outbox account is created as part of the processing of a message recovery initialization command.

#### Registered Names Substore

This substore contains the names of all chains in the ecosystem. It is present only on the mainchain. Entries are created as part of the processing of the sidechain registration command.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_REGISTERED_NAMES`.
* The store key is set to `name`, serialized as a utf-8 encoded string, where `name` is the name of the registered chain.
* The store value is the serialization of an object following the JSON schema `chainIDSchema` presented below.

##### JSON Schema

```java
chainIDSchema = {
    "type": "object",
    "required": ["ID"],
    "properties": {
        "ID": {
            "dataType": "uint32",
            "fieldNumber": 1
        }
    }
}
```

##### Properties and Default values

* `ID`: The ID of the chain.

An entry for the mainchain is present by default, where:

* The store key is set to `MAINCHAIN_NAME`.
* The store value is an object with `chainID=MAINCHAIN_ID`, serialized using the JSON schema `chainIDSchema`.

#### Registered Network IDs Substore

This substore contains the network IDs of all chains in the ecosystem. It is present only on the mainchain. Entries are created as part of the processing of the sidechain registration command.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_REGISTERED_NETWORK_IDS`.
* The store key is set to `networkID`, serialized as bytes, where `networkID` is the network ID of the registered chain.
* The store value is the serialization of an object following the JSON schema `chainIDSchema` presented below.

##### JSON Schema

```java
chainIDSchema = {
    "type": "object",
    "required": ["ID"],
    "properties": {
        "ID": {
            "dataType": "uint32",
            "fieldNumber": 1
        }
    }
}
```

##### Properties and Default values

* `ID`: The ID of the chain.

An entry for the mainchain is present by default, where:

* The store key is set to `MAINCHAIN_NETWORK_ID`.
* The store value is an object with `chainID=MAINCHAIN_ID`, serialized using the JSON schema `chainIDSchema`.

### Internal Functions

#### appendToInboxTree

The `appendToInboxTree` function appends a new element to the underlying Merkle tree of the inbox of a chain account.

##### Parameters

This function has the following input parameters in the order given below:

* `chainID`: The partner chain ID.
* `appendData`: A bytes value.

##### Returns

Nothing.

##### Execution

```python
appendToInboxTree(chainID, appendData):
    # Update root, appendPath, and size
    let inboxTree be the underlying Merkle tree of channel(chainID).inbox
    inboxTree.append(SHA-256(appendData))
    channel(chainID).inbox.root = inboxTree.root
    channel(chainID).inbox.appendPath = inboxTree.appendPath
    channel(chainID).inbox.size = inboxTree.size
```

#### appendToOutboxTree

The `appendToOutboxTree` function appends a new element to the underlying Merkle tree of the outbox of a chain account.

##### Parameters

This function has the following input parameters in the order given below:

* `chainID`: The partner chain ID.
* `appendData`: A bytes value.

##### Returns

Nothing.

##### Execution

```python
appendToOutboxTree(chainID, appendData):
    # Update root, appendPath, and size
    let outboxTree be the underlying Merkle tree of channel(chainID).outbox
    outboxTree.append(SHA-256(appendData))
    channel(chainID).outbox.root = outboxTree.root
    channel(chainID).outbox.appendPath = outboxTree.appendPath
    channel(chainID).outbox.size = outboxTree.size
```

#### addToOutbox

The `addToOutbox` function adds a new CCM to the outbox of a chain account.

##### Parameters

This function has the following input parameters in the order given below:

* `chainID`: The partner chain ID.
* `ccm`: The cross-chain message to be added.

##### Returns

Nothing.

##### Execution

```python
addToOutbox(chainID, ccm):
    serializedMessage = byte array corresponding to the serialized ccm according to the schema in LIP 0049
    appendToOutboxTree(chainID, serializedMessage)
    outboxRoot(chainID) = channel(chainID).outbox.root
```

#### isLive

The `isLive` function checks the liveness requirement for the partner chain.

##### Parameters

This function has the following input parameters in the order given below:

* `chainID`: The partner chain ID.

##### Returns

A boolean indicating whether the partner chain respects the liveness condition.

##### Execution

```python
isLive(chainID):
    # Check if chain has been already terminated
    if terminatedStateAccount(chainID) exists:
        return False

    # Processing on the mainchain
    if ownChainAccount.ID == MAINCHAIN_ID:
        # Check liveness condition
        timestamp = timestamp of the block where this state transition is processed
        if timestamp - chainAccount(chainID).lastCertificate.timestamp > LIVENESS_LIMIT:
            return False

    return True
```

#### validateFormat

The `validateFormat` function checks that a CCM follows the correct schema and does not exceed a size limit of 10KB. It is specified in [LIP 0049][lip-0049].

#### apply

The `apply` function applies a CCM. It is specified in [LIP 0049][lip-0049].

#### forward

The `forward` function forwards a CCM to the specified receiving chain. 
This function is only called on the mainchain when processing a CCU. It is specified in [LIP 0049][lip-0049].

#### bounce

The `bounce` function is used when a CCM cannot be forwarded. 
It returns the CCM back to the sending chain, with a `CCM_STATUS_CHANNEL_UNAVAILABLE` error status. 
This function is only called on the mainchain when processing a CCU. It is specified in [LIP 0049][lip-0049].

#### sendInternal

The `sendInternal` function is used to create and add a message to the outbox of a partner chain.

##### Parameters

This function has the following input parameters in the order given below:

* `feeAddress`: The address of the account paying the fee.
* `moduleID`: The ID of the module calling this function.
* `crossChainCommandID`: The ID of the command calling this function.
* `receivingChainID`: The ID of the receiving chain.
* `fee`: The message fee.
* `status`: The message status.
* `params`: The message parameters.

##### Returns

Nothing.

##### Execution

```python
sendInternal(feeAddress, moduleID, crossChainCommandID, receivingChainID, fee, status, params):
    # Processing on the mainchain
    if ownChainAccount.ID == MAINCHAIN_ID:
        # Chain has to exist on mainchain
        if chainAccount(receivingChainID) does not exists:
            raise MissingChainError
        partnerChainID = receivingChainID
    # Processing on a sidechain
    else:
        # Check for direct channel
        if chainAccount(receivingChainID) does not exists:
            partnerChainID = mainchainID
        else:
            partnerChainID = receivingChainID

    # Chain must be live; This checks is always on the receivingChainID
    if not isLive(receivingChainID):
        raise ChainNotLiveError
    # Chain status must be active
    if not chainAccount(partnerChainID).status == CHAIN_ACTIVE:
        raise ChainNotActiveError

    # Create cross-chain message
    ccm = {
        "nonce": ownChainAccount.nonce,
        "moduleID": moduleID,
        "crossChainCommandID": crossChainCommandID,
        "sendingChainID": ownChainAccount.ID,
        "receivingChainID": receivingChainID,
        "fee": fee,
        "status": status,
        "params": params
    }

    if validateFormat(ccm) == False:
        raise InvalidCCMFormatError 

    for each module mdl for which beforeSendCCM exists:
        mdl.beforeSendCCM(feeAddress, ccm)

    addToOutbox(partnerChainID, ccm)
    ownChainAccount.nonce += 1
```

#### terminateChainInternal

The `terminateChainInternal` function terminates a chain account.

##### Parameters

* `chainID`: The ID of the chain to be terminated.

##### Returns

Nothing.

##### Execution

```python
terminateChainInternal(chainID):
    sendInternal(
        EMPTY_FEE_ADDRESS, 
        MODULE_ID_INTEROPERABILITY, 
        CROSS_CHAIN_COMMAND_ID_CHANNEL_TERMINATED, 
        chainID, 
        0, 
        CCM_STATUS_OK, 
        EMPTY_BYTES
    )
    
    createTerminatedStateAccount(chainID)
```

#### createTerminatedStateAccount

The `createTerminatedStateAccount` function creates an entry in the terminated state substore.

##### Parameters

* `chainID`: The ID of the chain.
* `stateRoot`: The state root to be stored. If none is passed, it is deduced from the state.

##### Returns

Nothing.

##### Execution

```python
createTerminatedStateAccount(chainID, stateRoot = None):
    if stateRoot:
        if chainAccount(chainID) exists:
            chainAccount(chainID).status = CHAIN_TERMINATED
            remove the entry with storeKey = uint32be(chainID) from the outbox root substore

        terminatedState = {
            "stateRoot": stateRoot, 
            "mainchainStateRoot": EMPTY_BYTES,
            "initialized": True
        }

    elif chainAccount(chainID) exists:
        chainAccount(chainID).status = CHAIN_TERMINATED
        remove the entry with storeKey = uint32be(chainID) from the outbox root substore

        terminatedState = {
            "stateRoot": chainAccount(chainID).lastCertificate.stateRoot, 
            "mainchainStateRoot": EMPTY_BYTES,
            "initialized": True
        }
    # State root is not available, set it to empty bytes temporarily. 
    # This should only happen on a sidechain.
    else:
        # Processing on the mainchain
        if ownChainAccount.ID == MAINCHAIN_ID:
            # If the account does not exist on the mainchain, the input chainID is invalid.
            raise InvalidChainIDError

        terminatedState = {
            "stateRoot": EMPTY_BYTES,
            "mainchainStateRoot": chainAccount(MAINCHAIN_ID).lastCertificate.stateRoot, 
            "initialized": False
        }

    create an entry in the terminated state substore with 
        storeKey = uint32be(chainID) 
        storeValue = serialization of terminatedState
```

#### createTerminatedOutboxAccount

The `createTerminatedOutboxAccount` function creates an entry in the terminated outbox substore.

##### Parameters

* `chainID`: The ID of the chain.
* `outboxRoot`: The outbox root to be stored in the terminated outbox account.
* `outboxSize`: The outbox size to be stored in the terminated outbox account.
* `partnerChainInboxSize`: The partner chain inbox size to be stored in the terminated outbox account.

##### Returns

Nothing.

##### Execution

```python
createTerminatedOutboxAccount(chainID, outboxRoot, outboxSize, partnerChainInboxSize):
    terminatedOutbox = {
        "outboxRoot": outboxRoot, 
        "outboxSize": outboxSize, 
        "partnerChainInboxSize": partnerChainInboxSize
    }
    create an entry in the terminated outbox substore with
        storeKey = uint32be(chainID)
        storeValue = serialization of terminatedOutbox
```

### Commands

The Interoperability module contains the following commands:

* [Sidechain registration command][lip-0043]
* [Mainchain registration command][lip-0043]
* [Cross-Chain update command][lip-0053]
* [State recovery command][lip-0054]
* [Message recovery command][lip-0054]
* [State recovery initialization command][lip-0054]
* [Message recovery initialization command][lip-0054]

### Protocol Logic for Other Modules

#### send

For the function description, parameters, and return value see the corresponding internal function `sendInternal`.

##### Execution

```python
send(feeAddress, moduleID, crossChainCommandID, receivingChainID, fee, status, params):
    sendInternal(
        feeAddress, 
        moduleID, 
        crossChainCommandID, 
        receivingChainID, 
        fee, 
        status, 
        params
    )
```

#### error

The `error` function is used to add an error code to a CCM and then add it to the outbox of a partner chain.

##### Parameters

This function has the following input parameters in the order given below:

* `ccm`: The cross-chain message.
* `errorStatus`: The error status to be set.

##### Returns

Nothing.

##### Execution

```python
error(ccm, errorStatus):
    # Error codes from 0 to MAX_RESERVED_ERROR_STATUS (included) are reserved to the Interoperability module
    if 0 <= errorStatus <= MAX_RESERVED_ERROR_STATUS:
        raise InvalidErrorStatusError 

    sendInternal(
        EMPTY_FEE_ADDRESS, 
        ccm.moduleID, 
        ccm.crossChainCommandID, 
        ccm.sendingChainID, 
        0, 
        errorStatus, 
        ccm.params
    )
```
#### terminateChain

For the function description, parameters, and return value see the corresponding internal function `terminateChainInternal`.

##### Execution

```python
terminateChain(chainID):
    if terminatedStateAccount(chainID) exists:
        raise ChainNotLiveError
    
    if chainID == ownChainAccount.ID:
        raise InvalidChainIDError

    # Processing on a sidechain
    if ownChainAccount.ID != MAINCHAIN_ID:
        # The mainchain cannot be terminated
        if chainID == MAINCHAIN_ID:
            raise InvalidChainIDError

    terminateChainInternal(chainID)
```

#### getChainAccount

The `getChainAccount` function returns the object stored in the chain data substore with store key equal to the input `chainID`.

##### Parameters

* `chainID`: The ID of the chain.

##### Returns

This function returns `chainAccount(chainID)`.

#### getChannel

The `getChannel` function returns the object stored in the channel data substore with store key equal to the input `chainID`.

##### Parameters

* `chainID`: The ID of the chain.

##### Returns

This function returns `channel(chainID)`.


#### getOwnChainAccount

The `getOwnChainAccount` function returns the object stored in the own chain data substore.

##### Parameters

This function takes no input.

##### Returns

This function returns `ownChainAccount`.

#### getTerminatedStateAccount

The `getTerminatedStateAccount` function returns the object stored in the terminated state substore with store key equal to the input `chainID`.

##### Parameters

* `chainID`: The ID of the chain.

##### Returns

This function returns `terminatedStateAccount(chainID)`.

#### getTerminatedOutboxAccount

The `getTerminatedOutboxAccount` function returns the object stored in the terminated outbox substore with store key equal to the input `chainID`.

##### Parameters

* `chainID`: The ID of the chain.

##### Returns

This function returns `terminatedOutboxAccount(chainID)`.

#### isDirectChannelActive

The `isDirectChannelActive` function checks that there is a direct channel between chains and that it is active.

##### Parameters

* `chainID`: The ID of the chain.

##### Returns

A boolean, indicating whether the direct channel exists and is active.

##### Execution

```python
isDirectChannelActive(chainID):
    if chainAccount(chainID) does not exist:
        return False
    if chainAccount(chainID).status != CHAIN_ACTIVE:
        return False
    return True
```

### Genesis Block Processing

#### Genesis State Initialization

During the genesis state initialization stage, the following steps are executed. If any step fails, the block is discarded and has no further effect.

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the Interoperability module and let `interoperabilityAsset` be the deserialization of `genesisBlockAssetBytes` according to the `genesisInteroperabilityStoreSchema` schema, given below. Each top level entry in the schema corresponds to the substore of the Interoperability module store with the same name.

* Within each substore, check that all entries have a different `storeKey`.
* For each entry in the chain data substore there must be a corresponding entry (with the same value of `storeKey`) in the outbox root, channel data, and chain validators substores and viceversa. However, if the chain account has status set to terminated, the entry in the outbox root must *not* be present.
* For each entry in the terminated outbox substore there must be a corresponding entry (with the same value of `storeKey`) in the terminated state substore.
* For each entry in the terminated state substore, if the property `initialized` is set to `false`, the corresponding entry in the terminated outbox substore must *not* be present. Furthermore, the `stateRoot` must be set to empty bytes and `mainchainStateRoot` to a 32-bytes value. Conversely, if the property `initialized` is set to `true`, the `stateRoot` must be set to a 32-bytes value and `mainchainStateRoot` to empty bytes.
* For each entry `chainValidators` in `interoperabilityAsset.chainValidatorsSubstore`, let `activeValidators = chainValidators.storeValue.activeValidators` and let `certificateThreshold = chainValidators.storeValue.certificateThreshold`:
  * `activeValidators` must have at least 1 element and at most `MAX_NUM_VALIDATORS` elements.
  * `activeValidators` must be ordered lexicographically by `blsKey` property.
  * All `blsKey` properties have length 48 and are pairwise distinct.  
  * The `bftWeight` property of each element is a positive integer.
  * Let `totalWeight` be the sum of the `bftWeight` property of every element in `activeValidators`. Then `totalWeight` has to be less than or equal to `MAX_UINT64`.
  * Check that `  x totalWeight + 1 <= certificateThreshold <= totalWeight`, where `` is the floor function.
* If a chain account for another sidechain is present, than a chain account for the mainchain (`chainID = 1`) must be present, as well as the own chain account.
* For each entry `channelData` in `interoperabilityAsset.channelDataSubstore`, let `channel = channelData.storeValue`:
  * Either `channel.messageFeeTokenID={chainID=1, localID=0}` (corresponding to the LSK token), or `channel.messageFeeTokenID.chainID` must be equal to `channelData.storeKey` or `ownChainAccount.ID` (the message fee token must be a native token of either chains).
* For every substore, create all the corresponding entries in the Interoperability module state.


```java
genesisInteroperabilityStoreSchema = {
  "type": "object",
  "required": [
    "outboxRootSubstore",
    "chainDataSubstore",
    "channelDataSubstore",
    "chainValidatorsSubstore",
    "ownChainDataSubstore",
    "terminatedStateSubstore",
    "terminatedOutboxSubstore",
    "registeredNamesSubstore",
    "registeredNetworkIDsSubstore"
  ],
  "properties": {
    "outboxRootSubstore": {
      "type": "array",
      "fieldNumber": 1,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...outboxRootSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "chainDataSubstore": {
      "type": "array",
      "fieldNumber": 2,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...chainAccountSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "channelDataSubstore": {
      "type": "array",
      "fieldNumber": 3,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...channelSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "chainValidatorsSubstore": {
      "type": "array",
      "fieldNumber": 4,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...validatorsSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "ownChainDataSubstore": {
      "type": "array",
      "fieldNumber": 5,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...ownChainAccountSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "terminatedStateSubstore": {
      "type": "array",
      "fieldNumber": 6,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...terminatedStateSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "terminatedOutboxSubstore": {
      "type": "array",
      "fieldNumber": 7,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...terminatedOutboxSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "registeredNamesSubstore": {
      "type": "array",
      "fieldNumber": 8,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...chainIDSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "registeredNetworkIDsSubstore": {
      "type": "array",
      "fieldNumber": 9,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...chainIDSchema,
            "fieldNumber": 2,
          }
        }
      }
    }
  }
}
```

Here, the `...` notation, borrowed from [JavaScript ES6 data destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring), indicates that the corresponding schema should be inserted in place, and it is just used for notational convenience.


#### Genesis State Finalization

The Interoperability module does not execute any logic during the genesis state finalization.

## Backwards Compatibility

This proposal, together with [LIP 0043][lip-0043], [LIP 0049][lip-0049], [LIP 0053][lip-0053], and [LIP 0054][lip-0054], is part of the Interoperability module. Chains adding this module will need to do so with a hard fork.

[lip-0049]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md
[lip-0053]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0053.md
[lip-0043]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0043.md
[lip-0054]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0054.md
