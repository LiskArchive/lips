```
LIP: 0045
Title: Introduce Interoperability module
Author: Alessandro Ricottone <alessandro.ricottone@lightcurve.io>
        Mitsuaki Uchimoto <mitsuaki.uchimoto@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-interoperability-module/290
Status: Draft
Type: Standards Track
Created: 2021-05-21
Updated: 2022-03-22
```

## Abstract

The Interoperability module provides basic functionalities to transmit information between interoperable chains in the Lisk ecosystem using cross-chain messages. In this LIP the properties, serialization, and initial values of this module are specified. Additionally, this LIP also provides a broad overview of the Lisk interoperability solution, motivating several design choices and presenting the new commands that are part of the Interoperability module.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

Interoperability has the potential to solve the scaling issue of blockchains: Instead of deploying applications and their corresponding commands onto a single blockchain, these are implemented into separate blockchains which then communicate with each other using an interoperability protocol.

To achieve interoperability, chains in the Lisk ecosystem (the mainchain and the sidechains participating in interoperability) exchange information via _cross-chain transactions_. As an example, a user can issue a cross-chain transaction to transfer part of their mainchain LSK balance to a sidechain, and subsequently use it to issue one of the sidechain commands.

In the Lisk protocol, cross-chain transactions are special in that, after being included in their origin ledger, some new data structures, the _cross-chain messages_ (CCMs), are created, which are transmitted to other chains via special commands called _cross-chain update_ (CCU) commands. CCUs also contain information about the chain, in the form of a _certificate_. 
In the receiving chain, CCMs trigger the execution of _cross-chain commands_, in a way similar to how transaction trigger the execution of regular commands.

One of the main motivations for proposing a [certificate-based communication](https://lisk.com/blog/research/introduction-blockchain-interoperability) between chains is the ability for all chains in the ecosystem to remain state machines. This means that all information needed to validate and advance a chain to the next block is present on the chain itself.  In the Lisk interoperability solution, the only information that needs social consensus is information about the initial validators of the other chain. On the mainchain, this information is received via the sidechain registration command; on sidechains, in a similar way, via the mainchain registration command.

The Interoperability module provides the data structures and functionalities necessary for interoperability between chains of the Lisk ecosystem. In this LIP, we specify the properties, serialization, and initial values of the Interoperability module.

## Rationale

### Interoperability Commands

The Interoperability module stores the properties necessary to validate and process the following new commands.

#### [Sidechain Registration Command][lip-0043]

The sidechain registration command is used to register a sidechain on the Lisk mainchain. When this command is processed, a new account for the sidechain is created in the mainchain state under the interoperability store. The account is initialized with an empty inbox and outbox, while the sidechain name and the initial validators set are given in the command parameters. The chain ID, used as store key, is also given in the command parameters.

#### [Mainchain Registration Command][lip-0043]

The mainchain registration command is used to register the Lisk mainchain on a sidechain. When this command is processed, a new account for the mainchain is created in the sidechain state under the interoperability store. The account is initialized with an empty inbox and outbox, while the initial validators set is given in the command parameters. The name and chain ID of the mainchain are global protocol constants in the whole ecosystem.

This command also initializes another data structure in the interoperability store, containing some information about the sidechain itself. In particular, it sets the sidechain name and chain ID to the ones that have been previously registered on the mainchain via the sidechain registration command.

#### [Cross-Chain Update Commands][lip-0053]

<img src="lip-0045/ccu.png" width="80%">

_Figure 1: A sketch of an interoperability interaction between the Lisk mainchain and a sidechain. Information (cross-chain messages and updated state) from mainchain blocks (light blue) is collected into a cross-chain update command by the relayer, which then posts it on the sidechain._

CCUs are used to post the updated state of the sending chain on the receiving chain. Furthermore, they transmit the cross-chain messages that need to be sent to the receiving chain (see Figure 1). We introduce two different CCUs, one for posting on the Lisk mainchain, and the other for posting on sidechains. They differ in the way the included messages are handled: on the mainchain, messages targeting another sidechain are forwarded to that sidechain outbox, while messages targeting the mainchain are simply processed. On the other hand, a CCU posted on a sidechain can only contain CCMs targeting that sidechain, being invalid otherwise.


#### [State Recovery Command][lip-0054]

This command is used to recover a certain state (for example fungible and non-fungible tokens) from a sidechain that has been terminated. The user proves the existence of an entry in the terminated state substore with an inclusion proof. The proof is validated against the current state root stored in the terminated chain account. The recovery of the state is then handled by the relevant module (for example the token module would refund the user).

#### [Message Recovery Command][lip-0054]

This command is used to recover a pending message from the outbox of a terminated chain. The user proves with an inclusion proof that the message is in the terminated sidechain outbox. The proof is validated against the outbox root stored in the terminated outbox account. The recovered message is then bounced back to the original sending chain or processed directly (if the sending chain is the mainchain).

#### [State Recovery Initialization Command][lip-0054]

This command is used to initialize a terminated state account on a sidechain. The user proves with an inclusion proof that the target chain state on the mainchain implies that that chain is terminated (either the status is set to 'terminated' or the liveness condition is violated). Once the terminated state account has been initialized, the state recovery command can be issued in the sidechain.

#### [Message Recovery Initialization Command][lip-0054]

This command is used to initialize a terminated outbox account and can only be issued after the corresponding terminated state account has been created. This command contains the chain account of the current chain as stored in the state of the terminated chain and an inclusion proof for it against the state root stored in the corresponding terminated state account. Once the terminated outbox account has been initialized, the message recovery command can be issued.

### Liveness Condition

Active sidechains are required to prove their liveness to the mainchain at least once every 30 days. 
This is done by including a CCU on the mainchain. 
If a sidechain does not post a CCU within 30 days, the sidechain account is terminated. 
This rule guarantees that users do not send funds to inactive sidechains and that users who have tokens in a sidechain which stops communicating with the ecosystem can recover their tokens.

There are extra requirements for the first CCU posted on the mainchain: It must contain a non-empty `certificate` which follows the schema defined in [LIP 0061][lip-0061#certificate-schema]; furthermore, if this first CCU also contains a non-empty `inboxUpdate`, the certificate is only valid if it allows the sidechain account to remain live for a reasonable amount of time.

### Life Cycle of a Sidechain

The life cycle of a sidechain can be split into 3 parts, corresponding to the 3 values of the account status property: ''registered'', ''active'', and ''terminated''.

A sidechain registers on the mainchain with a [sidechain registration command][lip-0043]. This command creates the sidechain account on the mainchain. In particular, it creates an entry in the chain data substore, with initial status set to 'registered'; an entry in the channel data substore, with empty inbox and outbox; and an entry in the validators data substore, holding the initial sidechain validators set. Thereafter, the mainchain account is similarly created on a sidechain with a [mainchain registration command][lip-0043].

After a sidechain has been registered on the mainchain, it cannot receive any cross-chain message and does not need to follow the liveness rule, until the first sidechain CCU has been included in the mainchain. At this point, the status of the sidechain account on the mainchain is updated to ''active'' and the liveness requirement is enforced.

If no CCU is received within 30 days, the [chain account is terminated](#terminateChain) and no more CCMs can be sent to or received from the sidechain. A sidechain account can also be terminated if the sidechain posts a CCU containing a CCM with an invalid schema or with an invalid sending chain ID. A message targeting a terminated chain is bounced on the mainchain instead of being forwarded. When this happens, a ''terminated sidechain'' message is emitted by the mainchain, targeting the original sending chain. When this message is processed, the chain is also terminated in the sending chain, blocking future messages.

When a chain is terminated, a 'terminated state' account is created, storing the last certified state root of the terminated chain. Then, users can recover tokens from the terminated sidechain with a state recovery command or proceed with the message recovery initialization command to kick-off the recovery of pending cross-chain messages.

### Properties of the Interoperability Module

Each interoperable sidechain maintains a chain account, channel, and the chain validators for the mainchain, while the mainchain maintains these data structures for each registered sidechain. Correspondingly, on a sidechain we denote with ''partner chain'' the mainchain, while on the mainchain we denote with ''partner chain'' the relevant sidechain.

Each chain also includes an account storing the chain name and ID in the ecosystem as well as the current chain nonce. This ''own chain'' account is present by default in the mainchain, while on a sidechain is created by the mainchain registration command.

<img src="lip-0045/interoperability_store.png" width="80%">

_Figure 2: A summary of the Interoperability module store: Each box represents a substore, where we indicate the `storeKey --> storeValue` relation. The Interoperability module defines 7 substores on a sidechain: the outbox substore for outbox roots, the chain data substore for partner chain accounts and the own chain data substore for the own chain account, the channel data substore keeping track of the inbox and outbox, the validators data substore storing the partner-chain validators set, and the terminated state and terminated outbox substores to allow for recovery commands. The name substore, keeping track of the names of registered sidechains, is present only on the mainchain._

### Message Forwarding and the Role of the Lisk Mainchain

In the Lisk ecosystem, the Lisk mainchain plays a central role, distinct from any other chain. It acts as an intermediary chain, [relaying cross-chain messages between sidechains][lip-0053]. This has a few notable advantages:

1. Relayers only need to follow the chosen sidechain and the mainchain. All CCMs sent to a given chain will go through the sidechain outbox on the mainchain.
2. The mainchain guarantees that messages are available and can be delivered to active sidechains. In the case in which the receiving sidechain is not active, the messages are returned to their sending chain. This allows the sidechain protocol to remain simple and agnostic to the state of other sidechains. In particular, transaction handling does not require knowledge of all potential receiving chains.

### Inbox and Outbox

As explained above, inbox and outbox are organized as regular Merkle trees. Since the root of the tree depends on the order of insertion, all cross-chain messages have to be inserted in the receiving chain in the same order in which they were included in the sending chain, guaranteeing that they are processed in the correct order.

Using a Merkle tree also guarantees that the number of sibling hashes that are part of inclusion proofs grows only logarithmically with the number of elements in the tree. In particular, this means that the number of sibling hashes required to validate the cross-chain messages in a CCU against the partner chain `lastCertificate.stateRoot` grows logarithmically with the number of processed messages.

#### Storage of the Outbox Root

The outbox root property is duplicated and additionally stored separately from all other properties of the chain account. The substore prefix of the outbox root is the constant `SUBSTORE_PREFIX_OUTBOX_ROOT` and the store key is the hash of the chain ID of the partner chain. Storing the outbox root with a different substore prefix allows to separate the subtree corresponding to the outbox roots from the rest of the data in the interoperability store. This choice allows for shorter inclusion proofs for the outbox root, as the other properties of the Interoperability module are not needed to recalculate the state root if the outbox root is known. In particular, the inclusion proof contained in a CCU from a sidechain posted on the mainchain will contain only one hash.

### Storage of Auxiliary Data

In order to process sidechain registration commands more efficiently, it is convenient to store on the mainchain the names already registered in the ecosystem to quickly check the uniqueness of the sidechain name.  

## Specification

In this section, we specify the substores that are part of the Interoperability module store and the functions exposed to other modules. The Interoperability module has module name `MODULE_NAME_INTEROPERABILITY` (see the [table below](#Notation-and-Constants)).

### Notation and Constants

| Name                                          | Type   | Value                | Description                                                      |
|-----------------------------------------------|--------|----------------------|------------------------------------------------------------------|
| **Interoperability Constants**                |        |                      |                                                                  |
| `MODULE_NAME_INTEROPERABILITY`                | string | "interoperability"   | Name of the Interoperability module.                             |
| `CHAIN_ID_MAINCHAIN`                          | bytes  | 0x00000000           | Chain ID of the Lisk mainchain in the mainnet.                   |
| `CHAIN_NAME_MAINCHAIN`                        | string | "lisk-mainchain"     | Name of the Lisk mainchain.                                      |
| **Interoperability Store**                    |        |                      |                                                                  |
| `SUBSTORE_PREFIX_OUTBOX_ROOT`                 | bytes  | 0x0000               | Substore prefix of the outbox root substore.                     |
| `SUBSTORE_PREFIX_CHAIN_DATA`                  | bytes  | 0x8000               | Substore prefix of the chain data substore.                      |
| `SUBSTORE_PREFIX_OWN_CHAIN_DATA`              | bytes  | 0xb000               | Substore prefix of the own chain data substore.                  |
| `SUBSTORE_PREFIX_CHANNEL_DATA`                | bytes  | 0xa000               | Substore prefix of the channel data substore.                    |
| `SUBSTORE_PREFIX_CHAIN_VALIDATORS`            | bytes  | 0x9000               | Substore prefix of the chain validators substore.                |
| `SUBSTORE_PREFIX_TERMINATED_STATE`            | bytes  | 0xc000               | Substore prefix of the terminated state substore.                |
| `SUBSTORE_PREFIX_TERMINATED_OUTBOX`           | bytes  | 0xd000               | Substore prefix of the terminated outbox substore.               |
| `SUBSTORE_PREFIX_REGISTERED_NAMES`            | bytes  | 0xe000               | Substore prefix of the chain names substore.                     |
| **Interoperability Commands**                 |        |                      |                                                                  |
| `COMMAND_SIDECHAIN_REG`                       | string | 0x0000               | Command ID of sidechain registration command.                    |
| `COMMAND_MAINCHAIN_REG`                       | string | 0x0001               | Command ID of mainchain registration command.                    |
| `COMMAND_SIDECHAIN_CCU`                       | string | 0x0002               | Command ID of sidechain cross-chain update command.              |
| `COMMAND_MAINCHAIN_CCU`                       | string | 0x0003               | Command ID of mainchain cross-chain update command.              |
| `COMMAND_STATE_RECOVERY`                      | string | 0x0004               | Command ID of state recovery initialization command.             |
| `COMMAND_MESSAGE_RECOVERY`                    | string | 0x0005               | Command ID of message recovery command.                          |
| `COMMAND_STATE_RECOVERY_INITIALIZATION`       | string | 0x0006               | Command ID of message recovery initialization command.           |
| `COMMAND_MESSAGE_RECOVERY_INITIALIZATION`     | string | 0x0007               | Command ID of initiate recovery command.                         |
| **Interoperability Cross-chain Commands**     |        |                      |                                                                  |
| `CROSS_CHAIN_COMMAND_REGISTRATION`            | string | 0x0000               | Cross-chain command ID of chain registration CCM.                |
| `CROSS_CHAIN_COMMAND_CHANNEL_TERMINATED`      | string | 0x0001               | Cross-chain command ID of channel terminated CCM.                |
| `CROSS_CHAIN_COMMAND_SIDECHAIN_STATUS_TERMINATED` | string | 0x0002           | Cross-chain command ID of sidechain terminated CCM.              |
| **Chain Status**                              |        |                      |                                                                  |
| `CHAIN_STATUS_REGISTERED`                     | uint32 | 0                    | Chain registered status.                                         |
| `CHAIN_STATUS_ACTIVE`                         | uint32 | 1                    | Chain active status.                                             |
| `CHAIN_STATUS_TERMINATED`                     | uint32 | 2                    | Chain terminated status.                                         |
| **Message Status and Errors**                 |        |                      |                                                                  |
| `CCM_STATUS_OK`                               | uint32 | 0                    | Regular message status.                                          |
| `CCM_STATUS_MODULE_NOT_SUPPORTED`             | uint32 | 1                    | Status assigned to CCMs when module is not supported.            |
| `CCM_STATUS_CROSS_CHAIN_COMMAND_NOT_SUPPORTED`| uint32 | 2                    | Status assigned to CCMs when command is not supported.           |
| `CCM_STATUS_CHANNEL_UNAVAILABLE`              | uint32 | 3                    | Status assigned to CCMs when channel is unavailable.             |
| `CCM_STATUS_RECOVERED`                        | uint32 | 4                    | Status assigned to CCMs after recovery.                          |
| **Events**                                    |        |                      |                                                                  |
| `EVENT_NAME_INVALID_REGISTRATION_SIGNATURE`   | string | "invalidRegistrationSignature" | Name of the invalid registration signature event.      |
| `EVENT_NAME_CHAIN_ACCOUNT_UPDATED`            | string | "chainAccountUpdated | Name of the chain account updated event.                         |
| `EVENT_NAME_CCM_SENT`                         | string | "ccmSent"            | Name of the cross-chain message processed event.                 |
| `EVENT_NAME_CCM_PROCESSED`                    | string | "ccmProcessed"       | Name of the cross-chain message processed event.                 |
| **CCM Sent Event Status**                     |        |                      |                                                                  |
| `CCM_SENT_STATUS_SUCCESS`                     | uint32 | 0                    | Status code for CCM sent event: success.                         |
| `CCM_SENT_STATUS_CHANNEL_UNAVAILABLE`         | uint32 | 1                    | Status code for CCM sent event: channel unavailable.             |
| `CCM_SENT_STATUS_INVALID_FORMAT`              | uint32 | 2                    | Status code for CCM sent event: invalid format.                  |
| `CCM_SENT_STATUS_MESSAGE_FEE_ERROR`           | uint32 | 3                    | Status code for CCM sent event: message fee error.               |
| **CCM Processed Event Status**                |        |                      |                                                                  |
| `CCM_PROCESSED_STATUS_CHANNEL_UNAVAILABLE`    | uint32 | 0                    | Status code for CCM processed event: channel unavailable.        |
| `CCM_PROCESSED_STATUS_MODULE_NOT_SUPPORTED`   | uint32 | 1                    | Status code for CCM processed event: module not supported.       |
| `CCM_PROCESSED_STATUS_COMMAND_NOT_SUPPORTED`  | uint32 | 2                    | Status code for CCM processed event: command not supported.      |
| `CCM_PROCESSED_STATUS_FORWARDED`              | uint32 | 3                    | Status code for CCM processed event: forwarded.                  |
| `CCM_PROCESSED_STATUS_APPLIED`                | uint32 | 4                    | Status code for CCM processed event: applied.                    |
| `CCM_PROCESSED_STATUS_FAILED`                 | uint32 | 5                    | Status code for CCM processed event: failed.                     |
| `CCM_PROCESSED_STATUS_INVALID`                | uint32 | 6                    | Status code for CCM processed event: invalid.                    |
| `CCM_PROCESSED_STATUS_DISCARDED`              | uint32 | 7                    | Status code for CCM processed event: discarded.                  |
| `CCM_PROCESSED_STATUS_RECOVERY_FORWARDED`     | uint32 | 8                    | Status code for CCM processed event: recovered message forwarded.|
| `CCM_PROCESSED_STATUS_RECOVERY_APPLIED`       | uint32 | 9                    | Status code for CCM processed event: recovered message applied.  |
| `CCM_PROCESSED_STATUS_RECOVERY_FAILED`        | uint32 | 10                    | Status code for CCM processed event: recovered message failed.   |
| `CCM_PROCESSED_STATUS_RECOVERY_DISCARDED`     | uint32 | 11                   | Status code for CCM processed event: recovered message discarded.|
| **Message Tags**                              |        |                      |                                                                  |
| `MESSAGE_TAG_CHAIN_REG`                       | bytes  | `“LSK_CHAIN_REGISTRATION_”` ASCII-encoded | Message tag for chain registration message. |
| `MESSAGE_TAG_CERTIFICATE `                    | bytes  | `"LSK_CE_"` ASCII-encoded | Message tag for certificates.                               |
| **General Constants**                         |        |                      |                                                                  |
| `REGISTRATION_FEE`                            | uint64 | 1000000000           | Fee to pay for a sidechain registration command.                 |
| `EMPTY_HASH`                                  | bytes  | SHA-256("")          | Hash of empty bytes.                                             |
| `LIVENESS_LIMIT`                              | uint32 | 30x24x3600           | The maximum time interval for the liveness condition.            |
| `MAX_NUM_VALIDATORS`                          | uint32 | 199                  | The maximum number of validators that can be registered. Defined in the DPoS module.        |
| `MAX_UINT32`                                  | uint32 | 4294967295           | Maximum value for a 32-bit unsigned integer.                     |
| `MAX_UINT64`                                  | uint64 | 18446744073709551615 | The maximum value that can be encoded in a uint64.               |
| `MAX_RESERVED_ERROR_STATUS`                   | uint64 | 63                   | The largest error code reserved for the Interoperability module. |
| `EMPTY_BYTES`                                 | bytes  | ""                   | The empty byte string.                                           |
| `EMPTY_FEE_ADDRESS`                           | bytes  | ""                   | The empty byte string.                                           |
| `THRESHOLD_MAINCHAIN`                         | uint32 | `68`                 | The certificate threshold used for Lisk mainchain. Defined in the DPoS module.               |
| `TOKEN_ID_LSK_MAINCHAIN`                      | bytes  | 0x0000000000000000   | The token ID of the Lisk token. Defined in the Token module.                                 |
| `MAINCHAIN_NUMBER_ACTIVE_DELEGATES`        	| uint32 | 101                  | The number of active delegates on the Lisk mainchain. Defined in the DPoS module.           |
| `MIN_RETURN_FEE`                              | uint64 | 1000                 | The minimum return fee for a cross-chain message in Beddows.     |
| `MAX_CCM_SIZE`                                | uint64 | 10240  | The maximum size of a cross-chain message in bytes.                            |
| **Length Constants**                          |        |                      |                                                                  |
| `ADDRESS_LENGTH`                              | uint32 | 20                   | Length in bytes of type `Address`.                               |
| `ED25519_PUBLIC_KEY_LENGTH`                   | uint32 | 32                   | Length in bytes of type `PublicKeyEd25519`.                      |
| `BLS_PUBLIC_KEY_LENGTH`                       | uint32 | 48                   | Length in bytes of type `PublicKeyBLS`.                          |
| `BLS_SIGNATURE_LENGTH`                        | uint32 | 96                   | Length in bytes of type `SignatureBLS`.                          |
| `CHAIN_ID_LENGTH`                             | uint32 | 4                    | Length in bytes of type `ChainID`.                               |
| `TOKEN_ID_LENGTH`                             | uint32 | 8                    | Length in bytes of a token ID.                                   |
| `HASH_LENGTH`                                 | uint32 | 32                   | Length in bytes of outputs of SHA-256 hash function.             |
| `MIN_MODULE_NAME_LENGTH`                      | uint32 | 1                    | The minimum length of a string specifying the name of a module.  |
| `MAX_MODULE_NAME_LENGTH`                      | uint32 | 32                   | The maximum length of a string specifying the name of a module.  |
| `MIN_CROSS_CHAIN_COMMAND_NAME_LENGTH`         | uint32 | 1                    | The minimum length of a string specifying the name of a command. |
| `MAX_CROSS_CHAIN_COMMAND_NAME_LENGTH`         | uint32 | 32                   | The maximum length of a string specifying the name of a command. |
| `MIN_CHAIN_NAME_LENGTH`                       | uint32 | 1                    | The minimum length of a string specifying the name of a chain.   |
| `MAX_CHAIN_NAME_LENGTH`                       | uint32 | 32                   | The maximum length of a string specifying the name of a chain.   |


### Type Definition

| Name               | Type    | Validation            | Description                     |
|--------------------|---------|-----------------------|---------------------------------|
| `Address`          | bytes   | Must be of length `ADDRESS_LENGTH`. | Address of an account.   |
| `ModuleID`         | bytes   | Must be of length `MODULE_ID_LENGTH`. | ID of a module.   |
| `CrossChainCommandID` | bytes   | Must be of length `CROSS_CHAIN_COMMAND_LENGTH`. | ID of a cross-chain command.   |
| `ChainID`          | bytes   | Must be of length `CHAIN_ID_LENGTH`. | ID of a chain.   |
| `CCU`              | object   | The parameters must follow the `crossChainUpdateTransactionParams` schema. | The type of cross-chain update transactions.   |
| `CCM`              | object   | Must follow the `crossChainMessageSchema` schema. | The type of cross-chain messages.   |
| `MerkleRoot`       | bytes   | Must be of length `MERKLE_ROOT_LENGTH`. | The root of a Merkle tree.   |
| `PublicKeyEd25519` | bytes | Must be of length `ED25519_PUBLIC_KEY_LENGTH`. | Used for Ed25519 public keys. |
| `PublicKeyBLS`     | bytes | Must be of length `BLS_PUBLIC_KEY_LENGTH`. | Used for BLS keys. |
| `ActiveValidator`  | object | Must have `blsKey: PublicKeyBLS` and `bftWeight: uint64` properties. | The BLS key and BFT weight of an active validator. |
| `ChainAccount`     | object | | An entry in the chain data substore, must follow the `chainAccountSchema` schema. |
| `Channel`          | object | | An entry in the channel substore, must follow the `channelSchema` schema. |
| `OwnChainAccount`  | object | | An entry in the own chain data substore, must follow the `ownChainAccountSchema` schema. |
| `TerminatedStateAccount` | object | | An entry in the terminated state substore, must follow the `terminatedStateAccountSchema` schema. |
| `TerminatedOutboxAccount` | object | | An entry in the terminated outbox substore, must follow the `terminatedOutboxAccountSchema` schema. |


### Interoperability Module Store

The key-value pairs in the module store are organized in the following substores.

#### Outbox Root Substore

The outbox root substore holds the root of the outbox of each partner chain.

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_OUTBOX_ROOT`.
* Each store key is set to the ID of the partner chain `chainID`.
* Each store value is the serialization of an object following the JSON schema `outboxRootSchema` presented below.
* Notation: For the rest of this proposal let `outboxRoot(chainID)` be the outbox root identified by the store key `chainID`.

##### JSON Schema

```java
outboxRootSchema = {
    "type": "object",
    "required": ["root"],
    "properties": {
        "root": {
            "dataType": "bytes",
            "length": HASH_LENGTH,
            "fieldNumber": 1
        }
    }
}
```

##### Properties and Default values

* `root`: The root of the underlying Merkle tree of the partner chain outbox. This value is initialized to `EMPTY_HASH`.

#### Chain Data Substore

The chain data substore holds information about other partner chains.

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_CHAIN_DATA`.
* Each store key is set to the ID of the partner chain `chainID`.
* Each store value is the serialization of an object following the JSON schema `chainAccountSchema` presented below.
* Notation: For the rest of this proposal let `chainAccount(chainID)` be the chain account identified by the store key `chainID`.

##### JSON Schema

```java
chainAccountSchema = {
    "type": "object",
    "required": ["name", "lastCertificate", "status"],
    "properties": {
        "name": {
            "dataType": "string",
            "fieldNumber": 1
        },
        "lastCertificate": {
            "type": "object",
            "fieldNumber": 2,
            "required": ["height", "timestamp", "stateRoot", "validatorsHash"],
            "properties": {
                "height": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "timestamp": {
                    "dataType": "uint32",
                    "fieldNumber": 2
                },
                "stateRoot": {
                    "dataType": "bytes",
                    "length": HASH_LENGTH,
                    "fieldNumber": 3
                },
                "validatorsHash": {
                    "dataType": "bytes",
                    "length": HASH_LENGTH,
                    "fieldNumber": 4
                }
            }
        },
        "status": {
            "dataType": "uint32",
            "fieldNumber": 3
        }
    }
}
```

##### Properties and Default values

In this section, we describe the properties of a chain account and specify their default values.

* `name`: This property corresponds to the name of the sidechain as a string of characters. It has to be unique in the ecosystem. For the mainchain account on a sidechain, this property is initialized to the string `CHAIN_NAME_MAINCHAIN`. For a sidechain account on the mainchain, this property is set by the sidechain registration command.
* `lastCertificate`: This property holds some information from the certificate posted contained in the last CCU from the partner chain. It is an object containing the following properties:
  * `height`: The height contained in the last certificate from the partner chain. It is used to [validate a certificate][lip-0053] (certificates must contain block headers with increasing heights). The default value of this property is 0.
  * `timestamp`: The timestamp contained in the last certificate from the partner chain. On the mainchain, it is used to check that the sidechain chain fulfills the liveness requirement (see [above](#Liveness-Condition)). The default value of this property is 0.
  * `stateRoot`: The state root contained in the last certificate from the partner chain. It is used to validate the inclusion proof of the cross-chain messages contained in a CCU and to verify the validity of the token recovery command. The default value of this property is the constant `EMPTY_HASH`.
  * `validatorsHash`: The value of this property is set to the validators hash contained in the last certificate from the partner chain. This value always corresponds to the hash calculated from the validators data substore entry for the partner chain. The default value of this property is the constant `EMPTY_HASH`.
* `status`: This property stores the current status of the partner chain account. As explained [above](#Life-Cycle-of-a-Sidechain), there are 3 possible statuses: ''active'', ''registered'', and ''terminated''. The default value of this property is `CHAIN_STATUS_REGISTERED`, corresponding to the "registered" status.

#### Channel Data Substore

The channel data substore holds information about the inbox and outbox with other partner chains.

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_CHANNEL_DATA`.
* Each store key is set to the ID of the partner chain `chainID`.
* Each store value is the serialization of an object following the JSON schema `channelSchema` presented below.
* Notation: For the rest of this proposal let `channel(chainID)` be the channel identified by the store key `chainID`.

##### JSON Schema

```java
channelSchema = {
    "type": "object",
    "required": ["inbox", "outbox", "partnerChainOutboxRoot", "messageFeeTokenID"],
    "properties": {
        "inbox": {
            "type": "object",
            "fieldNumber": 1,
            "required": ["appendPath", "size", "root"],
            "properties": {
                "appendPath": {
                    "type": "array",
                    "items": {
                        "dataType": "bytes",
                        "length": HASH_LENGTH
                    },
                    "fieldNumber": 1
                },
                "size": {
                    "dataType": "uint64",
                    "fieldNumber": 2
                },
                "root": {
                    "dataType": "bytes",
                    "length": HASH_LENGTH,
                    "fieldNumber": 3
                }
            }
        },
        "outbox": {
            "type": "object",
            "fieldNumber": 2,
            "required": ["appendPath", "size", "root"],
            "properties": {
                "appendPath": {
                    "type": "array",
                    "items": {
                        "dataType": "bytes",
                        "length": HASH_LENGTH
                    },
                    "fieldNumber": 1
                },
                "size": {
                    "dataType": "uint64",
                    "fieldNumber": 2
                },
                "root": {
                    "dataType": "bytes",
                    "length": HASH_LENGTH,
                    "fieldNumber": 3
                }
            }
        },
        "partnerChainOutboxRoot": {
            "dataType": "bytes",
            "length": HASH_LENGTH,
            "fieldNumber": 3
        },
        "messageFeeTokenID": {
            "dataType": "bytes",
            "length": TOKEN_ID_LENGTH,
            "fieldNumber": 4
        }
    }
}
```

##### Properties and Default values

In this section, we describe the properties of a channel and specify their default values.

* `inbox`: The data structure containing information about the cross-chain messages received from the partner chain, organized in a regular Merkle tree (specified for the Lisk protocol in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md#regular-merkle-trees)). The underlying Merkle tree of the inbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md). It contains the following properties:
  * `root`:  The root of the Merkle tree. The default value of this property is `EMPTY_HASH`.
  * `appendPath`: An array of hashes necessary to append new data to the tree efficiently. The default value of this property is an empty array.
  * `size`: The current size of the tree, i.e. the number of cross-chain messages received from the partner chain and processed. The default value of this property is 0.
* `outbox`: The data structure containing information about the cross-chain messages sent to the partner chain, organized in a regular Merkle tree. The underlying Merkle tree of the outbox is initialized as an empty tree, as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md). It contains the following properties:
  * `root`:  The root of the Merkle tree. The default value of this property is `EMPTY_HASH`.
  * `appendPath`: An array of hashes necessary to append new data to the tree efficiently. The default value of this property is an empty array.
  * `size`: The current size of the tree, i.e. the number of cross-chain messages sent to the partner chain. The default value of this property is 0.
* `partnerChainOutboxRoot`: The value of this property is set to the outbox root computed from the last CCU from the partner chain. It is used to validate the cross-chain messages contained in a future CCU when the CCU does not certify a new outbox root. The default value of this property is the constant `EMPTY_HASH`.
* `messageFeeTokenID`: This property is the token ID of the token used to pay for the cross-chain message fees. The default value is `messageFeeTokenID = TOKEN_ID_LSK`, corresponding to the LSK token.

#### Chain Validators Substore

The chain validators substore holds information about the validators of other partner chains.

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_CHAIN_VALIDATORS`.
* Each store key is set to the ID of the partner chain `chainID`.
* Each store value is the serialization of an object following the JSON schema `validatorsSchema` presented below.
* Notation: For the rest of this proposal let `validators(chainID)` be the set of active validators for the chain identified by the store key `chainID`.

##### JSON Schema

```java
validatorsSchema = {
    "type": "object",
    "required": ["activeValidators", "certificateThreshold"],
    "properties": {
        "activeValidators": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["blsKey", "bftWeight"],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "length": BLS_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "certificateThreshold": {
            "dataType": "uint64",
            "fieldNumber": 2
        }
    }
}
```

##### Properties and Default values

In this section, we describe the properties of the chain validators and specify their default values.

* `activeValidators`: An array of objects corresponding to the set of validators eligible to sign the certificates from the partner chain. Each entry contains the following properties:
  * `blsKey`: The BLS public key used to sign certificates.
  * `bftWeight`: An integer indicating the weight of the corresponding BLS public key for signing a certificate. For DPoS chains, this value is usually 1, as every active validator has the same consensus weight for the signing of the next certificate.
* `certificateThreshold`: An integer setting the required cumulative weight needed for the certificate signature to be valid.
For the mainchain account on a sidechain, the `activeValidators` and `certificateThreshold` properties are initialized by the mainchain registration command. For a sidechain account on the mainchain, they are set by the sidechain registration command.

#### Own Chain Data

The own chain data substore stores the name and ID of the chain.

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_OWN_CHAIN_DATA`.
* The store key is set to `EMPTY_BYTES`.
* The store value is the serialization of an object following the JSON schema `ownChainAccountSchema` presented below.
* Notation: For the rest of this proposal let `ownChainAccount` be the own chain account.

##### JSON Schema

```java
ownChainAccountSchema = {
    "type": "object",
    "required": ["name", "chainID", "nonce"],
    "properties": {
        "name": {
            "dataType": "string",
            "fieldNumber": 1
        },
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 2
        },
        "nonce": {
            "dataType": "uint64",
            "fieldNumber": 3
        }
    }
}
```

##### Properties and Default values

* `name`: The name of the sidechain registered on the mainchain with the sidechain registration command.
* `chainID`: The chain ID assigned to the sidechain on the mainchain after processing the sidechain registration command.
* `nonce`: The chain nonce, an incremental integer indicating the total number of CCMs sent from the chain.

On the manchain, the own chain account is present by default, set to an object with properties:

* `name=CHAIN_NAME_MAINCHAIN`,
* `ID=CHAIN_ID_MAINCHAIN`,
* `nonce=0`,

serialized with the JSON schema `ownChainAccountSchema`.

On a sidechain, the own chain account is initialized as part of the mainchain registration command processing.

#### Terminated State Substore

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_TERMINATED_STATE`.
* The store key is set to the ID of the terminated chain `chainID`.
* The store value is the serialization of an object following the JSON schema `terminatedStateAccountSchema` presented below.
* Notation: For the rest of this proposal let `terminatedStateAccount(chainID)` be the terminated state account corresponding to the store key `chainID`.

##### JSON Schema

```java
terminatedStateAccountSchema = {
    "type": "object",
    "required": ["stateRoot", "mainchainStateRoot", "initialized"],
    "properties": {
        "stateRoot": {
            "dataType": "bytes",
            "length": HASH_LENGTH,
            "fieldNumber": 1
        },
        "mainchainStateRoot": {
            "dataType": "bytes",
            "length": HASH_LENGTH,
            "fieldNumber": 2
        },
        "initialized": {
            "dataType": "boolean",
            "fieldNumber": 3
        }
    }
}
```
##### Properties and Default values

* `stateRoot`: The state root of the terminated chain, initialized to `chainAccount(chainID).lastCertificate.stateRoot`, where `chainID` is the chain ID of the terminated chain. If the account is not initialized, it is set to `EMPTY_BYTES` instead.
* `mainchainStateRoot`: The state root of the mainchain at the moment in which the chain was terminated, set to `chainAccount(CHAIN_ID_MAINCHAIN).lastCertificate.stateRoot` for non-initialized terminated state accounts. If the account is initialized, it is set to `EMPTY_BYTES` instead.
* `initialized`: A boolean value, indicating whether the terminated state account has been initialized, i.e. if the `stateRoot` property has been set.

A terminated state account is created as part of the `terminateChain` function, as part of the processing of a sidechain terminated CCM or as part of the processing of a state recovery initialization command.

#### Terminated Outbox Substore

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_TERMINATED_OUTBOX`.
* The store key is set to the ID of the terminated chain `chainID`.
* The store value is the serialization of an object following the JSON schema `terminatedOutboxAccountSchema` presented below.
* Notation: For the rest of this proposal let `terminatedOutboxAccount(chainID)` be the terminated outbox account corresponding to the store key `chainID`.

##### JSON Schema

```java
terminatedOutboxAccountSchema = {
    "type": "object",
    "required": ["outboxRoot", "outboxSize", "partnerChainInboxSize"],
    "properties": {
        "outboxRoot": {
            "dataType": "bytes",
            "length": HASH_LENGTH,
            "fieldNumber": 1
        },
        "outboxSize": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "partnerChainInboxSize": {
            "dataType": "uint64",
            "fieldNumber": 3
        }
    }
}
```
##### Properties and Default values

* `outboxRoot`: The outbox root of the terminated chain, initialized to `channel(chainID).outbox.root`, where `chainID` is the chain ID of the terminated chain.
* `outboxSize`: The outbox size of the terminated chain, set to `channel(chainID).outbox.size`, where `chainID` is the chain ID of the terminated chain.
* `partnerChainInboxSize`: The number of cross-chain messages  processed in the terminated chain, set to the `partnerChainInboxSize` property contained in the message recovery initialization command.

A terminated outbox account is created as part of the processing of a message recovery initialization command.

#### Registered Names Substore

This substore contains the names of all chains in the ecosystem. It is present only on the mainchain. Entries are created as part of the processing of the sidechain registration command.

##### Substore Prefix, Store Key, and Store Value

* The substore prefix is set to `SUBSTORE_PREFIX_REGISTERED_NAMES`.
* The store key is set to `name`, serialized as a utf-8 encoded string, where `name` is the name of the registered chain.
* The store value is the serialization of an object following the JSON schema `chainIDSchema` presented below.

##### JSON Schema

```java
chainIDSchema = {
    "type": "object",
    "required": ["chainID"],
    "properties": {
        "chainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        }
    }
}
```

##### Properties and Default values

* `chainID`: The ID of the chain.

An entry for the mainchain is present by default, where:

* The store key is set to `CHAIN_NAME_MAINCHAIN`.
* The store value is an object with `chainID == CHAIN_ID_MAINCHAIN`, serialized using the JSON schema `chainIDSchema`.

### Internal Functions

#### appendToInboxTree

The `appendToInboxTree` function appends a new element to the underlying Merkle tree of the inbox of a chain account.

```python
def appendToInboxTree(chainID: ChainID, appendData: bytes) -> None:
    # Update root, appendPath, and size
    inboxTree = Merkle tree of channel(chainID).inbox
    inboxTree.append(sha256(appendData))
    channel(chainID).inbox.root = inboxTree.root
    channel(chainID).inbox.appendPath = inboxTree.appendPath
    channel(chainID).inbox.size = inboxTree.size
```

#### appendToOutboxTree

The `appendToOutboxTree` function appends a new element to the underlying Merkle tree of the outbox of a chain account.

```python
def appendToOutboxTree(chainID: ChainID, appendData: bytes) -> None:
    # Update root, appendPath, and size
    outboxTree = Merkle tree of channel(chainID).outbox
    outboxTree.append(sha256(appendData))
    channel(chainID).outbox.root = outboxTree.root
    channel(chainID).outbox.appendPath = outboxTree.appendPath
    channel(chainID).outbox.size = outboxTree.size
```

#### addToOutbox

The `addToOutbox` function adds a new CCM to the outbox of a chain account.

```python
def addToOutbox(chainID: ChainID, ccm: CCM) -> None:
    ccmBytes = encode(crossChainMessageSchema, ccm)
    appendToOutboxTree(chainID, ccmBytes)
    outboxRoot(chainID) = channel(chainID).outbox.root
```

#### isLive

The `isLive` function checks the liveness requirement for the partner chain. Notice that this requirement is only applied on the mainchain.

```python
def isLive(chainID: ChainID) -> bool:
    if chainID == ownChainAccount.chainID:
        return True
    
    # Processing on the mainchain
    if ownChainAccount.chainID == CHAIN_ID_MAINCHAIN:
        if chainAccount(chainID) exist:
            # Check if chain has been already terminated.
            if chainAccount(chainID).status == CHAIN_TERMINATED:
                return False
            # Check liveness condition
            timestamp = timestamp of the block where this state transition is processed
            if timestamp - chainAccount(chainID).lastCertificate.timestamp > LIVENESS_LIMIT:
                return False
            return True
        # Account has to exist on the mainchain
        return False
    # Processing on a sidechain
    else:
        if chainAccount(chainID) exist:
            # Check if chain has been already terminated.
            # Liveness condition is not checked on sidechains.
            # Account may not exist on a sidechain.
            if chainAccount(chainID).status == CHAIN_TERMINATED:
                return False

        if terminatedStateAccount(chainID) exists:
            return False
        return True
```

#### validateFormat

The `validateFormat` function checks that a CCM follows the correct schema and does not exceed a size limit of 10KB. It is specified in [LIP 0049][lip-0049].

#### apply

The `apply` function applies a CCM. It is specified in [LIP 0049][lip-0049].

#### forward

The `forward` function forwards a CCM to the specified receiving chain. This function is only called on the mainchain when processing a CCU. It is specified in [LIP 0049][lip-0049].

#### createTerminatedStateAccount

The `createTerminatedStateAccount` function creates an entry in the terminated state substore.

```python
def createTerminatedStateAccount(chainID: ChainID, stateRoot: bytes = EMPTY_BYTES) -> None:    
    if chainAccount(chainID) exists:
        chainAccount(chainID).status = CHAIN_STATUS_TERMINATED
        remove the entry with storeKey = chainID from the outbox root substore

        # If no stateRoot is given as input, get it from the state
        if len(stateRoot) == 0:
            stateRoot = chainAccount(chainID).lastCertificate.stateRoot

        terminatedState = {
            "stateRoot": stateRoot,
            "mainchainStateRoot": EMPTY_BYTES,
            "initialized": True
        }

        # Emit chain status updated event.
        emitEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CHAIN_ACCOUNT_UPDATED,
            data = chainAccount(chainID),
            topics = [chainID]
        )
        
    # State root is not available, set it to empty bytes temporarily.
    # This should only happen on a sidechain.
    else:
        # Processing on the mainchain
        if ownChainAccount.chainID == CHAIN_ID_MAINCHAIN:
            # If the account does not exist on the mainchain, the input chainID is invalid.
            raise Exception('Chain to be terminated is not valid.')

        terminatedState = {
            "stateRoot": EMPTY_BYTES,
            "mainchainStateRoot": chainAccount(CHAIN_ID_MAINCHAIN).lastCertificate.stateRoot,
            "initialized": False
        }

    create an entry in the terminated state substore with
        storeKey = chainID
        storeValue = encode(terminatedStateAccountSchema, terminatedState)
```

#### createTerminatedOutboxAccount

The `createTerminatedOutboxAccount` function creates an entry in the terminated outbox substore.

```python
def createTerminatedOutboxAccount(
    chainID: ChainID,
    outboxRoot: MerkleRoot,
    outboxSize: uint64,
    partnerChainInboxSize: uint64,
) -> None:
    terminatedOutbox = {
        "outboxRoot": outboxRoot,
        "outboxSize": outboxSize,
        "partnerChainInboxSize": partnerChainInboxSize,
    }
    create an entry in the terminated outbox substore with
        storeKey = chainID
        storeValue = encode(terminatedOutboxAccountSchema, terminatedOutbox)
```

### Commands

The Interoperability module contains the following commands:

* [Sidechain registration command][lip-0043]
* [Mainchain registration command][lip-0043]
* [Cross-Chain update command][lip-0053]
* [State recovery command][lip-0054]
* [Message recovery command][lip-0054]
* [State recovery initialization command][lip-0054]
* [Message recovery initialization command][lip-0054]

### Cross-chain Commands

The Interoperability module contains the following cross-chain commands:

* [Sidechain terminated cross-chain command][lip-0049]
* [Registration cross-chain command][lip-0049]
* [Channel terminated cross-chain command][lip-0049]
  
### Events

#### ChainAccountUpdated

This event has `name = EVENT_NAME_CHAIN_ACCOUNT_UPDATED`. 
This event is emitted when a chain account is updated.

##### Topics

- `chainID`: The ID of the chain.

##### Data

The `data` property of this event uses the `mainchainRegParams` schema given in [LIP0043][lip-0043].

#### InvalidRegistrationSignature

This event has `name = EVENT_NAME_INVALID_REGISTRATION_SIGNATURE`. 
This event is emitted when the signature in the mainchain registration command parameters is invalid.

##### Topics

- `chainID`: The ID of the chain.

##### Data

The `data` property of this event uses the `chainAccountSchema` schema given [above](#json-schema-1).


#### CrossChainMessageSent

This event has `name = EVENT_NAME_CCM_SENT`. This event is emitted when a new CCM is sent.
The status property of the data schema can take one of the following values:

1. `CCM_SENT_STATUS_SUCCESS`: The CCM was sent to the receiving chain succesfully.
2. `CCM_SENT_STATUS_CHANNEL_UNAVAILABLE`: The channel to the receiving chain is not available.
3. `CCM_SENT_STATUS_MESSAGE_FEE_ERROR`: The message fee could not be paid.

##### Topics

- `sendingChainID`: The ID of the sending chain.
- `receivingChainID`: The ID of the receiving chain.
- `sentCcmID`: The ID of the CCM that was sent.

##### Data

```java
ccmProcessedDataSchema = {
    "type": "object",
    "required": ["ccmID", "status"],
    "properties": {
        "ccmID": {
            "dataType": "bytes",
            "length": HASH_LENGTH, 
            "fieldNumber": 1
        },
        "status": {
            "dataType": "uint32",
            "fieldNumber": 2
        }
    }
}
```

#### CrossChainMessageProcessed

This event has `name = EVENT_NAME_CCM_PROCESSED`. This event is emitted when a CCM is processed.
The status property of the data schema can take one of the following values:

1. `CCM_PROCESSED_STATUS_CHANNEL_UNAVAILABLE`: The receiving chain is not available.
2. `CCM_PROCESSED_STATUS_MODULE_NOT_SUPPORTED`: The receiving chain does not support the module.
3. `CCM_PROCESSED_STATUS_COMMAND_NOT_SUPPORTED`: The receiving chain does not support the command.
4. `CCM_PROCESSED_STATUS_FORWARDED`: The CCM was forwarded to the receiving chain.
5. `CCM_PROCESSED_STATUS_APPLIED`: The CCM was applied on the receiving chain.
6. `CCM_PROCESSED_STATUS_DISCARDED`: The CCM was discarded.
7. `CCM_PROCESSED_STATUS_RECOVERY_FORWARDED`: The CCM was forwarded to the original sending chain for recovery.
8. `CCM_PROCESSED_STATUS_RECOVERY_APPLIED`: The CCM was recovered and applied on the original sending chain.
9. `CCM_PROCESSED_STATUS_RECOVERY_DISCARDED`: The CCM was recovered and discarded.


##### Topics

- `sendingChainID`: The ID of the sending chain.
- `receivingChainID`: The ID of the receiving chain.

##### Data

```java
ccmProcessedDataSchema = {
    "type": "object",
    "required": ["ccmID", "status"],
    "properties": {
        "ccmID": {
            "dataType": "bytes",
            "length": HASH_LENGTH, 
            "fieldNumber": 1
        },
        "status": {
            "dataType": "uint32",
            "fieldNumber": 2
        }
    }
}
```

### Protocol Logic for Other Modules

#### send

The `send` function is used to create and add a message to the outbox of a partner chain.

```python
def send(sendingAddress: Address, 
    module: Module, 
    crossChainCommand: CrossChainCommand, 
    receivingChainID: ChainID, 
    fee: uint64, 
    status: uint32, 
    params: object
) -> None:
    # Processing on the mainchain
    if ownChainAccount.chainID == CHAIN_ID_MAINCHAIN:
        # Chain has to exist on mainchain
        if chainAccount(receivingChainID) does not exists:
            emitPersistentEvent(
                module = MODULE_NAME_INTEROPERABILITY,
                name = EVENT_NAME_CCM_SENT,
                data = {"ccmID": ccmID, "status": CCM_PROCESSED_STATUS_CHANNEL_UNAVAILABLE},
                topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
            )
            raise Exception('Receiving chain does not exist.')
        partnerChainID = receivingChainID
    # Processing on a sidechain
    else:
        # Check for direct channel
        if chainAccount(receivingChainID) does not exists:
            partnerChainID = mainchainID
        else:
            partnerChainID = receivingChainID

    # Chain must be live; This checks is always on the receivingChainID
    if not isLive(receivingChainID):
        emitPersistentEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_SENT,
            data = {"ccmID": ccmID, "status": CCM_SENT_STATUS_CHANNEL_UNAVAILABLE},
            topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
        )
        raise Exception('Receiving chain is not live.')
    # Chain status must be active
    if not chainAccount(partnerChainID).status == CHAIN_STATUS_ACTIVE:
        emitPersistentEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_SENT,
            data = {"ccmID": ccmID, "status": CCM_SENT_STATUS_CHANNEL_UNAVAILABLE},
            topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
        )
        raise Exception('Receiving chain is not active.')

    # Create cross-chain message
    paramsSchema = JSON schema associated with (module, crossChainCommand)
    ccm = {
        "nonce": ownChainAccount.nonce,
        "module": module,
        "crossChainCommand": crossChainCommand,
        "sendingChainID": ownChainAccount.chainID,
        "receivingChainID": receivingChainID,
        "fee": fee,
        "status": status,
        "params": encode(paramsSchema, params)
    }

    # Validate ccm size
    try:
        validateFormat(ccm)
    except Exception as e:
        emitPersistentEvent(
            module = MODULE_NAME_INTEROPERABILITY,
            name = EVENT_NAME_CCM_SENT,
            data = {"ccmID": ccmID, "status": CCM_SENT_STATUS_INVALID_FORMAT},
            topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
        )
        raise e

    # Pay message fee
    if fee > 0:
        try:
            Token.payMessageFee(sendingAddress, fee)
        except Exception as e:
            emitPersistentEvent(
                module = MODULE_NAME_INTEROPERABILITY,
                name = EVENT_NAME_CCM_SENT,
                data = {"ccmID": ccmID, "status": CCM_SENT_STATUS_MESSAGE_FEE_ERROR},
                topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
            )
            raise e

    addToOutbox(partnerChainID, ccm)
    ownChainAccount.nonce += 1

    # Emit CCM processed event.
    ccmID = sha256(encode(crossChainMessageSchema, ccm))

    emitEvent(
        module = MODULE_NAME_INTEROPERABILITY,
        name = EVENT_NAME_CCM_SENT,
        data = {"ccmID": ccmID, "status": CCM_SENT_STATUS_SUCCESS},
        topics = [ccm.sendingChainID, ccm.receivingChainID, ccmID]
    )
```

#### terminateChain

The `terminateChain` function terminates a chain account.

```python
def terminateChain(chainID: ChainID) -> None:
    # Chain was already terminated, do nothing
    if terminatedStateAccount(chainID) exists:
        return

    if chainID == ownChainAccount.chainID:
        raise Exception('Chain cannot terminate itself.')

    # Processing on a sidechain
    if ownChainAccount.chainID != CHAIN_ID_MAINCHAIN:
        # The mainchain cannot be terminated
        if chainID == CHAIN_ID_MAINCHAIN:
            raise Exception('The mainchain cannot be terminated.')

    send(
        EMPTY_FEE_ADDRESS,
        MODULE_NAME_INTEROPERABILITY,
        CROSS_CHAIN_COMMAND_CHANNEL_TERMINATED,
        chainID,
        0,
        CCM_STATUS_OK,
        EMPTY_BYTES
    )

    return createTerminatedStateAccount(chainID)
```

#### error

The `error` function is used to add an error code to a CCM and then add it to the outbox of a partner chain.

```python
def error(ccm: CCM, errorStatus: uint32) -> None:
    # Error codes from 0 to MAX_RESERVED_ERROR_STATUS (included) are reserved to the Interoperability module
    if 0 <= errorStatus <= MAX_RESERVED_ERROR_STATUS:
        raise Exception('Invalid error status.')
    
    originalCCMID = sha256(encode(crossChainMessageSchema, ccm))
    return send(
        EMPTY_FEE_ADDRESS,
        ccm.module,
        ccm.crossChainCommand,
        ccm.sendingChainID,
        0,
        errorStatus,
        ccm.params
    )
```

#### getChainAccount

```python
def getChainAccount(chainID: ChainID) -> ChainAccount:
    if chainAccount(chainID) does not exist:
        raise Exception('Chain account does not exist.')
    return chainAccount(chainID)
```

#### getChannel

```python
def getChannel(chainID: ChainID) -> Channel:
    if channel(chainID) does not exist:
        raise Exception('Channel does not exist.')
    return channel(chainID)
```

#### getChainValidators

```python
def getChainValidators(chainID: ChainID) -> Validators:
    if chainAccount(chainID) does not exist:
        raise Exception('Chain account does not exist.')
    return validators(chainID)
```

#### getOwnChainAccount

```python
def getOwnChainAccount() -> OwnChainAccount:
    if ownChainAccount does not exist:
        raise Exception('Own chain account does not exist.')
    return ownChainAccount
```

#### getTerminatedStateAccount

```python
def getTerminatedStateAccount(chainID: ChainID) -> TerminatedStateAccount:
    if terminatedStateAccount(chainID) does not exist:
        raise Exception('Terminated state account does not exist.')
    return terminatedStateAccount(chainID)
```

#### getTerminatedOutboxAccount

```python
def getTerminatedOutboxAccount(chainID: ChainID) -> TerminatedOutboxAccount:
    if terminatedOutboxAccount(chainID) does not exist:
        raise Exception('Terminated outbox account does not exist.')
    return terminatedOutboxAccount(chainID)
```

#### isChainIDAvailable

```python
def isChainIDAvailable(chainID: ChainID) -> bool:
    if chainAccount(chainID) does not exist:
        return True
    return False
```

#### isDirectChannelActive

The `isDirectChannelActive` function checks that there is a direct channel with the chain identified by the input `chainID` and that it is active.

```python
def isDirectChannelActive(chainID: ChainID) -> bool:
    if chainAccount(chainID) does not exist:
        return False
    if chainAccount(chainID).status != CHAIN_STATUS_ACTIVE:
        return False
    return True
```

### Genesis Block Processing

#### Genesis State Initialization

During the genesis state initialization stage, the following steps are executed. If any step fails, the block is discarded and has no further effect.

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the Interoperability module and let `interoperabilityAsset` be the deserialization of `genesisBlockAssetBytes` according to the `genesisInteroperabilityStoreSchema` schema, given below. Each top level entry in the schema corresponds to the substore of the Interoperability module store with the same name.

* Within each substore, check that all entries have a different `storeKey`.
* For each entry in the chain data substore there must be a corresponding entry (with the same value of `storeKey`) in the outbox root, channel data, and chain validators substores and viceversa. However, if the chain account has status set to terminated, the entry in the outbox root must *not* be present.
* For each entry in the terminated outbox substore there must be a corresponding entry (with the same value of `storeKey`) in the terminated state substore.
* For each entry in the terminated state substore, if the property `initialized` is set to `False`, the corresponding entry in the terminated outbox substore must *not* be present. Furthermore, the `stateRoot` must be set to empty bytes and `mainchainStateRoot` to a 32-bytes value. Conversely, if the property `initialized` is set to `True`, the `stateRoot` must be set to a 32-bytes value and `mainchainStateRoot` to empty bytes.
* For each entry `chainValidators` in `interoperabilityAsset.chainValidatorsSubstore`, let `activeValidators = chainValidators.storeValue.activeValidators` and let `certificateThreshold = chainValidators.storeValue.certificateThreshold`:
  * `activeValidators` must have at least 1 element and at most `MAX_NUM_VALIDATORS` elements.
  * `activeValidators` must be ordered lexicographically by `blsKey` property.
  * All `blsKey` properties have length 48 and are pairwise distinct.  
  * The `bftWeight` property of each element is a positive integer.
  * Let `totalWeight` be the sum of the `bftWeight` property of every element in `activeValidators`. Then `totalWeight` has to be less than or equal to `MAX_UINT64`.
  * Check that `⌊ ⅓ x totalWeight⌋ + 1 <= certificateThreshold <= totalWeight`, where `⌊⋅⌋` is the floor function.
* If a chain account for another sidechain is present, than a chain account for the mainchain (`chainID = 1`) must be present, as well as the own chain account.
* For each entry `channelData` in `interoperabilityAsset.channelDataSubstore`, let `channel = channelData.storeValue`:
  * Either `channel.messageFeeTokenID=TOKEN_ID_LSK` (corresponding to the LSK token), or `Token.getChainID(channel.messageFeeTokenID)` must be equal to `channelData.storeKey` or `ownChainAccount.chainID` (the message fee token must be a native token of either chains).
* For every substore, create all the corresponding entries in the Interoperability module state.

```java
genesisInteroperabilityStoreSchema = {
  "type": "object",
  "required": [
    "outboxRootSubstore",
    "chainDataSubstore",
    "channelDataSubstore",
    "chainValidatorsSubstore",
    "ownChainDataSubstore",
    "terminatedStateSubstore",
    "terminatedOutboxSubstore",
    "registeredNamesSubstore",
    "registeredNetworkIDsSubstore"
  ],
  "properties": {
    "outboxRootSubstore": {
      "type": "array",
      "fieldNumber": 1,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...outboxRootSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "chainDataSubstore": {
      "type": "array",
      "fieldNumber": 2,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...chainAccountSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "channelDataSubstore": {
      "type": "array",
      "fieldNumber": 3,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...channelSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "chainValidatorsSubstore": {
      "type": "array",
      "fieldNumber": 4,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...validatorsSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "ownChainDataSubstore": {
      "type": "array",
      "fieldNumber": 5,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...ownChainAccountSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "terminatedStateSubstore": {
      "type": "array",
      "fieldNumber": 6,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...terminatedStateAccountSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "terminatedOutboxSubstore": {
      "type": "array",
      "fieldNumber": 7,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...terminatedOutboxAccountSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "registeredNamesSubstore": {
      "type": "array",
      "fieldNumber": 8,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...chainIDSchema,
            "fieldNumber": 2,
          }
        }
      }
    },
    "registeredNetworkIDsSubstore": {
      "type": "array",
      "fieldNumber": 9,
      "items": {
        "type": "object",
        "required": ["storeKey", "storeValue"],
        "properties": {
          "storeKey": {
            "dataType": "bytes",
            "fieldNumber": 1
          },
          "storeValue": {
            ...chainIDSchema,
            "fieldNumber": 2,
          }
        }
      }
    }
  }
}
```

Here, the `...` notation, borrowed from [JavaScript ES6 data destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring), indicates that the corresponding schema should be inserted in place, and it is just used for notational convenience.

#### Genesis State Finalization

The Interoperability module does not execute any logic during the genesis state finalization.

## Backwards Compatibility

This proposal, together with [LIP 0043][lip-0043], [LIP 0049][lip-0049], [LIP 0053][lip-0053], and [LIP 0054][lip-0054], is part of the Interoperability module. Chains adding this module will need to do so with a hard fork.

[lip-0043]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0043.md
[lip-0049]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md
[lip-0049#ccmschema]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#cross-chain-message-schema
[lip-0053]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0053.md
[lip-0054]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0054.md
[lip-0055#block-processing-stages]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md#block-processing-stages
[lip-0061#certificate-schema]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0061.md#schema
