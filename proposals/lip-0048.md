```
LIP: 0048
Title: Introduce Fee module
Author: Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
        Mitsuaki Uchimoto <mitsuaki.uchimoto@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-fee-module/318
Status: Draft
Type: Standards Track
Created: 2021-08-09
Updated: 2023-02-24
Requires: 0051
```

## Abstract

The Fee module is responsible for handling the fee of transactions. It allows chains to choose the token used to pay the fee and to define a minimum fee for transactions to be valid.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

This LIP defines the fee system in a modular way, as currently [used in the Lisk ecosystem][lip-0040]. The fee handling is implemented in a separate module to allow sidechains to freely update or replace the fee handling module, possibly to implement a more complex fee structure, without needing to modify or update the Token module.

## Rationale

### Initialization Fee

The fee structure presented here allows for defining a sufficient cost to manage state growth. In principle, any transaction resulting in a state increase should imply a fee. This reasoning is implemented in the [`payFee`](#payfee) method, which can be invoked by other modules to charge *initialization fee* for data store initializations or some other special purposes, e.g., chain or validator registration. 

For example, this method is called during the execution of the [validator registration command][lip-0057#execution] in LIP 0057: 
```python
Fee.payFee(VALIDATOR_REGISTRATION_FEE)
```

### Transaction Fee

*Transaction fees* are introduced to motivate validators. Any remaining amount from the transaction fee, not consumed by the transaction processing, is given as a reward to the validator that includes the transaction in a block. 

#### Fee Token ID

Each chain can configure the token used to pay fees, as defined by `TOKEN_ID_FEE`. On the Lisk mainchain, the token used for transaction fees is the LSK token.

#### Minimum Fee per Transaction

As introduced in [LIP 0013][lip-0013], all transactions must have a transaction fee greater or equal to a *minimum fee*, which is introduced in order to discourage validators from sending zero-cost transactions in the blocks they generate. 

For a transaction `trs`, the minimum fee is determined by its size and the proportionality constant `MIN_FEE_PER_BYTE`: 
```python
trsSize = length(encodeTransaction(trs))
minFee = MIN_FEE_PER_BYTE * trsSize
```
Note that chains can freely configure their `MIN_FEE_PER_BYTE`, which can be even set to zero. The value `MIN_FEE_PER_BYTE` can not be modified, unless a hard fork occurs. For this reason, we allow sidechains the possibility to define a period of `MAX_BLOCK_HEIGHT_ZERO_FEE_PER_BYTE` blocks after the genesis block for which the minimum fee does not apply. 

This could be useful, for example, for sidechains that want to use LSK as the fee token: Initially, no LSK is present on the sidechain, so the sidechain would not be able to process any transactions unless `MIN_FEE_PER_BYTE` is set to zero. By allowing an initial exception period, users have a time window to transfer LSK tokens to this sidechain, after which the initially set value of `MIN_FEE_PER_BYTE` would start being applied. 

### Fee Pool

Chains can choose to either burn the fee consumed by transaction processing, on the other hand, to transfer it to a dedicated pool address, `ADDRESS_FEE_POOL`. The latter choice could be beneficial for sidechains, as fees collected in this way can be used as an incentive for validators and other protocol participants for various purposes like funding a community pool for on-chain governance spending, sharing the funds among validators proportionally per round, incentivizing ecosystem developers, supporting chain maintenance and improvement, rewarding user staking/voting activity, etc.

In the Lisk mainchain, the remaining fee is always burned, reducing the total supply and thus introducing a deflationary pressure to counteract the inflation.

### Cross-chain Message Fee

Cross-chain messages or CCMs facilitate interoperability by enabling cross-chain transfer of data. They require an associated fee, distinct from the usual transaction fee, paid by the relayer. Similarly to transaction fees, the minimum CCM fee can be either burned or transferred to a fee pool, depending on the chain configuration.

## Specification

### Notation and Constants

We define the following constants:

| Name                                 | Type   | Value                                  | Description                                                       |
| ------------------------------------ | ------ | -------------------------------------- | ----------------------------------------------------------------- |
| **General Constants**                |        |                                        |                                                                   |
| `MODULE_NAME_FEE`                    | string | "fee"                                  | Module name of the Fee module.                                    |
| `EVENT_NAME_GENERATOR_FEE_PROCESSED` | string | "generatorFeeProcessed"                | Event name of the GeneratorFeeProcessed event.                    |
| `EVENT_NAME_RELAYER_FEE_PROCESSED`   | string | "relayerFeeProcessed"                  | Event name of the RelayerFeeProcessed event.                      |
| `EVENT_NAME_INSUFFICIENT_FEE`        | string | "insufficientFee"                      | Event name of the InsufficientFee event.                          |
| `LENGTH_ADDRESS`                     | uint32 | 20                                     | The length of an address in bytes.                                |
| `LENGTH_TOKEN_ID`                    | uint32 | 8                                      | The length of a token ID in bytes.                                |
| **Configurable Constants**           |        | **Mainchain Value**                    |                                                                   |
| `MIN_FEE_PER_BYTE`                   | uint64 | 1000                                   | Minimum amount of fee per byte required for transaction validity. |
| `MAX_BLOCK_HEIGHT_ZERO_FEE_PER_BYTE`                   | uint32 | 0                                   | Block height ending the `MIN_FEE_PER_BYTE = 0` initial period. |
| `TOKEN_ID_FEE`                       | bytes  | `OWN_CHAIN_ID[0:1] + '00000000000000'` | Token ID of the token used to pay the transaction fees.           |
| `ADDRESS_FEE_POOL`                   | bytes  | None                                   | Address of the fee pool.                                          |

### Type Definitions

We use the definition of the following types:

| Name          | Type   | Validation                                                                                                                                                                                                                                                                                    | Description                                          |
| ------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| `TokenID`     | bytes  | Must be of length `LENGTH_TOKEN_ID`.                                                                                                                                                                                                                                                          | Used for token identifiers.                          |

Furthermore, for the rest of this LIP we indicate with `ctx` the execution context which is passed as extra input to each method call.

### Functions from Other Modules

Calling a function `fct` from another module (named `module`) is represented by `module.fct(required inputs)`.

### Fee Module Store

The Fee module does not store information in the state.

### Commands

The Fee module does not contain any commands.

### Events

#### GeneratorFeeProcessed

This event has name `name = EVENT_NAME_GENERATOR_FEE_PROCESSED`. The event is emitted when a transaction fee is assigned to the generator. Event's data includes the amount of burnt fee tokens and the amount of fee tokens paid to the block generator.

##### Topics

- `senderAddress`: the address of the account paying the fee.
- `generatorAddress`: the address of the generator of the block receiving the fee.

##### Data

```java
generatorFeeProcessedEventDataSchema = {
    "type": "object",
    "required": ["senderAddress", "generatorAddress", "requiredAmount", "generatorAmount"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "length": LENGTH_ADDRESS,
            "fieldNumber": 1
        },
        "generatorAddress": {
            "dataType": "bytes",
            "length": LENGTH_ADDRESS,
            "fieldNumber": 2
        },
        "requiredAmount": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
        "generatorAmount": {
            "dataType": "uint64",
            "fieldNumber": 4
        }
    }
}
```

#### RelayerFeeProcessed

This event has name `name = EVENT_NAME_RELAYER_FEE_PROCESSED`. The event is emitted when a message fee is assigned to the CCU relayer. Event's data includes the amount of burnt fee tokens and the amount of fee tokens paid to the relayer.

##### Topics

- `relayerAddress`: the address of the relayer.

##### Data

```java
relayerFeeProcessedEventDataSchema = {
    "type": "object",
    "required": ["ccmID", "relayerAddress", "requiredAmount", "relayerAmount"],
    "properties": {
        "ccmID": {
            "dataType": "bytes",
            "length": LENGTH_HASH,
            "fieldNumber": 1
        },
        "relayerAddress": {
            "dataType": "bytes",
            "length": LENGTH_ADDRESS,
            "fieldNumber": 2
        },
        "requiredAmount": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
        "relayerAmount": {
            "dataType": "uint64",
            "fieldNumber": 4
        }
    }
}
```

#### InsufficientFee

This event has name `name = EVENT_NAME_INSUFFICIENT_FEE`. The event is emitted when there is not enough transaction or cross-chain message fee left.

##### Topics

This event has no extra topics (only the default transaction or cross-chain message ID).

##### Data

```java
insufficientFeeDataSchema = {
    "type": "object",
    "required": [],
    "properties": {}
}
```

### Protocol Logic for Other Modules

#### payFee

```python
def payFee(amount: uint64) -> None:
    # ctx.ccmProcessing is set by the Interoperability module during the CCM processing.
    # In particular, before the CCM is processed, ctx.ccmProcessing is set to True.
    # After the CCM is processed, ctx.ccmProcessing is set to False.
    if ctx.ccmProcessing:
        ctx.availableCCMFee -= amount
        if ctx.availableCCMFee < 0:
            ctx.availableCCMFee = 0
            emitPersistentEvent(
                module = MODULE_NAME_FEE,
                name = EVENT_NAME_INSUFFICIENT_FEE,
                data = {},
                topics = []
            )
            raise Exception("Cross-chain message ran out of fee.")
    else:
        ctx.availableTransactionFee -= amount
        if ctx.availableTransactionFee < 0:
            ctx.availableTransactionFee = 0
            emitPersistentEvent(
                module = MODULE_NAME_FEE,
                name = EVENT_NAME_INSUFFICIENT_FEE,
                data = {},
                topics = []
            )
            raise Exception("Transaction ran out of fee.")
```

#### getFeeTokenID

```python
def getFeeTokenID() -> TokenID:
    return TOKEN_ID_FEE
```

### Block Processing

#### Verify Transaction

```python
def verify(trs: Transaction) -> None:
    b = block including trs
    h = b.header.height
    if h < MAX_BLOCK_HEIGHT_ZERO_FEE_PER_BYTE:
	    # Set minFee = 0 for the first MAX_BLOCK_HEIGHT_ZERO_FEE_PER_BYTE blocks.
        minFee = 0
    else:    
        trsSize = length(encodeTransaction(trs))
        minFee = MIN_FEE_PER_BYTE * trsSize
    if trs.fee < minFee:
        raise Exception("Insufficient transaction fee")
    senderAddress = sha256(trs.senderPublicKey)[:LENGTH_ADDRESS]
    if not Token.userSubstoreExists(senderAddress, TOKEN_ID_FEE):
        raise Exception("Account not initialized")
    if trs.fee > Token.getAvailableBalance(senderAddress, TOKEN_ID_FEE):
        raise Exception("Insufficient balance")
```

#### Before Command Execution

```python
def beforeCommandExecute(trs: Transaction) -> None:
    senderAddress = sha256(trs.senderPublicKey)[:LENGTH_ADDRESS]
    Token.lock(senderAddress, MODULE_NAME_FEE, TOKEN_ID_FEE, trs.fee)
    minFee = MIN_FEE_PER_BYTE * len(encodeTransaction(trs))
    ctx.availableTransactionFee = trs.fee - minFee
```

#### After Command Execution

```python
def afterCommandExecute(trs: Transaction) -> None:
    let b be the block including trs
    generatorAddress = b.header.generatorAddress
    senderAddress = sha256(trs.senderPublicKey)[:LENGTH_ADDRESS]
    # The fee paid to the generator is the difference between the fee paid by the sender and the paid fees.
    Token.unlock(senderAddress, MODULE_NAME_FEE, TOKEN_ID_FEE, trs.fee)

    if Token.userSubstoreExists(generatorAddress, TOKEN_ID_FEE):
        Token.transfer(senderAddress, generatorAddress, TOKEN_ID_FEE, ctx.availableTransactionFee)
    else:
        ctx.availableTransactionFee = 0

    burnConsumedFee = False if (ADDRESS_FEE_POOL is not None and Token.userSubstoreExists(ADDRESS_FEE_POOL, TOKEN_ID_FEE)) else True

    if burnConsumedFee:
       Token.burn(senderAddress, TOKEN_ID_FEE, trs.fee - ctx.availableTransactionFee)
    else:
       Token.transfer(senderAddress, ADDRESS_FEE_POOL, TOKEN_ID_FEE, trs.fee - ctx.availableTransactionFee)

    emitEvent(
        module = MODULE_NAME_FEE,
        name = EVENT_NAME_GENERATOR_FEE_PROCESSED,
        data = {
            "senderAddress": senderAddress,
            "generatorAddress": generatorAddress,
            "requiredAmount": trs.fee - ctx.availableTransactionFee,
            "generatorAmount": ctx.availableTransactionFee
        },
        topics = [senderAddress, generatorAddress]
    )
    ctx.availableTransactionFee = 0
```

### Cross-chain Update Processing

#### Before Cross-chain Command Execution

```python
def beforeCrossChainCommandExecution(trs: Transaction, ccm: CCM) -> None:
    # The Token module handles checks on the ccm.fee validity
    # with respect to the escrow account of the ccm sending chain.
    messageFeeTokenID = Interoperability.getMessageFeeTokenID(ccm.sendingChainID)
    relayerAddress = sha256(trs.senderPublicKey)[:LENGTH_ADDRESS]

    # The Token module beforeCrossChainCommandExecution needs to be called first
    # to ensure that the relayer has enough funds.
    Token.lock(relayerAddress, MODULE_NAME_FEE, messageFeeTokenID, ccm.fee)
    ctx.availableCCMFee = ccm.fee
```

#### After Cross-chain Command Execution

```python
def afterCrossChainCommandExecution(trs: Transaction, ccm: CCM) -> None:
    # The fee paid to the relayer is the difference between the message fee and the paid fees.
    relayerAddress = sha256(trs.senderPublicKey)[:LENGTH_ADDRESS]
    messageFeeTokenID = Interoperability.getMessageFeeTokenID(ccm.sendingChainID)
    Token.unlock(relayerAddress, MODULE_NAME_FEE, messageFeeTokenID, ccm.fee)

    burnConsumedFee = False if (ADDRESS_FEE_POOL is not None and Token.userSubstoreExists(ADDRESS_FEE_POOL, messageFeeTokenID)) else True

    if burnConsumedFee:
        Token.burn(relayerAddress, messageFeeTokenID, ccm.fee - ctx.availableCCMFee)
    else:
        # Transfer the cross-chain message fees to the pool account address, if it exists and it is initialized for the cross-chain message fee token.
        Token.transfer(relayerAddress, ADDRESS_FEE_POOL, messageFeeTokenID, ccm.fee - ctx.availableCCMFee)
    
    # No need to transfer as the remaining fee is already in the relayer account.    
    
    ccmID = sha256(encodeCCM(ccm))
    emitEvent(
        module = MODULE_NAME_FEE,
        name = EVENT_NAME_RELAYER_FEE_PROCESSED,
        data = {
            "ccmID": ccmID,
            "relayerAddress": relayerAddress,
            "requiredAmount": ccm.fee - ctx.availableCCMFee,
            "relayerAmount": ctx.availableCCMFee
        },
        topics = [relayerAddress]
    )
    ctx.availableCCMFee = 0
```

### Endpoints for Off-Chain Services

To be completed by the dev team.

## Backwards Compatibility

This LIP defines a new Fee module, which follows the same protocol as currently implemented. Changing the implementation to include the Fee module will be backwards compatible.

## Reference Implementation

TBA

[lip-0013]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0013.md
[lip-0040]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0040.md
[lip-0049#ccmschema]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#cross-chain-message-schema
[lip-0057#execution]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0057.md#execution