```
LIP: 0052
Title: Introduce NFT module
Author: Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-nft-module/297
Status: Draft
Type: Standards Track
Created: 2021-05-22
Updated: 2022-03-22
Requires: 0045
```

## Abstract

This topic introduces an NFT (non-fungible token) module to be used in the Lisk ecosystem for creating, destroying NFTs, and transferring them in the ecosystem.

NFTs are uniquely identified assets. They can be transferred similarly to fungible tokens, but their unique identifiers can never be modified. In this module, NFTs also carry a list of attributes that are used to store information specific to the NFT.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

NFTs are very common in the blockchain space and have uses in a wide range of applications. This can go from being the virtual representation of a real world object (art, fashion, event tickets ...) to purely virtual collectibles (crypto kitties, ...).

Therefore, providing a unified module to handle, transfer and modify NFTs is a necessity for the Lisk ecosystem. The module presented here contains all the basic features that are needed to incorporate NFTs in a blockchain ecosystem without being restrictive on the way NFTs will be used by custom modules and applications.

## Rationale

### Technical Glossary

- **Native chain:** with regards to an NFT, this is the chain where the NFT was created.
- **Native NFT:** with regards to a chain, all NFTs created on this chain.
- **Foreign chain:** with regards to an NFT, all chains other than the native chain.

### NFT Module Store

<img src="lip-0052/nft_module_store.png" width="80%">

_Figure 1: The NFT module store is divided into 5 substores. All NFTs held by users are stored sequentially in the user substore with keys given by the user address and the NFT ID._

#### NFT Store

The NFT store contains entries for all NFTs present on the chain, as well as entries for all native NFTs that have been sent cross-chain. Each entry contains three properties, the owner, the locking module ID and the attributes of the NFT. The owner can either be a 20 bytes user address or a 4 bytes chain ID. In the latter case, the token is a native token that has been sent cross-chain and is escrowed.

The locking module property stores the information regarding the locking status of the NFT. If the NFT is unlocked, this property will have the value `NFT_NOT_LOCKED`, whereas if the NFT is locked, this property will store the locking module name.

Lastly, the NFT stores an attribute property which can be used by custom applications to store information about the NFT, or modify interactions with the NFT.

#### User Substore

In the proposed solution, all NFTs associated with a given address are stored sequentially in the user substore part of the state. In this way, getting all NFTs of a given account can be done efficiently. This is in contrast to specifications (like [ERC 721](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md) without optional extensions) where the NFT owner is only stored as one of the NFTs properties. We think that this feature is useful in an account based blockchain ecosystem and the user substore is designed accordingly.

### NFT Identifier

To identify NFTs in the Lisk ecosystem, we introduce the NFT ID, a unique NFT identifier in the ecosystem. It is a 16-byte concatenation of the [chain ID][research:chain-registration] of the chain creating the token, and the serializations of a collection integer, chosen when the token is created, and an index which is automatically assigned to the new NFT.

This allows chains to define multiple sets of NFTs, each identified by their respective collection. Each collection can then easily have its own attribute schema and custom logic. For example, an art NFT exchange could have a different collection per artist. The index being then the unique integer associated with each art piece of this artist.

### Cross-chain NFT Transfer

To allow cross-chain transfers of NFTs, we define a specific command which makes use of the [Interoperability module][research:base-interoperability] and creates a [cross-chain message][research:ccm] with the relevant information. When sending NFTs cross-chain, it is crucial that every chain can correctly escrow its native tokens sent to other chains. In this way, a native NFT can never be created by a foreign chain and sent across the ecosystem. When receiving non-native NFTs on a chain, users can query this NFT's native chain to make sure that the NFT is properly escrowed.

#### Transfer To and From the Native Chain

These specifications only allow NFTs to be transferred to and from their native chain. In particular, this means that a token created on chain A cannot be transferred directly from chain B to chain C. This is required to allow the native chain to maintain correctly escrowed NFTs.

### Attributes

Each NFT is stored with an attribute property. This property is a byte sequence that is not deserialized by the NFT module. Each custom module using an NFT collection should define schemas to serialize and deserialize the attribute property of NFTs of their collection.

When an NFT is sent to another chain, the attributes property of the NFT can be modified according to specifications set on the receiving chain. For this reason, custom modules specifying an NFT collection must also implement the behavior to adopt when an NFT is returned with a modified attributes property. This custom behavior will compare the returned attributes with the ones stored with the escrowed NFT. If the returned NFT has an empty attribute, the native chain will restore the attributes as stored, this can be used to save on cross-chain messages size when returning non-modified NFTs to their native chains.

### Protocol Logic for Other Modules

The NFT module provides the following functions to modify the NFT state. Any other modules should use those functions to modify the NFT state. The NFT state should never be modified from outside the module without using one of the provided functions as this could result in unexpected behavior and could cause an improper state transition.

#### create

This function is used to create a new NFT. The NFT will always be native to the chain creating it. The index of the created NFT will be the next available index, as specified by the max index corresponding to the collection.

#### destroy

This function is used to destroy NFTs. The NFT will be removed from the NFT store and cannot be retrieved. The use of this function is limited to destroying native NFTs.

#### transfer

This function is used to transfer ownership of NFTs within one chain.

#### transferCrossChain

This function is used to transfer ownership of NFTs across chains in the Lisk ecosystem.

#### lock

This function is used to lock an NFT to a `module` name. A locked NFT cannot be transferred (within the chain or across chains). This can be useful, for example, when the NFT is used as a deposit for a service. A `module` name is specified both when locking and unlocking the NFT, thus preventing NFTs being accidentally locked and unlocked by different modules.

#### unlock

This function is used to unlock an NFT that was locked with a given `module` name.

#### setAttributes

This function is used to modify the attributes of NFTs. Each custom module can define the rules surrounding modifying NFT attributes and should call this function. This function will be executed even if the NFT is locked.

#### recover

This function should only be called by the Interoperability module to trigger the recovery of NFTs escrowed to terminated chains.

## Specification

### Constants and Notations

The following constants are used throughout the document:

| Name                                   | Type   | Value             |
| -------------------------------------- | ------ | ----------------- |
| **Interoperability Constants**         |        |                   |
| `MAINCHAIN_ID`                         | bytes  | 0x 00 00 00 00    |
| **NFT Module Constants**               |        |                   |
| `MODULE_NAME_NFT`                      | string | "nft"             |
| `COMMAND_NAME_TRANSFER`                | string | "transfer"        |
| `COMMAND_NAME_CROSS_CHAIN_TRANSFER`    | string | TBD               |
| `CROSS_CHAIN_COMMAND_NAME_TRANSFER`    | string | TBD               |
| `CHAIN_ID_ALIAS_NATIVE`                | bytes  | 0x 00 00 00 00    |
| `NFT_NOT_LOCKED`                       | string | `MODULE_NAME_NFT` |
| `MAX_BYTE_LENGTH_ATTRIBUTES`           | uint32 | 9 \* 1024         |
| `CCM_STATUS_OK`                        | uint32 | 0                 |
| `CCM_STATUS_NFT_NOT_SUPPORTED`         | uint32 | 64                |
| `CCM_STATUS_NFT_PROTOCOL_VIOLATION`    | uint32 | 65                |
| **Store Constants**                    |        |                   |
| `SUBSTORE_PREFIX_NFT`                  | bytes  | 0x00 00           |
| `SUBSTORE_PREFIX_USER`                 | bytes  | 0x80 00           |
| `SUBSTORE_PREFIX_COLLECTION`           | bytes  | 0xc0 00           |
| `SUBSTORE_PREFIX_AVAILABLE_COLLECTION` | bytes  | 0xd0 00           |
| `SUBSTORE_KEY_LENGTH_NFT`              | uint32 | 16                |
| **General Constants**                  |        |                   |
| `ADDRESS_LENGTH`                       | uint32 | 20                |
| `MIN_MODULE_NAME_LENGTH`               | uint32 | 1                 |
| `MAX_MODULE_NAME_LENGTH`               | uint32 | 32                |
| `NFT_ID_LENGTH`                        | uint32 | 16                |
| `CHAIN_ID_LENGTH`                      | uint32 | 4                 |
| `EMPTY_BYTES`                          | bytes  | ""                |

### Event Names and Results

| Name                           | Type   | Value             | Description                                                          |
| ------------------------------ | ------ | ----------------- | -------------------------------------------------------------------- |
| **Names**                      |        |                   |                                                                      |
| `EVENT_NAME_CREATE_NFT_ENTRY`  | string | "createNFTEntry"  | Name of the event emitted during token NFT substore entry creation.  |
| `EVENT_NAME_DELETE_NFT_ENTRY`  | string | "deleteNFTEntry"  | Name of the event emitted during token NFT substore entry deletion.  |
| `EVENT_NAME_CREATE_USER_ENTRY` | string | "createUserEntry" | Name of the event emitted during token user substore entry creation. |
| `EVENT_NAME_DELETE_USER_ENTRY` | string | "deleteUserEntry" | Name of the event emitted during token user substore entry deletion. |
| **Result codes**               |        |                   |                                                                      |
| `RESULT_SUCCESSFUL`            | uint32 | 0                 | Successful result code for events.                                   |

### Type Definitions

| Name      | Type   | Validation                                                                                | Description                   |
| --------- | ------ | ----------------------------------------------------------------------------------------- | ----------------------------- |
| `Address` | bytes  | Must be of length `ADDRESS_LENGTH`.                                                       | Address of an account.        |
| `Module`  | string | Must be of length at least `MIN_MODULE_NAME_LENGTH` and at most `MAX_MODULE_NAME_LENGTH`. | Used for identifying modules. |
| `NFTID`   | bytes  | Must be of length `NFT_ID_LENGTH`.                                                        | Used for NFT identifiers.     |
| `ChainID` | bytes  | Must be of length `CHAIN_ID_LENGTH`.                                                      | Used for chain identifiers.   |

#### uint32be Function

The function `uint32be(x)` returns the big endian uint32 serialization of an integer `x`, with `0 <= x < 2^32`. This serialization is always 4 bytes long.

#### uint64be Function

The function `uint64be(x)` returns the big endian uint64 serialization of an integer `x`, with `0 <= x < 2^64`. This serialization is always 8 bytes long.

#### length Function

In this LIP, `length(byteSequence)` returns the length in bytes of `byteSequence`.

#### Logic from Other Modules

Calling a function `fct` from the [Interoperability module][research:base-interoperability] is represented by `Interoperability.fct(required inputs)`.

### NFT Identification

All NFTs in the ecosystem are identified by the three values `chainID`, `collection` and `index`.

- `chainID` is always the chain ID of the chain that created the NFT,
- `collection` is an integer specified at NFT creation,
- `index` is assigned at NFT creation to the next available index in the collection.

In this LIP, the NFT identifier `nftID` is a 16-byte concatenation of the ID of the NFT native chain and the serializations of `collection` and `index`: `nftID = chainID + uint32be(collection) + uint64be(index)`. This is for example used in all input formats for the module's exposed logics. This allows the exposed logic interfaces to be simple and uniform. This choice follows a potential way how the module could be implemented in JavaScript, the same behavior could be implemented with a named tuple in Python.

#### NFT ID and Native NFT

The NFTs on their native chain have the `chainID` part of the `nftID` equal to `CHAIN_ID_ALIAS_NATIVE`. The same NFT in other chains would be identified by `chainID = nativeChainID`, `nativeChainID` being the chain ID of the chain where the NFT was created.

#### Supported NFTs

The NFT module contains a function used when receiving cross-chain NFT transfers to assert the support for non-native NFTs. It should return a boolean, depending on the configuration of the NFT module. For the rest of this LIP, this function is written `NFTSupported(nftID)`.

### NFT Module Store

The store keys and schemas for value serialization of the NFT store are set as follows:

#### NFT Substore

- The substore prefix is set to `SUBSTORE_PREFIX_NFT`.
- Each store key is an NFT ID: `nftID`.
- Each store value is the serialization of an object following `NFTStoreSchema`.

```java
NFTStoreSchema = {
    "type": "object",
    "required": [
        "owner",
        "lockingModule",
        "attributes"
    ],
    "properties": {
        "owner": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "lockingModule": {
            "dataType": "string",
            "minLength": MIN_MODULE_NAME_LENGTH,
            "maxLength": MAX_MODULE_NAME_LENGTH,
            "pattern": "^[a-zA-Z0-9]*$]",
            "fieldNumber": 2
        },
        "attributes": {
            "dataType": "bytes",
            "maxLength": MAX_BYTE_LENGTH_ATTRIBUTES,
            "fieldNumber": 3
        }
    }
}
```

#### User Substore

- The substore prefix is set to `SUBSTORE_PREFIX_USER`.
- Each store key is a concatenation of an address and a NFT ID: `address + nftID`.
- Each store value is the serialization of an object following `userStoreSchema`.

```java
userStoreSchema = {
    "type": "object",
    "required": ["exists"],
    "properties": {
        "exists": {
            "dataType": "boolean",
            "fieldNumber": 1
        }
    }
}
```

#### Collection Substore

- The substore prefix is set to `SUBSTORE_PREFIX_COLLECTION`.
- Each store key is a collection: `uint32be(collection)`.
- Each store value is the serialization of an object following `collectionStoreSchema`.

```java
collectionStoreSchema = {
    "type": "object",
    "required": ["nextAvailableIndex"],
    "properties": {
        "nextAvailableIndex": {
            "dataType": "uint64",
            "fieldNumber": 1
        }
    }
}
```

#### Available Collection Substore

- The substore prefix is set to `SUBSTORE_PREFIX_AVAILABLE_COLLECTION`.
- Each store key is the empty bytes.
- Each store value is the serialization of an object following `availableCollectionStoreSchema`.

```java
availableCollectionStoreSchema = {
    "type": "object",
    "required": ["nextAvailableCollection"],
    "properties": {
        "nextAvailableCollection": {
            "dataType": "uint32",
            "fieldNumber": 1
        }
    }
}
```

#### Store Notation

For the rest of this proposal:

- Let `NFTStore(nftID)` be the NFT substore entry with store key `nftID`.
- Let `userStore(address, nftID)` be the user substore entry with store key `address + nftID`.
- Let `collectionStore(collection)` be the collection substore entry with store key `uint32be(collection)`.
- Let `nextAvailableCollection` be the `nextAvailableCollection` property of the entry of the available collection substore.

### Commands

The module provides the following commands to modify the NFT store.

#### NFT Transfer

Transactions executing this command have:

- `module = MODULE_NAME_NFT`
- `command = COMMAND_NAME_TRANSFER`

##### Parameters Schema

The `params` property of an NFT transfer transaction follows the schema `NFTTransferParamsSchema`.

```java
NFTTransferParamsSchema = {
    "type": "object",
    "required": [
        "nftID",
        "recipientAddress"
    ],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1,
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:

    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    nftID = trs.params.nftID
    recipientAddress = trs.params.recipientAddress

    if NFTStore(nftID).lockingModule != NFT_NOT_LOCKED:
        raise Exception("NFT is locked.")

    if NFTStore(nftID).owner != senderAddress:
        raise Exception("Sender is not the NFT owner.")

```

##### Execution

```python
def execute(trs: Transaction) -> None:

    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    nftID = trs.params.nftID
    recipientAddress = trs.params.recipientAddress

    deleteUserEntry(senderAddress, nftID)
    createUserEntry(recipientAddress, nftID)
    NFTStore(nftID).owner = recipientAddress
```

Here, deleteUserEntry and createUserEntry are internal functions that respectively delete and create an entry in the user substore.

#### Cross-chain NFT Transfer

Transactions executing this command have:

- `module = MODULE_NAME_NFT`
- `command = COMMAND_NAME_CROSS_CHAIN_TRANSFER`

##### Parameters Schema

The `params` property of a cross-chain NFT transfer transaction follows the schema `crossChainTransferParamsSchema`.

```java
crossChainTransferParamsSchema = {
    "type": "object",
    "required": [
        "nftID",
        "receivingChainID",
        "recipientAddress",
        "messageFee"
    ],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1,
        },
        "receivingChainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 2
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 3
        },
        "messageFee": {
            "dataType": "uint64",
            "fieldNumber": 4
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:

    chainID = nftID[:CHAIN_ID_LENGTH]

    if chainID not in [CHAIN_ID_ALIAS_NATIVE, receivingChainID]:
        raise Exception("NFT must be native to either to the mainchain or receiving chain.")
```

##### Execution

```python
def execute(trs: Transaction) -> None:

    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    nftID = trs.params.nftID
    receivingChainID = trs.params.receivingChainID
    recipientAddress = trs.params.recipientAddress
    messageFee = trs.params.messageFee

    transferCrossChain(
        senderAddress,
        receivingChainID,
        recipientAddress,
        nftID,
        messageFee,
        True
    )
```

Here, transferCrossChain function transfers ownership of NFTs across chains in the Lisk ecosystem.

### Executing Cross-chain Messages

#### Cross-chain NFT Transfer Message

Cross-chain messages executing this cross-chain command have:

- `module = MODULE_NAME_NFT`,
- `crossChainCommand = CROSS_CHAIN_COMMAND_NAME_TRANSFER`

##### Message Parameters Schema

The `params` property of cross-chain NFT transfers follows the `crossChainTransferMessageParamsSchema`.

```java
crossChainTransferMessageParamsSchema = {
    "type": "object",
    "required": [
        "nftID",
        "senderAddress"
        "recipientAddress",
        "attributes"
    ],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1,
        },
        "senderAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 3
        },
        "attributes": {
            "dataType": "bytes",
            "maxLength": MAX_BYTE_LENGTH_ATTRIBUTES,
            "fieldNumber": 4
        }
    }
}
```

##### Verification

```python
def verify(ccu: Transaction, ccm: CCM) -> None:

nftID = ccm.params.nftID
chainID = nftID[:CHAIN_ID_LENGTH]
sendingChainID = ccm.sendingChainID
senderAddress = ccm.params.senderAddress
ownChainID = Interoperability.getOwnChainAccount().ID

if chainID not in [ownChainID, sendingChainID]
    raise Exception("NFT is not native to either the sending chain or the receiving chain.")

if chainID == ownChainID and NFTStore(nftID).owner != senderAddress
    raise Exception("Sender is not the NFT owner.")

if chainID == sendingChainID and NFTStore(nftID) exists:
    raise Exception("NFT substore entry already exists.")

```

##### Execution

When executing a cross-chain NFT transfer message `ccm`, the logic below is followed.

```python
def execute(ccu: Transaction, ccm: CCM) -> None:

    nftID = ccm.params.nftID
    chainID = nftID[:CHAIN_ID_LENGTH]
    sendingChainID = ccm.sendingChainID
    senderAddress = ccm.params.senderAddress
    recipientAddress = ccm.params.recipientAddress
    receivedAttributes = ccm.params.attributes
    ownChainID = Interoperability.getOwnChainAccount().ID
    storedAttributes = NFTStore(nftID).attributes
    collection = nftID[5:8]

    if chainID == ownChainID:
        if ccm.status == CCM_STATUS_OK:
        newAttributes = getNewAttributes(collection, storedAttributes, receivedAttributes)
        newOwner = recipientAddress
        else:
        newAttributes = storedAttributes
        newOwner = senderAddress
    NFTStore(nftID).owner = newOwner
    NFTStore(nftID).attributes = newAttributes
    createUserEntry(newOwner, nftID)

    else: # chainID == sendingChainID
        if NFTSupported(nftID) == FALSE:
            if (ccm.fee >= MIN_RETURN_FEE * length(ccm)
                and ccm.status == CCM_STATUS_OK):
                Interoperability.error(ccm, CCM_STATUS_NFT_NOT_SUPPORTED)
            stop ccm execution
        if ccm.status == CCM_STATUS_OK:
            createNFTEntry(nftID, recipientAddress, receivedAttributes)
            createUserEntry(recipientAddress, nftID)
        else:
            createNFTEntry(nftID, senderAddress, receivedAttributes)
            createUserEntry(senderAddress, nftID)

```

### Events

#### createNFTEntry

This event has `name = EVENT_NAME_CREATE_NFT_ENTRY`, and is emitted when the createNFTEntry function is called.

##### Topics

- ``: bla bla.
- ``: bla bla.

##### Data

```java
createNFTEntryDataSchema = {
    "type": "object",
    "required": [
        "",
        "",
        ""
    ]
    "properties": {
    }
}
```

#### deleteNFTEntry

This event has `name = EVENT_NAME_DELETE_NFT_ENTRY`, and is emitted when the deleteNFTEntry function is called.

##### Topics

- ``: bla bla.
- ``: bla bla.

##### Data

```java
createNFTEntryDataSchema = {
    "type": "object",
    "required": [
        "",
        "",
        ""
    ]
    "properties": {
    }
}
```

#### createUserEntry

This event has `name = EVENT_NAME_CREATE_USER_ENTRY`, and is emitted when the createUserEntry function is called.

##### Topics

- ``: bla bla.
- ``: bla bla.

##### Data

```java
createNFTEntryDataSchema = {
    "type": "object",
    "required": [
        "",
        "",
        ""
    ]
    "properties": {
    }
}
```

#### deleteUserEntry

This event has `name = EVENT_NAME_DELETE_USER_ENTRY`, and is emitted when the deleteUserEntry function is called.

##### Topics

- ``: bla bla.
- ``: bla bla.

##### Data

```java
createNFTEntryDataSchema = {
    "type": "object",
    "required": [
        "",
        "",
        ""
    ]
    "properties": {
    }
}
```

### Internal Functions

#### createNFTEntry

```python
def createNFTEntry(
    nftID: NFTID,
    address: Address,
    givenAttributes: bytes
    ) -> None:

    create substore entry with
        substorePrefix = STORE_PREFIX_NFT
        key =  nftID
        value = encode(
            schema = NFTStoreSchema,
            object = {
            "owner": address,
            "lockingModule": NFT_NOT_LOCKED,
            "attributes": givenAttributes
            }
        )

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_CREATE_NFT_ENTRY,
        data = {
            "address": address,
            "nftID": nftID,
            "givenAttributes": givenAttributes,
            "result": RESULT_SUCCSESSFUL
        },
        topics = [TODO:]
    )
```

#### deleteNFTEntry

```python
def deleteNFTEntry(
    nftID: NFTID
    ) -> None:

    delete substore entry with
        substorePrefix = STORE_PREFIX_NFT
        key = nftID

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_DELETE_NFT_ENTRY,
        data = {
            TODO:
        },
        topics = [TODO:]
    )
```

#### createUserEntry

```python
def createUserEntry(
    address: Address,
    nftID: NFTID
    ) -> None:

    create substore entry with
        substorePrefix = SUBSTORE_PREFIX_USER
        key = address + nftID
        value = encode(
            schema = userStoreSchema,
            object = {
               "exists": True
            }
        )

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_CREATE_USER_ENTRY,
        data = {
            TODO:
        },
        topics = [TODO:]
    )
```

#### deleteUserEntry

```python
def deleteUserEntry(
    address: Address,
    nftID: NFTID
    ) -> None:

    delete substore entry with
        substorePrefix = STORE_PREFIX_USER
        key = address + nftID

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_DELETE_USER_ENTRY,
        data = {
            TODO:
        },
        topics = [TODO:]
    )
```

#### canonicalNFTID

```python
def canonicalNFTID(
    nftID: NFTID
    ) -> bytes:

    chainID = nftID[:CHAIN_ID_LENGTH]
    collectionBytes = nftID[5:8]
    indexBytes = nftID[9:16]

    if chainID == Interoperability.getOwnChainAccount().ID:
        return CHAIN_ID_ALIAS_NATIVE + collectionBytes + indexBytes
    else:
        return nftID
```

This function will return the input `nftID` in the case `interoperabiliby.getOwnChainAccount()` cannot be called.

### NFT Attributes

For all NFT collections, native chains must implement the function `getNewAttributes(collection, storedAttributes, receivedAttributes)` which is used whenever an NFT from this collection is received from another chain. The function `getNewAttributes` must always return a byte array of length at most `MAX_BYTE_LENGTH_ATTRIBUTES` bytes.

For all values of `collection` and `storedAttributes`, this function must be defined as `getNewAttributes(collection, storedAttributes, EMPTY_BYTES) = storedAttributes`.

This function's default behavior is to always overwriting the received attributes with the ones in the NFT substore:

```python
defaultGetNewAttributes(collection, storedAttributes, receivedAttributes):
    return storedAttributes
```

### Genesis Block Processing

#### Genesis Assets Schema

```java
genesisNFTStoreSchema = {
    "type": "object",
    "required": [
        "NFTSubstore",
        "collectionSubstore",
        "availableLocalIDSubstore",
        "terminatedEscrowSubstore"
    ],
    "properties": {
        "NFTSubstore": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": [
                    "NFTID",
                    "owner",
                    "lockingModuleID",
                    "attributes"
                ],
                "properties": {
                    "NFTID": {
                        "type": "object",
                        "fieldNumber": 1,
                        "required": ["chainID", "collection", "index"],
                        "properties": {
                            "chainID": {
                                "dataType": "uint32",
                                "fieldNumber": 1
                            },
                            "collection": {
                                "dataType": "uint32",
                                "fieldNumber": 2
                            },
                            "index": {
                                "dataType": "uint32",
                                "fieldNumber": 3
                            }
                        }
                    },
                    "owner": {
                        "dataType": "bytes",
                        "fieldNumber": 2
                    },
                    "lockingModuleID": {
                        "dataType": "string",
                        "fieldNumber": 3
                    },
                    "attributes": {
                        "dataType": "bytes",
                        "fieldNumber": 4
                    }
                }
            }
        },
        "collectionSubstore": {
            "type": "array",
            "fieldNumber": 2,
            "items": {
                "type": "object",
                "required": ["collection", "nextAvailableIndex"],
                "properties": {
                    "collection": {
                        "dataType": "uint32",
                        "fieldNumber": 1
                    },
                    "nextAvailableIndex": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "availableCollectionSubstore": {
            "dataType": "uint32",
            "fieldNumber": 3
        },
        "terminatedEscrowSubstore": {
            "type": "array",
            "fieldNumber": 4,
            "items": {
                "type": "uint32"
            }
        }
    }
}
```

#### Genesis State Initialization

During the genesis state initialization stage, the following steps are executed. If any step fails, the block is discarded and has no further effect.

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the NFT module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisNFTStoreSchema` schema, given above.

- Initial checks:

  - Across all elements of the `NFTSubstore` array, all values given for `NTFID` must be unique.
  - For all elements of the `NFTSubstore` array, values given for `owner` must have either length 20 (representing a user address) or 4 (representing a chain ID).
  - The `NFTSubstore` must be in lexicographical order of `owner`.
    - For a given `owner`, the entries must be in ascending order of `tokenID.chainID`.
    - For a given `owner` and `tokenID.chainID`, the entries must be in ascending order of `tokenID.collection`.
    - For a given `owner`, `tokenID.chainID` and `tokenID.collection` the entries must be in ascending order of `tokenID.index`.
  - For all elements of the `NFTSubstore` array, if the value of `owner` has length 4 (representing an escrowed NFT) then the corresponding `NFTID.chainID` must equal `CHAIN_ID_ALIAS_NATIVE`.
  - For all elements of the `NFTSubstore` array, if the value of `attributes` must have length less than or equal to `MAX_BYTE_LENGTH_ATTRIBUTES`.
  - Accross all element of the `collectionSubstore` array, all values given for `collection` must be unique.
  - The `collectionSubstore` array must be in ascending order of `collection`.
  - In the `terminatedEscrowSubstore` array, each element must be unique (appears at most once).
  - The `terminatedEscrowSubstore` array must be in ascending order.

- For each entry `NFTEntry` in `genesisBlockAssetObject.NFTSubstore`, create an entry in the NFT substore with:

  ```python
  storeKey = uint32be(NFTEntry.NFTID.chainID) || uint32be(NFTEntry.NFTID.collection) || uint64be(NFTEntry.NFTID.index)
  storeValue = {"owner": NFTEntry.owner,
                "lockingModuleID": NFTEntry.lockingModuleID,
                "attributes": NFTEntry.attributes
               } serialized using NFTStoreSchema.
  ```

  Further, if `NFTEntry.owner` has length 20, create an entry in the user substore with:

  ```python
  storeKey = NFTEntry.owner || uint32be(NFTEntry.NFTID.chainID) || uint32be(NFTEntry.NFTID.collection) || uint64be(NFTEntry.NFTID.index)
  storeValue = {"exists": True} serialized using userStoreSchema.
  ```

- For each entry `collectionEntry` in `genesisBlockAssetObject.collectionSubstore`, create an entry in the collection substore with:

  ```python
  storeKey = uint32be(collectionEntry.collection)
  storeValue = {"nextAvailableIndex": collectionEntry.nextAvailableIndex} serialized using collectionStoreSchema.
  ```

- Create an entry in the available collection substore with:

  ```python
  storeKey = EMPTY_BYTES
  storeValue = {"nextAvailableCollection": genesisBlockAssetObject.availableCollectionSubstore}
               serialized using availableCollectionStoreSchema.
  ```

- For each entry `terminatedChainID` in `genesisBlockAssetObject.terminatedEscrowSubstore`, create an entry in the terminated escrow substore with:
  ```python
  storeKey = uint32be(terminatedChainID)
  storeValue = {"escrowTerminated": True} serialized using terminatedEscrowStoreSchema.
  ```

Once the module store is initialized, its validity is attested asserting that the function below returns `True`.

```python
NFTStoreValid():
    existingIndex = {}
    for storeKey a store key in NFT substore:
        chainID = storeKey[0:4] # Part of the key corresponding to the chain ID of the NFT
        collection = storeKey[4:8] # Part of the key corresponding to the collection of the NFT
        index = storeKey[8:12] # Part of the key corresponding to the index of the NFT
        if chainID == CHAIN_ID_ALIAS_NATIVE:
            existingIndex[collection] = max{existingIndex[collection], index}

    # Check that all existing indices are smaller than the next available index for the collection
    for collection in existingIndex:
        if (collectionStore(collection) does not exist
            or collectionStore(collection).nextAvailableIndex <= existingIndex[collection]):
            return False

    # Check that the largest existing collection is smaller than the recorded available collection
    maxCollection = max key of the existingIndex dictionary, -1 if existingIndex is empty
    # Recall that nextAvailableCollection is used as the value of the available collection substore
    if nextAvailableCollection <= maxCollection:
        return False

    return True
```

### Protocol Logic for Other Modules

#### getAttributes

This function returns the attributes of an NFT.

```python
def getAttributes(
    nftID: NFTID
    ) -> bytes:

    nftID = canonicalNFTID(nftID)

    if NFTStore(nftID) does not exist:
        raise Exception("NFT substore entry does not exist.")
    else:
        return NFTStore(nftID).attributes
```

#### getLockingModule

This function returns the locking status of an NFT.

```python
def getLockingModule(
    nftID: NFTID
    ) -> string:

    nftID = canonicalNFTID(nftID)
    if NFTStore(nftID) does not exist:
        raise Exception("NFT substore entry does not exist.")
    else:
        return NFTStore(nftID).lockingModule
```

#### getNFTowner

This function returns the owner of an NFT.

```python
def getNFTowner(
    nftID: NFTID
    ) -> Address:

    nftID = canonicalNFTID(nftID)
    if NFTStore(nftID) does not exist:
        raise Exception("NFT substore entry does not exist.")
    else:
        return NFTStore(nftID).owner
```

#### getNextAvailableIndex

This function returns the max index of a collection.

```python
def getNextAvailableIndex(
    collection: uint32
    ) -> uin64:

    if collectionStore(collection) does not exist:
        raise Exception("Collection substore entry does not exist.")
    else:
        return collectionStore(collection).nextAvailableIndex
```

#### getNextAvailableCollection

This function returns the next available collection.

```python
def getNextAvailableCollection() -> uint32:
    return nextAvailableCollection
```

#### create

This function creates an NFT.

```python
def create(
    address: Address,
    collection: uint32,
    attributes: bytes
    ) -> None:

    if (length(attributes) > MAX_BYTE_LENGTH_ATTRIBUTES bytes):
        raise Exception("Atrributes exceeds the maximum byte length.")

    if collectionStore(collection) does not exist:
        raise Exception("Collection substore entry does not exist.")

    index = collectionStore(collection).nextAvailableIndex
    nftID = {"chainID": CHAIN_ID_ALIAS_NATIVE,
            "collection": collection,
            "index": index}
    createNFTEntry(nftID, address, attributes)
    createUserEntry(address, nftID)
    collectionStore(collection).nextAvailableIndex += 1

    TODO: EMITEVENT
```

#### destroy

This function destroys an NFT.

```python
def destroy(
    nftID: NFTID
    ) -> None:

    nftID = canonicalNFTID(nftID)
    if nftID.chainID != CHAIN_ID_ALIAS_NATIVE:
        raise Exception("NFT is not native.")

    if NFTStore(nftID) does not exist:
        raise Exception("NFT substore entry does not exist.")

    address = NFTStore(nftID).owner
    deleteNFTEntry(nftID)
    deleteUserEntry(address, nftID)

    TODO: EMITEVENT
```

#### initializeCollection

This function creates a new collection substore entry.

```python
def initializeCollection(
    collection: uint32
    ) -> None

    if collectionStore(collection) exists:
        raise Exception("Collection substore entry already exists.")
    else:
        create substore entry with
            substorePrefix = STORE_PREFIX_COLLECTION
            key = uint32be(collection)
            value = encode(
               schema = collectionStoreSchema,
                object = {
                   "nextAvailableIndex": 0
                }
            )

    if collection >= nextAvailableCollection:
        nextAvailableCollection = collection + 1
    return collection

    TODO: EMITEVENT
```

#### transfer

This function transfers ownership of NFTs within one chain.

```python
def transfer(
    senderAddress: Address,
    recipientAddress: Address,
    nftID: NFTID
) -> None:

    nftID = canonicalNFTID(nftID)

    if NFTStore(nftID).lockingModule != NFT_NOT_LOCKED
        raise Exception("NFT is locked.")

    if NFTStore(nftID).owner != senderAddress:
        raise Exception("Transfer not initiated by the NFT owner.")

    deleteUserEntry(senderAddress, nftID)
    createUserEntry(recipientAddress, nftID)
    NFTStore(nftID).owner = recipientAddress

    TODO: EMITEVENT
```

#### transferCrossChain

This function transfers ownership of NFTs across chains in the Lisk ecosystem.

```python
def transferCrossChain(
    senderAddress: Address,
    receivingChainID: ChainID,
    recipientAddress: Address,
    nftID: NFTID,
    messageFee: uint64,
    includeAttributes: bool
) -> None:

    nftID = canonicalNFTID(nftID)
    chainID = nftID[:CHAIN_ID_LENGTH]

    if chainID not in [CHAIN_ID_ALIAS_NATIVE, receivingChainID]:
        raise Exception("...")

    if NFTStore(nftID).lockingModuleID != NFT_NOT_LOCKED:
        raise Exception("NFT is locked.")

    if NFTStore(nftID).owner != senderAddress:
        raise Exception("Transfer not initiated by the NFT owner.")

    if includeAttributes == True:
        attributes = NFTStore(nftID).attributes
    else:
        attributes = EMPTY_BYTES

    messageParams = {
        "nftID": nftID,
        "senderAddress": senderAddress,
        "recipientAddress": recipientAddress,
        "attributes": attributes,
    }

    serializedParams = serialization of messageParams following
                      crossChainTransferMessageParams schema

    if Interoperability.send(senderAddress,
                             NFT_MODULE_ID,
                             CROSS_CHAIN_COMMAND_ID_TRANSFER,
                             receivingChainID,
                             messageFee,
                             CCM_STATUS_OK,
                             serializedParams):
        deleteUserEntry(address, nftID)
        if chainID == CHAIN_ID_ALIAS_NATIVE:
            NFTStore(nftID).owner = uint32be(receivingChainID)
            nftID.chainID = Interoperability.getOwnChainAccount().ID
        else:
            deleteNFTEntry(nftID)
    else:
        transferCrossChain fails

    TODO: EMITEVENT
```

#### lock

This function locks an NFT to a module.

```python
def lock(
    module: Module,
    nftID: NFTID
) -> None:

    nftID = canonicalNFTID(nftID)

    if NFTStore(nftID).lockingModule != NFT_NOT_LOCKED:
        raise Exception("NFT is already locked.")

    NFTStore(nftID).lockingModule = module

    emitPersistentEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_LOCK,
        data = {
            "module": module,
            "nftID": nftID,
            "result": RESULT_SUCCESSFUL
        },
        topics = [TODO:]
)
```

#### unlock

This function unlocks an NFT that was locked to a module.

```python
def unlock(
    module: Module,
    nftID: NFTID
) -> None:

    nftID = canonicalNFTID(nftID)

    if NFTStore(nftID).lockingModule != module:
        raise Exception("Trying to unlock NFT via the module that didn't lock it.")

    NFTStore(nftID).lockingModule = NFT_NOT_LOCKED

    emitPersistentEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_LOCK,
        data = {
            "module": module,
            "nftID": nftID,
            "result": RESULT_SUCCESSFUL
        },
        topics = [TODO:]
```

#### setAttributes

This function modifies the attributes of NFTs.

```python
def setAttributes(
    newAttributes: bytes,
    nftID: NFTID
) -> None:

    if NFTStore(nftID) does not exist:
        raise Exception("NFT substore entry does not exist.")

    if length(newAttributes) > MAX_BYTE_LENGTH_ATTRIBUTES:
        raise Exception("Atrributes exceeds the maximum byte length.")

    NFTStore(nftID).attributes = newAttributes

    TODO: EMITEVENT
```

#### recover

This function should only be called by the Interoperability module. It recovers NFTs escrowed to terminated chains.

```python
def recover(
    terminatedChainID: ChainID,
    module: Module,
    substorePrefix: bytes,
    storeKey: bytes,
    storeValue: bytes
) -> None:

    if (storePrefix != SUBSTORE_PREFIX_NFT:
        or length(storeKey) != STORE_KEY_LENGTH_NFT):
        recover fails

    chainID = first 4 bytes of storeKey deserialized as uint32be
    collection = bytes 5 to 8 of storeKey deserialized as uint32be
    index = last 8 bytes of storeKey deserialized as uint64be
    nftID = {"chainID": chainID, "collection": collection, "index": index}

    if (chainID != Interoperability.getOwnChainAccount().ID
        or NFTStore(nftID).owner != uint32be(terminatedChainID)
        or storeValue does not follow nftStoreSchema):
        recover fails
    nftValue = storeValue deserialized according to nftStoreSchema
    if length(nftValue.owner) != ADDRESS_LENGTH:
        recover fails

    NFTStore(nftID).owner = nftValue.owner
    storedAttributes = NFTStore(nftID).attributes
    newAttributes = nftValue.attributes
    NFTStore(nftID).attributes =  getNewAttributes(collection, storedAttributes, newAttributes)

    TODO: EMITEVENT
```

### Endpoints for Off-Chain Services

TBA

## Backwards Compatibility

Chains adding support for the NFT module specified in this document need to do so with a hard fork. This proposal does not imply a fork for the Lisk mainchain.

## Reference Implementation

TBA

[research:base-interoperability]: https://research.lisk.com/t/introduce-interoperability-module/290
[research:ccm]: https://research.lisk.com/t/cross-chain-messages/299
[research:ccu]: https://research.lisk.com/t/introduce-cross-chain-update-transactions/298
[research:chain-registration]: https://research.lisk.com/t/chain-registration/291
[research:sidechain-recovery]: https://research.lisk.com/t/sidechain-recovery-transactions/292
[research:token-module]: https://research.lisk.com/t/introduce-an-interoperable-token-module/295
