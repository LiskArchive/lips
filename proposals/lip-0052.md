```
LIP: 0052
Title: Introduce NFT module
Author: Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
        Miroslav Jerkovic <miroslav.jerkovic@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-nft-module/297
Status: Draft
Type: Standards Track
Created: 2021-05-22
Updated: 2022-03-22
Requires: 0045
```

## Abstract

The NFT (non-fungible token) module is used in the Lisk ecosystem for creating, destroying NFTs, and transferring them in the ecosystem. NFTs are uniquely identified assets. They can be transferred similarly to fungible tokens, but their unique identifiers can never be modified. In this module, NFTs also carry `attributes` that are used to store information specific to the NFT.

In this LIP, we specify the properties of the NFT module, along with their serialization and default values. Furthermore, we specify the state transitions logic defined within this module, i.e. the commands, the protocol logic injected during the block lifecycle, and the functions that can be called from other modules or off-chain services.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

NFTs are very common in the blockchain space and have uses in a wide range of applications. This can go from being the virtual representation of a real world object (art, fashion, event tickets ...) to purely virtual collectibles (crypto kitties, ...).

Therefore, providing a unified module to handle, transfer and modify NFTs is a necessity for the Lisk ecosystem. The module presented here contains all the basic features that are needed to incorporate NFTs in a blockchain ecosystem without being restrictive on the way NFTs will be used by custom modules and applications.

## Rationale

### Technical Glossary

- **Native chain:** with regards to an NFT, this is the chain where the NFT was created.
- **Native NFT:** with regards to a chain, all NFTs created on this chain.
- **Foreign chain:** with regards to an NFT, all chains other than the native chain.

### NFT Module Store

<img src="lip-0052/nft_module_store.png" width="40%">

_Figure 1: The NFT module store is divided into three substores. All NFTs held by users are stored sequentially in the user substore with keys given by the user address and the NFT ID._

#### NFT Store

The NFT store contains entries for all NFTs present on the native chain, as well as entries for all native NFTs that have been sent cross-chain to a foreign chain. Each entry contains three properties:

- The `owner` property can either be a 20 bytes long user address or a 4 bytes long chain ID. In the latter case, the NFT is a native NFT that has been sent cross-chain to a foreign chain and is escrowed.
- The `attributes` property can be used by custom applications to store information about the NFT, or modify interactions with the NFT.

#### User Substore

In the proposed solution, all NFTs associated with a given address are stored sequentially in the user substore part of the state. In this way, getting all NFTs of a given account can be done efficiently. This is in contrast to specifications (like [ERC 721](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md) without optional extensions) where the NFT owner is only stored as one of the NFTs properties. We think that this feature is useful in an account-based blockchain ecosystem and the user substore is designed accordingly. The `lockingModule` property stores the information regarding the locking status of the NFT. If the NFT is unlocked, this property will have the value `NFT_NOT_LOCKED`, whereas if the NFT is locked, this property will store the locking module name.

### NFT Identifier

To identify NFTs in the Lisk ecosystem, we introduce the `nftID`, a unique NFT identifier in the ecosystem. It is a 16 bytes long concatenation of the 4 bytes long `chainID`, the [chain ID][lip-0043] of the chain creating the NFT, the 4 bytes long `collectionID`, chosen when the NFT is created, and a 8 bytes long serialization of an `index` integer, automatically assigned at the NFT creation.

This allows chains to define multiple sets of NFTs, each identified by their respective collection. Each collection can then easily have its own attributes schema and custom logic. For example, an art NFT exchange could have a different collection per artist, index being then a unique integer associated with each art piece of this artist.

### Cross-chain NFT Transfer

To allow cross-chain transfers of NFTs, we define a specific command which makes use of the [Interoperability module][lip-0045] and creates a [cross-chain message][lip-0049] with the relevant information. When sending NFTs cross-chain, it is crucial that every native chain can correctly escrow its native NFTs sent to a foreign chain. In this way, a native NFT can never be created by a foreign chain and sent across the ecosystem. When receiving non-native NFTs on a chain, users can query this NFT's native chain to make sure that the NFT is properly escrowed.

#### Transfer To and From the Native Chain

These specifications only allow NFTs to be transferred from or to their native chain. In particular, this means that NFT created on chain A cannot be transferred directly from chain B to chain C. This is required to allow the native chain to maintain escrowed NFTs correctly.

### Attributes

Each NFT is stored with `attributes` property, a byte sequence that is not deserialized by the NFT module. Each custom module using an NFT collection should define schemas to serialize and deserialize the `attributes` property of NFTs of their collection.

When an NFT is sent to another chain, the `attributes` property of the NFT can be modified according to specifications set on the receiving chain. For this reason, custom modules specifying an NFT collection must also implement the behavior to adopt when an NFT is returned with a modified `attributes` property. This custom behavior will compare the returned attributes with the ones stored with the escrowed NFT. If the returned NFT has an empty attributes, the native chain will restore the attributes as stored, this can be used to save on cross-chain messages size when returning non-modified NFTs to their native chains.

### Protocol Logic for Other Modules

The NFT module provides the following functions to modify the NFT state. Any other modules should use those functions to modify the NFT state. The NFT state should never be modified from outside the module without using one of the provided functions as this could result in unexpected behavior and could cause an improper state transition.

#### create

This function is used to create a new NFT. The NFT will always be native to the chain creating it.

#### destroy

This function is used to destroy NFTs. The NFT will be removed from the NFT substore and cannot be retrieved. The use of this function is limited to destroying native NFTs.

#### transfer

This function is used to transfer ownership of NFTs within one chain.

#### transferCrossChain

This function is used to transfer ownership of NFTs across chains in the Lisk ecosystem.

#### lock

This function is used to lock an NFT to a module. A locked NFT cannot be transferred (within the chain or across chains). This can be useful, for example, when the NFT is used as a deposit for a service. Module is specified both when locking and unlocking the NFT, thus preventing NFTs being accidentally locked and unlocked by different modules.

#### unlock

This function is used to unlock an NFT that was locked to a module.

#### setAttributes

This function is used to modify the attributes of NFTs. Each custom module can define the rules surrounding modifying NFT attributes and should call this function. This function will be executed even if the NFT is locked.

#### recover

This function should only be called by the [Interoperability module][lip-0045] to trigger the recovery of NFTs escrowed to terminated chains.

## Specification

### Notation and Constants

The following constants are used throughout the document:

| Name                                | Type   | Value                   |
| ----------------------------------- | ------ | ----------------------- |
| **Interoperability Constants**      |        |                         |
| `MIN_RETURN_FEE`                    | uint64 | 1000                    |
| **NFT Module Constants**            |        |                         |
| `MODULE_NAME_NFT`                   | string | "nft"                   |
| `COMMAND_NAME_TRANSFER`             | string | "transfer"              |
| `COMMAND_NAME_CROSS_CHAIN_TRANSFER` | string | "transferCrossChain"    |
| `CROSS_CHAIN_COMMAND_NAME_TRANSFER` | string | TBD                     |
| `NFT_NOT_LOCKED`                    | string | `MODULE_NAME_NFT`       |
| `MAX_BYTE_LENGTH_ATTRIBUTES`        | uint32 | 9 \* 1024               |
| `CCM_STATUS_OK`                     | uint32 | 0                       |
| `CCM_STATUS_NFT_NOT_SUPPORTED`      | uint32 | 64                      |
| `CCM_STATUS_NFT_PROTOCOL_VIOLATION` | uint32 | 65                      |
| **Store Constants**                 |        |                         |
| `SUBSTORE_PREFIX_NFT`               | bytes  | 0x00 00                 |
| `SUBSTORE_PREFIX_USER`              | bytes  | 0x80 00                 |
| `SUBSTORE_PREFIX_TERMINATED_ESCROW` | bytes  | TBD                     |
| `SUBSTORE_KEY_LENGTH_NFT`           | uint32 | 16                      |
| **General Constants**               |        |                         |
| `OWN_CHAIN_ID`                      | bytes  | `chainID` of the chain. |
| `ADDRESS_LENGTH`                    | uint32 | 20                      |
| `MIN_MODULE_NAME_LENGTH`            | uint32 | 1                       |
| `MAX_MODULE_NAME_LENGTH`            | uint32 | 32                      |
| `NFT_ID_LENGTH`                     | uint32 | 16                      |
| `CHAIN_ID_LENGTH`                   | uint32 | 4                       |
| `EMPTY_BYTES`                       | bytes  | ""                      |

### Event Names and Results

| Name                              | Type   | Value                | Description                                                                                |
| --------------------------------- | ------ | -------------------- | ------------------------------------------------------------------------------------------ |
| **Names**                         |        |                      |                                                                                            |
| `EVENT_NAME_TRANSFER`             | string | "transfer"           | Name of the events emitted during NFT transfer.                                            |
| `EVENT_NAME_TRANSFER_CROSS_CHAIN` | string | "transferCrossChain" | Name of the events emitted during cross-chain NFT transfer.                                |
| `EVENT_NAME_CCM_TRANSFER`         | string | "ccmTransfer"        | Name of the events emitted during execution of cross-chain NFT transfer messages.          |
| `EVENT_NAME_CREATE`               | string | "create"             | Name of the events emitted during calls to the [create](#create-2) function.               |
| `EVENT_NAME_DESTROY`              | string | "destroy"            | Name of the events emitted during calls to the [destroy](#destroy-2) function.             |
| `EVENT_NAME_LOCK`                 | string | "lock"               | Name of the events emitted during calls to the [lock](#lock-2) function.                   |
| `EVENT_NAME_UNLOCK`               | string | "unlock"             | Name of the events emitted during calls to the [unlock](#unlock-2) function.               |
| `EVENT_NAME_SET_ATTRIBUTES`       | string | "setAttributes"      | Name of the events emitted during calls to the [setAttributes](#setattributes-2) function. |
| `EVENT_NAME_RECOVER`              | string | "recover"            | Name of the events emitted during calls to the [recover](#recover-2) function.             |
| **Result codes**                  |        |                      |                                                                                            |
| `RESULT_SUCCESSFUL`               | uint32 | 0                    | Successful result code for events.                                                         |
| `RESULT_ATTRIBUTES_TOO_LONG`      | uint32 | 1                    | Used when `attributes` input is too long.                                                  |
| `RESULT_NFT_NOT_NATIVE`           | uint32 | 3                    | Used when NFT is not native to either the sending chain or the receiving chain.            |
| `RESULT_NFT_DOES_NOT_EXIST`       | uint32 | 4                    | Used when NFT substore entry does not exist.                                               |
| `RESULT_NFT_LOCKED`               | uint32 | 6                    | Used when transfer fails due to NFT being locked.                                          |
| `RESULT_INITIATED_BY_NONOWNER`    | uint32 | 7                    | Used when transfer fails due to not being initiated by the NFT owner.                      |
| `RESULT_NFT_ALREADY_LOCKED`       | uint32 | 8                    | Used when locking fails due to NFT being already locked.                                   |
| `RESULT_UNAUTHORIZED_UNLOCK`      | uint32 | 9                    | Used when NFT unlock fails due to being requested by a module that did not lock it.        |
| `RESULT_INVALID_ARGUMENTS`        | uint32 | 10                   | Used when the recover function fails because of invalid inputs.                            |

### Type Definitions

| Name          | Type   | Validation                                                                                                                                                                                                                                  | Description                                          |
| ------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| `Address`     | bytes  | Must be of length `ADDRESS_LENGTH`.                                                                                                                                                                                                         | Address of an account.                               |
| `Module`      | string | Must be of length at least `MIN_MODULE_NAME_LENGTH` and at most `MAX_MODULE_NAME_LENGTH`.                                                                                                                                                   | Used for identifying modules.                        |
| `NFTID`       | bytes  | Must be of length `NFT_ID_LENGTH`.                                                                                                                                                                                                          | Used for NFT identifiers.                            |
| `ChainID`     | bytes  | Must be of length `CHAIN_ID_LENGTH`.                                                                                                                                                                                                        | Used for chain identifiers.                          |
| `Transaction` | object | Must follow the `transactionSchema` schema defined in the [LIP 0068][lip-0068] with the only difference that `params` property is not serialized and contains the values of parameters of `paramsSchema` for the corresponding transaction. | An object representing a non-serialized transaction. |
| `CCM`         | object | Must follow the `crossChainMessageSchema` schema defined in [LIP 0049][lip-0049#ccmschema].                                                                                                                                                 | The type of cross-chain messages.                    |

#### uint64be Function

The function `uint64be(x)` returns the big endian uint64 serialization of an integer `x`, with `0 <= x < 2^64`. This serialization is always 8 bytes long.

#### length Function

In this LIP, `length(byteSequence)` returns the length in bytes of `byteSequence`.

#### Logic from Other Modules

Calling a function `fct` from the [Interoperability module][lip-0045] is represented by `Interoperability.fct(required inputs)`.

### NFT Identification

All NFTs in the ecosystem are identified by using the following three values:

- `chainID`, always the chain ID of the chain that created the NFT,
- `collectionID`, a 4-bytes array specified at NFT creation,
- `index`, assigned at NFT creation to the next available index in the collection.

In this LIP, the NFT identifier `nftID` is a 16 bytes long concatenation of the `chainID` of the NFT native chain, `collectionID` and the serialization of `index`: `nftID = chainID + collectionID + uint64be(index)`. This is for example used in all input formats for the module's exposed logics. This allows the exposed logic interfaces to be simple and uniform.

#### Supported NFTs

The NFT module contains a function used when receiving cross-chain NFT transfers to assert the support for non-native NFTs. It should return a boolean, depending on the configuration of the NFT module. For the rest of this LIP, this function is written `isNFTSupported(nftID)`.

### NFT Module Store

The store keys and schemas for value serialization of the NFT module store are set as follows:

#### NFT Substore

- The substore prefix is set to `SUBSTORE_PREFIX_NFT`.
- Each store key is an NFT ID: `nftID`.
- Each store value is the serialization of an object following `NFTStoreSchema`.

```java
NFTStoreSchema = {
    "type": "object",
    "required": [
        "owner",
        "attributes"
    ],
    "properties": {
        "owner": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "attributes": {
            "dataType": "bytes",
            "maxLength": MAX_BYTE_LENGTH_ATTRIBUTES,
            "fieldNumber": 2
        }
    }
}
```

#### User Substore

- The substore prefix is set to `SUBSTORE_PREFIX_USER`.
- Each store key is a concatenation of an address and a NFT ID: `address` + `nftID`.
- Each store value is the serialization of an object following `userStoreSchema`.

```java
userStoreSchema = {
    "type": "object",
    "required": ["lockingModule"],
    "properties": {
        "lockingModule": {
            "dataType": "string",
            "minLength": MIN_MODULE_NAME_LENGTH,
            "maxLength": MAX_MODULE_NAME_LENGTH,
            "pattern": "^[a-zA-Z0-9]*$]",
            "fieldNumber": 1
        },
    }
}
```

#### Terminated Escrow Substore

- The substore prefix is set to `SUBSTORE_PREFIX_TERMINATED_ESCROW`.
- Each store key is the `terminatedChainID`.
- Each store value is the serialization of an object following `terminatedEscrowStoreSchema`.

```java
terminatedEscrowStoreSchema = {
    "type": "object",
    "required": ["terminatedEscrow"],
    "properties": {
        "terminatedEscrow": {
            "dataType": "boolean",
            "fieldNumber": 1
        }
    }
}
```

#### Store Notation

For the rest of this proposal:

- Let `NFTStore(nftID)` be the NFT substore entry with store key `nftID`.
- Let `userStore(address, nftID)` be the user substore entry with store key `address` + `nftID`.
- Let `terminatedEscrowStore(terminatedChainID)` be the terminated escrow substore entry with store key `terminatedChainID`.

### Commands

The module provides the following commands to modify the NFT store.

#### NFT Transfer

Transactions executing this command have:

- `module = MODULE_NAME_NFT`
- `command = COMMAND_NAME_TRANSFER`

##### Parameters Schema

The `params` property of an NFT transfer transaction follows the schema `NFTTransferParamsSchema`.

```java
NFTTransferParamsSchema = {
    "type": "object",
    "required": [
        "nftID",
        "recipientAddress"
    ],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1,
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:

    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    nftID = trs.params.nftID
    recipientAddress = trs.params.recipientAddress

    if NFTStore(nftID).owner != senderAddress:
        raise Exception("Sender is not the NFT owner.")

    if userStore(senderAddress, nftID).lockingModule != NFT_NOT_LOCKED:
        raise Exception("NFT is locked.")
```

##### Execution

```python
def execute(trs: Transaction) -> None:

    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    nftID = trs.params.nftID
    recipientAddress = trs.params.recipientAddress

    transfer(senderAddress, recipientAddress, nftID)
```

Here, [transfer](#transfer-2) is the internal function that tranfers the ownership of the NFT within one chain.

#### Cross-chain NFT Transfer

Transactions executing this command have:

- `module = MODULE_NAME_NFT`
- `command = COMMAND_NAME_CROSS_CHAIN_TRANSFER`

##### Parameters Schema

The `params` property of a cross-chain NFT transfer transaction follows the schema `crossChainTransferParamsSchema`.

```java
crossChainTransferParamsSchema = {
    "type": "object",
    "required": [
        "nftID",
        "receivingChainID",
        "recipientAddress",
        "messageFee"
    ],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1,
        },
        "receivingChainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 2
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 3
        },
        "messageFee": {
            "dataType": "uint64",
            "fieldNumber": 4
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:

    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    nftID = trs.params.nftID
    receivingChainID = trs.params.receivingChainID

    if NFTStore(nftID).owner != senderAddress:
        raise Exception("Sender is not the NFT owner.")

    if userStore(senderAddress, nftID).lockingModule != NFT_NOT_LOCKED:
        raise Exception("NFT is locked.")

    if chainID not in [OWN_CHAIN_ID, receivingChainID]:
        raise Exception("NFT must be native to either the sending or the receiving chain.")
```

##### Execution

```python
def execute(trs: Transaction) -> None:

    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    nftID = trs.params.nftID
    receivingChainID = trs.params.receivingChainID
    recipientAddress = trs.params.recipientAddress
    messageFee = trs.params.messageFee

    transferCrossChain(senderAddress, receivingChainID, recipientAddress, nftID, messageFee, True)
```

Here, [transferCrossChain](#transfercrosschain-2) function transfers ownership of NFTs across chains in the Lisk ecosystem.

### Executing Cross-chain Messages

#### Cross-chain NFT Transfer Message

Cross-chain messages executing this cross-chain command have:

- `module = MODULE_NAME_NFT`,
- `crossChainCommand = CROSS_CHAIN_COMMAND_NAME_TRANSFER`

##### Message Parameters Schema

The `params` property of cross-chain NFT transfers follows the `crossChainTransferMessageParamsSchema`.

```java
crossChainTransferMessageParamsSchema = {
    "type": "object",
    "required": [
        "nftID",
        "senderAddress"
        "recipientAddress",
        "attributes"
    ],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1,
        },
        "senderAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 3
        },
        "attributes": {
            "dataType": "bytes",
            "maxLength": MAX_BYTE_LENGTH_ATTRIBUTES,
            "fieldNumber": 4
        }
    }
}
```

##### Verification

```python
def verify(ccu: Transaction, ccm: CCM) -> None:

nftID = ccm.params.nftID
chainID = nftID[:CHAIN_ID_LENGTH]
sendingChainID = ccm.sendingChainID
senderAddress = ccm.params.senderAddress
ownChainID = Interoperability.getOwnChainAccount().ID

if chainID not in [ownChainID, sendingChainID]
    raise Exception("NFT is not native to either the sending chain or the receiving chain.")

if chainID == ownChainID and NFTStore(nftID).owner != ccm.sendingChain
    raise Exception("Sender is not the NFT owner.")

if chainID == sendingChainID and NFTStore(nftID) exists:
    raise Exception("NFT substore entry already exists.")
```

##### Execution

When executing a cross-chain NFT transfer message `ccm`, the logic below is followed.

```python
def execute(ccu: Transaction, ccm: CCM) -> None:

    nftID = ccm.params.nftID
    chainID = nftID[:CHAIN_ID_LENGTH]
    sendingChainID = ccm.sendingChainID
    senderAddress = ccm.params.senderAddress
    recipientAddress = ccm.params.recipientAddress
    receivedAttributes = ccm.params.attributes
    ownChainID = Interoperability.getOwnChainAccount().ID
    storedAttributes = NFTStore(nftID).attributes
    collection = nftID[5:8]

    if chainID == ownChainID:
        if ccm.status == CCM_STATUS_OK:
            newAttributes = getNewAttributes(collection, storedAttributes, receivedAttributes)
            newOwner = recipientAddress
        else:
            newAttributes = storedAttributes
            newOwner = senderAddress

        NFTStore(nftID).owner = newOwner
        NFTStore(nftID).attributes = newAttributes
        createUserEntry(newOwner, nftID)

    else: # chainID == sendingChainID
        if isNFTSupported(nftID) == FALSE:
            if (ccm.fee >= MIN_RETURN_FEE * length(ccm)
                and ccm.status == CCM_STATUS_OK):
                Interoperability.error(ccm, CCM_STATUS_NFT_NOT_SUPPORTED)
            stop ccm execution
        if ccm.status == CCM_STATUS_OK:
            createNFTEntry(nftID, recipientAddress, receivedAttributes)
            createUserEntry(recipientAddress, nftID)
        else:
            createNFTEntry(nftID, senderAddress, receivedAttributes)
            createUserEntry(senderAddress, nftID)

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_CCM_TRANSFER,
        data = {
            "senderAddress": senderAddress,
            "recipientAddress": recipientAddress,
            "nftID": nftID,
            "receivingChainID": receivingChainID,
            "result": RESULT_SUCCESSFUL
        },
        topics=[senderAddress, recipientAddress]
```

### Events

#### transfer

This event has `name = EVENT_NAME_TRANSFER`, and is emitted when the transfer function is called.

##### Topics

- `senderAddress`: the address of the sending account.
- `recipientAddress`: the address of the receiving account.

##### Data

```java
transferEventDataSchema = {
    "type": "object",
    "required": ["senderAddress", "recipientAddress", "nftID", "result"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        },
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 3
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 4
        },
    }
}
```

#### transferCrossChain

This event has `name = EVENT_NAME_TRANSFER_CROSS_CHAIN`, and is emitted when the transferCrossChain function is called.

##### Topics

- `senderAddress`: the address of the sending account.
- `recipientAddress`: the address of the receiving account.
- `receivingChainID`: the chain ID of the receiving chain.

##### Data

```java
transferCrossChainEventDataSchema = {
    "type": "object",
    "required": ["senderAddress", "recipientAddress", "nftID", "receivingChainID", "result"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        },
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 3
        },
        "receivingChainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 4
        },
        "result": {
            "dataType": "bytes",
            "length": "uint32",
            "fieldNumber": 5
        }
    }
}
```

#### ccmTransfer

This event has `name = EVENT_NAME_CCM_TRANSFER`, and is emitted during the execution of cross-chain NFT transfer messages.

##### Topics

- `senderAddress`: the address of the sending account.
- `recipientAddress`: the address of the receiving account.
- `receivingChainID`: the chain ID of the receiving chain.

##### Data

```java
ccmTransferEventDataSchema = {
    "type": "object",
    "required": ["senderAddress", "recipientAddress", "nftID", "receivingChainID", "result"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        },
        "recipientAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        },
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 3
        },
        "receivingChainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 4
        },
        "result": {
            "dataType": "bytes",
            "length": "uint32",
            "fieldNumber": 5
        }
    }
}
```

#### create

This event has `name = EVENT_NAME_CREATE`, and is emitted when the create function is called.

##### Topics

- `address`: the address of the account that created the NFT.
- `nftID`: ID of the created NFT.

##### Data

```java
createEventDataSchema = {
    "type": "object",
    "required": ["nftID", "address", "collection", "attributes", "result"],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1
        },
        "address": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        },
        "collection": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "attributes": {
            "dataType": "bytes",
            "maxLength": MAX_BYTE_LENGTH_ATTRIBUTES,
            "fieldNumber": 4
        },
        "result": {
            "dataType": "uint32"
            "fieldNumber": 5
        }
    }
}
```

#### destroy

This event has `name = EVENT_NAME_DESTROY`, and is emitted when the destroy function is called.

##### Topics

- `address`: the address of the NFT owner.
- `nftID`: ID of the destroyed NFT.

##### Data

```java
destroyEventDataSchema = {
    "type": "object",
    "required": ["nftID", "result"],
    "properties": {
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 1
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 2
        }
    }
}
```

#### lock

This event has `name = EVENT_NAME_LOCK`, and is emitted when the lock function is called.

##### Topics

There are no topics for this event.

##### Data

```java
lockEventDataSchema = {
    "type": "object",
    "required": ["module", "nftID", "result"],
    "properties": {
        "module": {
            "dataType": "string",
            "minLength": MIN_MODULE_NAME_LENGTH,
            "maxLength": MAX_MODULE_NAME_LENGTH,
            "fieldNumber": 1
        },
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 2
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 3
        }
    }
}
```

#### unlock

This event has `name = EVENT_NAME_UNLOCK`, and is emitted when the unlock function is called.

##### Topics

There are no topics for this event.

##### Data

```java
unlockEventDataSchema = {
    "type": "object",
    "required": ["module", "nftID", "result"],
    "properties": {
        "module": {
            "dataType": "string",
            "minLength": MIN_MODULE_NAME_LENGTH,
            "maxLength": MAX_MODULE_NAME_LENGTH,
            "fieldNumber": 1
        },
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 2
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 3
        }
    }
}
```

#### setAttributes

This event has `name = EVENT_NAME_SET_ATTRIBUTES`, and is emitted when the setAttributes function is called.

##### Topics

There are no topics for this event.

##### Data

```java
setAttributesEventDataSchema = {
    "type": "object",
    "required": ["attributes", "nftID", "result"],
    "properties": {
        "attributes": {
            "dataType": "bytes",
            "maxLength": MAX_BYTE_LENGTH_ATTRIBUTES,
            "fieldNumber": 1
        },
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 2
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 3
        }
    }
}
```

#### recover

This event has `name = EVENT_NAME_RECOVER`, and is emitted when the recover function is called.

##### Topics

There are no topics for this event.

##### Data

```java
recoverEventDataSchema = {
    "type": "object",
    "required": ["terminatedChainID", "nftID", "result"],
    "properties": {
        "terminatedChainID": {
            "dataType": "bytes",
            "maxLength": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "nftID": {
            "dataType": "bytes",
            "length": NFT_ID_LENGTH,
            "fieldNumber": 2
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 3
        }
    }
}
```

### Internal Functions

#### createNFTEntry

```python
def createNFTEntry(nftID: NFTID, address: Address, attributes: bytes) -> None:

    create substore entry with
        substorePrefix = SUBSTORE_PREFIX_NFT
        key =  nftID
        value = encode(
            schema = NFTStoreSchema,
            object = {
                "owner": address,
                "attributes": attributes
            }
        )
```

#### deleteNFTEntry

```python
def deleteNFTEntry(nftID: NFTID) -> None:

    delete substore entry with
        substorePrefix = SUBSTORE_PREFIX_NFT
        key = nftID
```

#### createUserEntry

```python
def createUserEntry(address: Address, nftID: NFTID) -> None:

    create substore entry with
        substorePrefix = SUBSTORE_PREFIX_USER
        key = address + nftID
        value = encode(
            schema = userStoreSchema,
            object = {
               "lockingModule": NFT_NOT_LOCKED
            }
        )
```

#### deleteUserEntry

```python
def deleteUserEntry(address: Address, nftID: NFTID) -> None:

    delete substore entry with
        substorePrefix = STORE_PREFIX_USER
        key = address + nftID
```

#### canonicalNFTID

```python
def canonicalNFTID(nftID: NFTID) -> bytes:

    chainID = nftID[:CHAIN_ID_LENGTH]
    collectionID = nftID[4:8]
    indexBytes = nftID[8:16]

    return nftID
```

This function will return the input `nftID` in the case `interoperabiliby.getOwnChainAccount()` cannot be called.

### NFT Attributes

For all NFT collections, native chains must implement the function `getNewAttributes(collection, storedAttributes, receivedAttributes)` which is used whenever an NFT from this collection is received from another chain. The function `getNewAttributes` must always return a byte array of length at most `MAX_BYTE_LENGTH_ATTRIBUTES` bytes.

For all values of `collectionID` and `storedAttributes`, this function must be defined as `getNewAttributes(collection, storedAttributes, EMPTY_BYTES) = storedAttributes`.

This function's default behavior is to always overwrite the received attributes with the ones in the NFT substore:

```python
def defaultGetNewAttributes(collection: uint32, storedAttributes: bytes, receivedAttributes: bytes) -> bytes:

    return storedAttributes
```

### Protocol Logic for Other Modules

#### getAttributes

This function returns the `attributes` of an NFT.

```python
def getAttributes(
    nftID: NFTID
    ) -> bytes:

    nftID = canonicalNFTID(nftID)
    if NFTStore(nftID) does not exist:
        raise Exception("NFT substore entry does not exist.")

    return NFTStore(nftID).attributes
```

#### getLockingModule

This function returns the locking status of an NFT.

```python
def getLockingModule(
    address: Address,
    nftID: NFTID
    ) -> string:

    nftID = canonicalNFTID(nftID)
    if userStore(address, nftID) does not exist:
        raise Exception("User substore entry does not exist.")

    return userStore(address, nftID).lockingModule
```

#### getNFTowner

This function returns the owner of an NFT.

```python
def getNFTowner(
    nftID: NFTID
    ) -> Address:

    nftID = canonicalNFTID(nftID)
    if NFTStore(nftID) does not exist:
        raise Exception("NFT substore entry does not exist.")

    return NFTStore(nftID).owner
```

#### create

This function creates an NFT.

```python
def create(
    address: Address,
    collectionID: bytes,
    attributes: bytes
    ) -> None:

    count all NFT store entries with key OWN_CHAIN_ID and collectionID: if none, then index = 0, otherwise index = count + 1
    nftID = OWN_CHAIN_ID + collectionID + uint64be(index)

    if length(attributes) > MAX_BYTE_LENGTH_ATTRIBUTES bytes:
        emitFailedCreateEvent(nftID, address, collection, attributes, RESULT_ATTRIBUTES_TOO_LONG)
        raise Exception("Atrributes exceed the maximum byte length.")

    createNFTEntry(nftID, address, attributes)
    createUserEntry(address, nftID)

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_CREATE,
        data = {
            "nftID": nftID,
            "address": address,
            "collection": collection,
            "attributes": attributes,
            "result": RESULT_SUCCSESSFUL
        },
        topics = [address, nftID]
    )

    def emitFailedCreateEvent(
        nftID: nftID,
        address: Address,
        collection: uint32,
        attributes: bytes,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_CREATE,
            data = {
                "nftID": nftID,
                "address": address,
                "collection": collection,
                "attributes": attributes,
                "result": result
            },
            topics = [address, nftID]
        )
```

#### destroy

This function destroys an NFT.

```python
def destroy(
    nftID: NFTID
    ) -> None:

    nftID = canonicalNFTID(nftID)
    if nftID.chainID != OWN_CHAIN_ID:
        emitFailedDestroyEvent(nftID, RESULT_NFT_NOT_NATIVE)
        raise Exception("NFT is not native.")
    if NFTStore(nftID) does not exist:
        emitFailedDestroyEvent(nftID, RESULT_NFT_DOES_NOT_EXIST)
        raise Exception("NFT substore entry does not exist.")

    address = NFTStore(nftID).owner
    deleteNFTEntry(nftID)
    deleteUserEntry(address, nftID)

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_DESTROY,
        data = {
            "nftID": nftID,
            "result": RESULT_SUCCSESSFUL
        },
        topics = [address, nftID]
    )

    def emitFailedDestroyEvent(
        nftID: NFTID,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_DESTROY,
            data = {
                "nftID": nftID,
                "result": result
            },
            topics = [address, nftID]
        )
```

#### transfer

This function transfers ownership of NFTs within one chain.

```python
def transfer(
    senderAddress: Address,
    recipientAddress: Address,
    nftID: NFTID
) -> None:

    nftID = canonicalNFTID(nftID)

    if NFTStore(nftID).lockingModule != NFT_NOT_LOCKED
        emitFailedTransferEvent(senderAddress, recipientAddress, nftID, RESULT_NFT_LOCKED)
        raise Exception("NFT is locked.")

    if NFTStore(nftID).owner != senderAddress:
        emitFailedTransferEvent(senderAddress, recipientAddress, nftID, RESULT_INITIATED_BY_NONOWNER)
        raise Exception("Transfer not initiated by the NFT owner.")

    deleteUserEntry(senderAddress, nftID)
    createUserEntry(recipientAddress, nftID)
    NFTStore(nftID).owner = recipientAddress

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_TRANSFER,
        data = {
            "senderAddress": senderAddress,
            "recipientAddress": recipientAddress,
            "nftID": nftID,
            "result": RESULT_SUCCESSFUL
        },
        topics=[senderAddress, recipientAddress]
    )

    def emitFailedTransferEvent(
        senderAddress: Address,
        recipientAddress: Address,
        nftID: NFTID,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_TRANSFER,
            data = {
                "senderAddress": senderAddress,
                "recipientAddress": recipientAddress,
                "nftID": nftID,
                "result": result
            },
            topics = [senderAddress, recipientAddress]
        )
```

#### transferCrossChain

This function transfers ownership of NFTs across chains in the Lisk ecosystem.

```python
def transferCrossChain(
    senderAddress: Address,
    receivingChainID: ChainID,
    recipientAddress: Address,
    nftID: NFTID,
    messageFee: uint64,
    includeAttributes: bool
) -> None:

    nftID = canonicalNFTID(nftID)
    chainID = nftID[:CHAIN_ID_LENGTH]

    if chainID not in [OWN_CHAIN_ID, receivingChainID]:
        emitFailedTransferCrossChainEvent(senderAddress, receivingChainID, recipientAddress, nftID, messageFee, includeAttributes, RESULT_NFT_NOT_NATIVE)
        raise Exception("NFT must be native either to the sending chain or the receiving chain.")

    if NFTStore(nftID).lockingModule != NFT_NOT_LOCKED:
        emitFailedTransferCrossChainEvent(senderAddress, receivingChainID, recipientAddress, nftID, messageFee, includeAttributes, RESULT_NFT_LOCKED)
        raise Exception("NFT is locked.")

    if NFTStore(nftID).owner != senderAddress:
        emitFailedTransferCrossChainEvent(senderAddress, receivingChainID, recipientAddress, nftID, messageFee, includeAttributes, RESULT_INITIATED_BY_NONOWNER)
        raise Exception("Transfer not initiated by the NFT owner.")

    if includeAttributes == True:
        attributes = NFTStore(nftID).attributes
    else:
        attributes = EMPTY_BYTES

    messageParams = {
        "nftID": nftID,
        "senderAddress": senderAddress,
        "recipientAddress": recipientAddress,
        "attributes": attributes,
    }

    serializedParams = serialization of messageParams following
                      crossChainTransferMessageParams schema

    if Interoperability.send(senderAddress,
                             NFT_MODULE_NAME,
                             CROSS_CHAIN_COMMAND_NAME_TRANSFER,
                             receivingChainID,
                             messageFee,
                             CCM_STATUS_OK,
                             serializedParams):
        deleteUserEntry(address, nftID)
        if chainID == OWN_CHAIN_ID:
            NFTStore(nftID).owner = receivingChainID
            chainID = Interoperability.getOwnChainAccount().ID
            nftID = chainID + nftID[5:16]
        else:
            deleteNFTEntry(nftID)
    else:
        transferCrossChain fails

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_TRANSFER_CROSS_CHAIN,
        data = {
            "senderAddress": senderAddress,
            "recipientAddress": recipientAddress,
            "nftID": nftID,
            "receivingChainID": receivingChainID,
            "result": RESULT_SUCCESSFUL
        },
        topics = [senderAddress, recipientAddress, receivingChainID]
    )

    def emitFailedTransferCrossChainEvent(
        senderAddress: Address,
        receivingChainID: ChainID,
        recipientAddress: Address,
        nftID: NFTID,
        messageFee: uint64,
        includeAttributes: bool,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_TRANSFER_CROSS_CHAIN,
            data = {
                "senderAddress": senderAddress,
                "recipientAddress": recipientAddress,
                "nftID": nftID,
                "receivingChainID": receivingChainID,
                "result": result
            },
            topics = [senderAddress, recipientAddress, receivingChainID]
        )
```

#### lock

This function locks an NFT to a module.

```python
def lock(
    module: Module,
    nftID: NFTID
) -> None:

    nftID = canonicalNFTID(nftID)

    if NFTStore(nftID).lockingModule != NFT_NOT_LOCKED:
        emitFailedLockEvent(module, nftID, RESULT_NFT_ALREADY_LOCKED)
        raise Exception("NFT is already locked.")

    NFTStore(nftID).lockingModule = module

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_LOCK,
        data = {
            "module": module,
            "nftID": nftID,
            "result": RESULT_SUCCESSFUL
        },
        topics = []
    )

    def emitFailedLockEvent(
        module: Module,
        nftID: NFTID,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_LOCK,
            data = {
                "module": module,
                "nftID": nftID,
                "result": result
            },
            topics = []
        )

```

#### unlock

This function unlocks an NFT that was locked to a module.

```python
def unlock(
    module: Module,
    nftID: NFTID
) -> None:

    nftID = canonicalNFTID(nftID)

    if NFTStore(nftID).lockingModule != module:
        emitFailedUnlockEvent(module, nftID, RESULT_UNAUTHORIZED_UNLOCK)
        raise Exception("Unlocking NFT via module that didn't lock it.")

    NFTStore(nftID).lockingModule = NFT_NOT_LOCKED

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_UNLOCK,
        data = {
            "module": module,
            "nftID": nftID,
            "result": RESULT_SUCCESSFUL
        },
        topics = []
    )

    def emitFailedUnlockEvent(
        module: Module,
        nftID: NFTID,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_UNLOCK,
            data = {
                "module": module,
                "nftID": nftID,
                "result": result
            },
            topics = []
        )
```

#### setAttributes

This function modifies the `attributes` of NFTs.

```python
def setAttributes(
    attributes: bytes,
    nftID: NFTID
) -> None:

    if NFTStore(nftID) does not exist:
        emitFailedSetAttributesEvent(attributes, nftID, RESULT_NFT_DOES_NOT_EXIST)
        raise Exception("NFT substore entry does not exist.")

    if length(attributes) > MAX_BYTE_LENGTH_ATTRIBUTES:
        emitFailedSetAttributesEvent(attributes, nftID, RESULT_ATTRIBUTES_TOO_LONG)
        raise Exception("Atrributes exceeds the maximum byte length.")

    NFTStore(nftID).attributes = attributes

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_SET_ATTRIBUTES,
        data = {
            "attributes": attributes,
            "nftID": nftID,
            "result": RESULT_SUCCESSFUL
        },
        topics = []
    )

    def emitFailedSetAttributesEvent(
        attributes: bytes,
        nftID: NFTID,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_SET_ATTRIBUTES,
            data = {
                "attributes": attributes,
                "nftID": nftID,
                "result": result
            },
            topics = []
        )
```

#### recover

This function should only be called by the Interoperability module. It recovers NFTs escrowed to terminated chains.

```python
def recover(
    terminatedChainID: ChainID,
    module: Module,
    substorePrefix: bytes,
    storeKey: bytes,
    storeValue: bytes
) -> None:

    if substorePrefix != SUBSTORE_PREFIX_NFT or length(storeKey) != SUBSTORE_KEY_LENGTH_NFT:
        emitFailedRevoverEvent(terminatedChainID, nftID, RESULT_INVALID_ARGUMENTS)
        raise Exception("Invalid arguments.")

    chainID = storeKey(:CHAIN_ID_LENGTH)
        nftID = storeKey

    if (chainID != Interoperability.getOwnChainAccount().ID
        or NFTStore(nftID).owner != terminatedChainID
        or storeValue does not follow nftStoreSchema):
        emitFailedRevoverEvent(terminatedChainID, nftID, RESULT_INVALID_ARGUMENTS)
        raise Exception("Invalid arguments.")

    nftValue = storeValue deserialized according to nftStoreSchema
    if length(nftValue.owner) != ADDRESS_LENGTH:
        emitFailedRevoverEvent(terminatedChainID, nftID, RESULT_INVALID_ARGUMENTS)
        raise Exception("Invalid arguments.")

    collection = bytes 5 to 8 of storeKey deserialized as uint32be
    index = last 8 bytes of storeKey deserialized as uint64be
    NFTStore(nftID).owner = nftValue.owner
    storedAttributes = NFTStore(nftID).attributes
    newAttributes = nftValue.attributes
    NFTStore(nftID).attributes = getNewAttributes(collection, storedAttributes, newAttributes)

    emitEvent(
        module = MODULE_NAME_NFT,
        name = EVENT_NAME_RECOVER,
        data = {
            "terminatedChainID": terminatedChainID,
            "nftID": nftID,
            "result": RESULT_SUCCESSFUL
        },
        topics = [nftID]
    )

    def emitFailedRecoversEvent(
        terminatedChainID: ChainID,
        nftID: NFTID,
        result: uint32
    ) -> None:

        emitPersistentEvent(
            module = MODULE_NAME_NFT,
            name = EVENT_NAME_RECOVER,
            data = {
                "terminatedChainID": terminatedChainID,
                "nftID": nftID,
                "result": result
            },
            topics = []
        )
```

### Endpoints for Off-Chain Services

TBA

### Genesis Block Processing

#### Genesis Assets Schema

```java
genesisNFTStoreSchema = {
    "type": "object",
    "required": [
        "NFTSubstore",
        "terminatedEscrowSubstore"
    ],
    "properties": {
        "NFTSubstore": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["nftID", "owner", "lockingModule", "attributes"],
                "properties": {
                    "nftID": {
                        "dataType": "bytes",
                        "length": NFT_ID_LENGTH,
                        "fieldNumber": 1
                    },
                    "owner": {
                        "dataType": "bytes",
                        "fieldNumber": 2
                    },
                    "lockingModule": {
                        "dataType": "string",
                        "minLength": MIN_MODULE_NAME_LENGTH,
                        "maxLength": MAX_MODULE_NAME_LENGTH,
                        "pattern": "^[a-zA-Z0-9]*$]",
                        "fieldNumber": 3
                    },
                    "attributes": {
                        "dataType": "bytes",
                        "maxLength": MAX_BYTE_LENGTH_ATTRIBUTES,
                        "fieldNumber": 4
                    }
                }
            }
        },
        "terminatedEscrowSubstore": {
            "type": "array",
            "fieldNumber": 2,
            "items": {
                "type": "object",
                "required": ["terminatedChainID", "terminatedEscrow"],
                "properties": {
                    "terminatedChainID": {
                        "dataType": "bytes",
                        "length": CHAIN_ID_LENGTH,
                        "fieldNumber": 1
                    },
                    "terminatedEscrow": {
                        "dataType": "boolean",
                        "fieldNumber": 2
                    }
                }
            }
        }
    }
}
```

#### Genesis State Initialization

During the genesis state initialization stage, the following steps are executed. If any step fails, the block is discarded and has no further effect.

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the NFT module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisNFTStoreSchema` schema, given above.

- Initial checks on the properties of `genesisBlockAssetObject`:

- Across all elements of the `NFTSubstore` array, all values given for `nftID` must be unique.
- For all elements of the `NFTSubstore` array, values given for `owner` must have either length 20 bytes (representing a user address) or 4 bytes (representing a chain ID).
- The `NFTSubstore` must be in lexicographical order of `owner`.
  - For a given `owner`, the entries must be in ascending order of `nftID`.
- For all elements of the `NFTSubstore` array, if the value of `owner` has length 4 bytes (representing an escrowed NFT), the corresponding `chainID = nftID[:CHAIN_ID_LENGTH]` must equal to `OWN_CHAIN_ID`.
- In the `terminatedEscrowSubstore` array, each element must be unique.
- The `terminatedEscrowSubstore` array must be in ascending order of `nftID`.

- For each entry `NFTEntry` in `genesisBlockAssetObject.NFTSubstore`, create an entry in the NFT substore with:

  ```python
  storeKey = NFTEntry.nftID
  storeValue = encode(
      schema = NFTStoreSchema,
      object = {
          "owner": NFTEntry.owner,
          "lockingModule": NFTEntry.lockingModule,
          "attributes": NFTEntry.attributes
      }
  )
  ```

  Further, if `NFTEntry.owner` has length 20 bytes, create an entry in the user substore with:

  ```python
  storeKey = NFTEntry.owner + NFTEntry.nftID
  storeValue = encode(
      schema = userStoreSchema,
      object = {
          "exists": True
      }
  )
  ```

- For each entry `terminatedChainID` in `genesisBlockAssetObject.terminatedEscrowSubstore`, create an entry in the terminated escrow substore with:

  ```python
  storeKey = terminatedChainID
  storeValue = encode(
      schema = terminatedEscrowSubstore,
      object = {
          "escrowTerminated": True
      }
  )
  ```

## Backwards Compatibility

Chains adding support for the NFT module specified in this document need to do so with a hard fork. This proposal does not imply a fork for the Lisk mainchain.

## Reference Implementation

TBA

[lip-0043]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0043.md
[lip-0045]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md
[lip-0049]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md
[lip-0049#ccmschema]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#cross-chain-message-schema
[lip-0068]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0068.md
