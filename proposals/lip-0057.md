```
LIP: 0057
Title: Define state and state transitions of PoS module
Author: Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
        Nazar Hussain <nazar@lightcurve.io>
        Mehmet Egemen Albayrak <mehmet.albayrak@lightcurve.io>
        Grigorios Koumoutsos <grigorios.koumoutsos@lightcurve.io>
Discussions-To: https://research.lisk.com/t/define-state-and-state-transitions-of-pos-module/320
Status: Draft
Type: Standards Track
Created: 2021-09-03
Updated: 2022-11-25
Required: 0022, 0023, 0024, 0040, 0044, 0046, 0058, 0059
```

## Abstract

The PoS (proof-of-stake) module is responsible for handling delegate registration, votes, and computing the delegate weight. In this LIP, we specify the properties of the PoS module, along with their serialization and initial values.
Furthermore, we specify the state transitions logic defined within this module, i.e. the commands, the protocol logic injected during the block lifecycle, and the functions that can be called from other modules or off-chain services. We also specify the events emitted by the PoS module.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

The PoS module handles all aspects of the generator selection, this includes the registration of accounts as delegates, the voting process, and potential misbehavior reports.

In this LIP we specify the properties, serialization, initialization, and exposed functions of the PoS module, as well as the protocol logic processed during a block life cycle and the module commands.

## Rationale

This LIP does not introduce significant protocol changes to the generator selection mechanism proposed in [LIP 0022][lip-0022] and [LIP 0023][lip-0023]. It only defines how the commands and processes defined in those LIPs are integrated in the [state model][lip-0040] used in Lisk. Please see [LIP 0022][lip-0022] and [LIP 0023][lip-0023] for a thorough rationale regarding the choice of voting system and the inclusion of standby delegates. [LIP 0022][lip-0022] defines a selection mechanism for 2 standby delegates. In this LIP, we slightly extend the specifications to support 0 or 1 standby delegate, however, we do not specify how to extend the protocol to more than 2 delegates. Introducing more standby delegates might require a different source of randomness and it is not the aim of this LIP to describe this topic.

### PoS Store

#### Voter Substore

This part of the state store is used to maintain the votes and recent unvotes of users (the ones for which the unvoted amount has not been unlocked). The entries are keyed by address and contain an array of the current votes as well as an array of objects representing the tokens waiting to be unlocked.

#### Delegate Substore

This part of the state store is used to maintain all information regarding the registered delegates. It is keyed by address and contains values for the delegate name, last generated height, total votes received, proof-of-misbehaviour heights, and a flag asserting if the delegate is banned or not.

#### Name Substore

This part of the state store is used to maintain a list of all names already registered. It allows the protocol to efficiently process the delegate registration transaction. The entries are keyed by delegate name and the value contains the address of the corresponding delegate.

#### Eligible Delegates Substore

This part of the state store is used to maintain the list of all non-banned delegates that have more delegate weight than a specified threshold. The delegates from this list with the most weight are active delegates, and the others are standby delegates.

#### Snapshot Substore

This part of the state store is used to maintain the needed snapshots of the eligible delegates. The entries are keyed by round number and contain the addresses and weights of eligible delegates at the end of the corresponding round. Based on this information, the sets of active and standby delegates are selected two rounds later. Entries for older rounds which are no longer necessary are removed.

#### Genesis Data Substore

This part of the state store is used to maintain information from the genesis block. This information is used to compute if a block is at the end of a round, and to generate the generator list during the bootstrap period.

#### Previous Timestamp Substore

This part of the state store is used to maintain the timestamp of the last block added to the chain. This is used when calling the function computing missed blocks from the Validators module.

### Setting BFT Weights

In this LIP, we set the BFT weights of active delegates to be proportional to their delegate weight. Additionally, to avoid a large concentration of BFT weight in one or only very few delegates, we introduce a capping threshold for the BFT weight, i.e., we do not allow one delegate to get more than a a certain percentage of the total BFT weight. This threshold is specified by the constant `MAX_BFT_WEIGHT_CAP`; for the Lisk mainchain, it is set to 5 %.

Note that further we choose `floor(2/3 * aggregateBFTWeight) + 1` as precommit and certificate threshold for PoS chains, see [LIP 0058][lip-0058] for an explanation of these parameters. Here `aggregateBFTWeight` is the sum of BFT weights of the active delegates. This choice of BFT parameters means that the safety and liveness of the BFT consensus protocol is ensured if `<1/3 * aggregateBFTWeight` is malicious (for the case of changing delegates the guarantees are slightly weaker). The capping of BFT weights to 5 % for the Lisk mainchain implies that at least 7 delegates would need to be malicious as any set of 6 delegates would have `<1/3 * aggregateBFTWeight` BFT weight. Similarly, only a set of at least 14 delegates could have BFT weight of `>= floor(2/3 * aggregateBFTWeight) + 1` and would therefore be able to generate any certificate. Hence, the capping ensures a minimum of decentralization in the delegate set, even in the case of very unbalanced delegate weight distribution. In practice, we expect the capping to only effect very few delegates, in particular, as rewards are also distributed proportional to the BFT weights.

By setting the BFT weights proportional to delegate weight instead of uniform BFT weights for all active delegates as done before, we can improve the security guarantees of the BFT consensus protocol. If we neglect the effect of capping, which will likely effect only very few delegates by a small percentage, then more than 1/3 of the active delegate weight are needed to have more than 1/3 of the BFT weight for an attack of the network. Assuming delegates generally have at least 10 % self-votes, this translates to at least 1/3 of the stake used in voting would have to be controlled by the attacker.

In the current system of uniform BFT weights this is not the case. The set of 34 lowest-weight delegates may have significantly less than 1/3 of the total delegate weight although their total BFT weight is more than 1/3. This means that quite a lot less than 1/3 of the voting stake is sufficient to control more than 1/3 of BFT weight, which would be sufficient to perform an attack on the network. Choosing BFT weights proportional to delegate weight avoids this issue.

## Specification

### Notation and Constants

For the rest of this proposal we define the following constants:

| Name | Type | Value | Description |
|------|------|-------|-------------|
| **Global constants** | | | |
| `ADDRESS_LENGTH` | uint32 | 20 | Length in bytes of type `Address`. |
| `BLS_PUBLIC_KEY_LENGTH` | uint32 | 48 | Length in bytes of type `PublicKeyBLS`. |
| `BLS_POP_LENGTH` | uint32 | 96 | Length in bytes of type `ProofOfPossession`. |
| `ED25519_PUBLIC_KEY_LENGTH` | uint32 | 32 | Length in bytes of type `PublicKeyEd25519`. |
| `SEED_LENGTH` | uint32 | 16 | Length in bytes of a valid seed revealed. |
| `OWN_CHAIN_ID` | bytes | | The [chain ID][lip-0037#chain-identifiers] of the chain. |
| `TOKEN_ID_LENGTH` | uint32  | 8 | Length in bytes of type `TokenID` |
| `INVALID_BLS_KEY` | bytes | 48 bytes all set to 0x00 | The byte value associated with validators that did not register a BLS key. |
| **PoS store constants** | | | |
| `SUBSTORE_PREFIX_VOTER` | bytes | 0x0000 | The substore prefix of the voter substore. |
| `SUBSTORE_PREFIX_DELEGATE` | bytes | 0x4000 | The substore prefix of the delegate substore. |
| `SUBSTORE_PREFIX_NAME` | bytes | 0x8000 | The substore prefix of the name substore. |
| `SUBSTORE_PREFIX_SNAPSHOT` | bytes | 0xd000 | The substore prefix of the snapshot substore. |
| `SUBSTORE_PREFIX_GENESIS_DATA` | bytes | 0xc000 | The substore prefix of the genesis data substore. |
| `SUBSTORE_PREFIX_PREVIOUS_TIMESTAMP` | bytes | 0xe000 | The substore prefix of the previous timestamp substore. |
| `SUBSTORE_PREFIX_ELIGIBLE_DELEGATES` | bytes | 0xf000 | The substore prefix of the eligible delegates substore. |
| **PoS constants** | | | |
| `MODULE_NAME_POS` | string | "pos" | The module name of the PoS module. |
| `COMMAND_NAME_DELEGATE_REGISTRATION` | string | "delegateRegistration"| The command name of the delegate registration transaction. |
| `COMMAND_NAME_VOTE` | string | "vote" | The command name of the vote transaction. |
| `COMMAND_NAME_UNLOCK` | string | "unlock" | The command name of the unlock transaction. |
| `COMMAND_NAME_POM` | string | "pom" | The command name of the proof-of-misbehavior transaction. |
| `MIN_INIT_ROUNDS` | uint32 | `3` | The minimum number of rounds for the [bootstrap period][lip-0034#bootstrap-period]. |
| `MAX_NUM_BYTES_Q96` | uint32 | 24 | The maximal number of bytes of a serialized fractional number in Q96 format (see [Reward sharing LIP][lip-reward-sharing]). |
| **Configurable Constants** | | **Mainchain Value** | |
| `TOKEN_ID_POS` | bytes | `TOKEN_ID_LSK = 0x 00 00 00 00 00 00 00 00` | The [token ID][lip-0051#tokenID] of the token used to cast votes. |
| `FACTOR_SELF_VOTES` | uint32 | `10` | The factor multiplying the self-votes of a delegate for the delegate weight computation. |
| `BASE_VOTE_AMOUNT` | uint32 | `10 * (10)^8` | The minimum voting amount. All voted amounts should be multiples of this value. |
| `MAX_LENGTH_NAME` | uint32 | `20` | The maximum allowed name length for delegates. |
| `MAX_NUMBER_SENT_VOTES` | uint32 | `10` | The maximum size of the sentVotes array of a voter substore entry. |
| `MAX_NUMBER_PENDING_UNLOCKS` | uint32 | `20` | The maximum size of the pendingUnlocks array of a voter substore entry. |
| `FAIL_SAFE_MISSED_BLOCKS` | uint32 | `50` | The number of consecutive missed blocks used in the fail safe banning mechanism. |
| `FAIL_SAFE_INACTIVE_WINDOW` | uint32 | `130,000` | The length of the inactivity window used in the fail safe banning mechanism. |
| `LOCKING_PERIOD_VOTES` | uint32 | `26,000` | The [locking period][lip-0023#explicit-unlock-mechanism] for regular votes. |
| `LOCKING_PERIOD_SELF_VOTES` | uint32 | `260,000` | The [locking period][lip-0023#explicit-unlock-mechanism] for self-votes. |
| `PUNISHMENT_WINDOW_VOTES` | uint32 | `260,000` | The punishment time for votes on punished delegates. |
| `PUNISHMENT_WINDOW_SELF_VOTES` | uint32 | `780,000` | The punishment time for self-votes of punished delegates. |
| `POM_REWARD` | uint32 | `10^8` | The reward (in `TOKEN_ID_POS`) for a sender of a proof-of-misbehavior transaction.   |
| `POM_LIMIT_BANNED` | uint32 | `5` | The number of proof-of-misbehavior transactions against a delegate for getting banned. |
| `MIN_WEIGHT` | uint64 | `1000*(10^8)` | The minimum delegate weight required to be selected as a block generator. |
| `NUMBER_ACTIVE_DELEGATES` | uint32 | `101` | The number of active delegates.To be compatible with the interoperability module, the value should be at most `MAX_NUM_VALIDATORS` ( constant defined in [LIP 0045][lip-0045#constants]), due to the fact that BLS keys of all active delegates should fit into a [Cross-Chain Update Transaction (CCU)][lip-0053]. |
| `NUMBER_STANDBY_DELEGATES` | uint32 | `2` | The number of standby delegates. This LIP is specified for the number of standby delegates being 0, 1 or 2. |
| `ROUND_LENGTH` | uint32 | `103` | The round length. Is equal to `NUMBER_ACTIVE_DELEGATES` + `NUMBER_STANDBY_DELEGATES` |
| `DELEGATE_REGISTRATION_FEE` | uint64 | `10*(10^8)` | The extra command fee of the delegate registration. |
| `WEIGHT_SCALE_FACTOR` | uint32 | `1000 * (10)^8` | It determines the factor by which BFT weights are divided. |
| `MAX_BFT_WEIGHT_CAP` | uint32 | `500` | It determines the maximum BFT weight percentage for a single delegate. The percentage is obtained by dividing this value by 100, i.e., a value of 500 corresponds to 5%. |

### Event Names and Results

| Name | Type | Value | Description |
|------|------|-------|-------------|
| **Event names** | | | |
| `EVENT_NAME_DELEGATE_REGISTERED` | string | "registerDelegate" | Used for events during delegate registration. |
| `EVENT_NAME_DELEGATE_VOTED` | string | "voteDelegate" | Used for events related to voting a delegate. |
| `EVENT_NAME_DELEGATE_PUNISHED` | string | "delegatePunished" | Used for events related to punishing a delegate. |
| `EVENT_NAME_DELEGATE_BANNED` | string | "delegateBanned" | Used for events related to banning a delegate. |
| **Result codes** | | | |
| `VOTE_SUCCESSFUL` | uint32 | 0 | Used when a vote succeeds. |
| `VOTE_FAILED_NON_REGISTERED_DELEGATE`| uint32 | 1 | Used when a vote fails because the voted account has not registered a delegate. |
| `VOTE_FAILED_INVALID_UNVOTE_PARAMETERS`| uint32 | 2 | Used when an unvote fails because the unvoted amount exceeds the total votes sent from voter to delegate. |
| `VOTE_FAILED_TOO_MANY_PENDING_UNLOCKS` | uint32 | 3 | Used when a vote fails because it the total number of pending unlocks of voter exceeds `MAX_NUMBER_PENDING_UNLOCKS`. |
| `VOTE_FAILED_TOO_MANY_SENT_VOTES` | uint32 | 4 | Used when a vote fails because the total number of delegates voted by the voter exceeds `MAX_NUMBER_SENT_VOTES`. |

### Type Definition

| Name | Type | Validation | Description |
|------|------|------------|-------------|
| `Address` | bytes | Must be of length `ADDRESS_LENGTH`. | Address of an account. |
| `Transaction` | object | Must follow the `transactionSchema` schema defined in [LIP 0068][lip-0068] with the only difference that `params` property is not serialized and contains the values of parameters of `paramsSchema` for the corresponding transaction. | An object representing a non-serialized transaction. |
| `TokenID` | bytes | Must be of length `TOKEN_ID_LENGTH`. | Used for token identifiers. |
| `UnlockObject` | object | Contains 3 elements (`address`, `amount`, `unvoteHeight`) of types `Address`, `uint64` and `uint32` respectively (same as the items in the `pendingUnlocks` array of the [voterStoreSchema](#json-schema)). | An object containing information regarding unvoting a delegate. |
| `PublicKeyBLS` | bytes | Must be of length `BLS_PUBLIC_KEY_LENGTH`. | Used for BLS keys. |
| `ProofOfPossession` | bytes | Must be of length `BLS_POP_LENGTH`. | [The proof of possession associated with a BLS key][lip-0038#public-key-registration]. |
| `PublicKeyEd25519` | bytes | Must be of length `ED25519_PUBLIC_KEY_LENGTH`. | Used for Ed25519 public keys. |
| `VoterStoreObject` | object | Must follow the [`voterStoreSchema` schema](#json-schema). | Deserialized version of voter substore values. |
| `DelegateStoreObject` | object | Must follow the [`delegateStoreSchema` schema](#json-schema-1). | Deserialized version of delegate substore values. |
| `EligibleDelegateObject` | object | Contains 2 elements (`address`, `weight`) of types `Address` and `uint64` respectively (same as the items in the `delegateWeightSnapshot` array of the [snapshotStoreSchema](#json-schema-4)). | An object containing information regarding an eligible delegate. |
| `ValidatorObject` | object | Contains 2 elements (`address`, `bftWeight`) of types `Address` and `uint64` respectively. | An object containing information regarding a validator. |

#### Functions from Other Modules

Calling a function `fct` from another module (named `module`) is represented by `module.fct(required inputs)`.

### PoS Module Store

The store keys and values of the PoS store are set as follows:

#### Voter Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `SUBSTORE_PREFIX_VOTER`.
* Each store key is a `ADDRESS_LENGTH`-byte `address`, representing a user address.
* Each store value is the serialization of an object following `voterStoreSchema`.
* Notation: For the rest of this proposal let `voterStore(address)` be the value stored in the voter substore with store key `address`, deserialized using `voterStoreSchema`.

##### JSON Schema

```java
voterStoreSchema = {
    "type": "object",
    "required": ["sentVotes", "pendingUnlocks"],
    "properties": {
        "sentVotes": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["delegateAddress", "amount", "voteSharingCoefficients"],
                "properties": {
                    "delegateAddress": {
                        "dataType": "bytes",
                        "length": ADDRESS_LENGTH,
                        "fieldNumber": 1
                    },
                    "amount": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    },
                    "voteSharingCoefficients": {
                        "type": "array",
                        "fieldNumber": 3,
                        "items":{
                            "type": "object",
                            "required": ["tokenID", "coefficient"],
                            "properties": {
                                "tokenID": {
                                    "dataType": "bytes",
                                    "length": TOKEN_ID_LENGTH,
                                    "fieldNumber": 1
                                },
                                "coefficient":{
                                    "dataType": "bytes",
                                    "maxLength": MAX_NUM_BYTES_Q96,
                                    "fieldNumber": 2
                                }
                            }
                        }
                    }
                }
            }
        },
        "pendingUnlocks": {
            "type": "array",
            "fieldNumber": 2,
            "items": {
                "type": "object",
                "required": ["delegateAddress", "amount", "unvoteHeight"],
                "properties": {
                    "delegateAddress": {
                        "dataType": "bytes",
                        "length": ADDRESS_LENGTH,
                        "fieldNumber": 1
                    },
                    "amount": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    },
                    "unvoteHeight": {
                        "dataType": "uint32",
                        "fieldNumber": 3
                    }
                }
            }
        }
    }
}
```

##### Properties

In this section, we describe the properties of the voter substore.

* `sentVotes`: stores an array of the current votes of a user. This array was called `votes` in [LIP 0023][lip-0023].
  Each vote is represented by the address of the voted delegate and the amount of tokens that have been used to vote for the delegate; in case reward sharing is enabled, the vote also includes the [sharing coefficients][lip-reward-sharing#efficient-calculation-of-rewards] at the time of voting (or at the last time rewards for this vote were claimed).
  This array is updated with a [vote command](#vote).
  The `sentVotes` array is always kept ordered in lexicographical order of `delegateAddress`.
  Its size is at most `MAX_NUMBER_SENT_VOTES`, any state transition that would increase it to above `MAX_NUMBER_SENT_VOTES` is invalid.
  Any element with `amount == 0` is removed from the array.
  For all elements of this array, the `voteSharingCoefficients` array is always kept ordered in lexicographical order of `tokenID`
* `pendingUnlocks`: stores an array representing the tokens that have been unvoted, but not yet unlocked.
  Each unvote generates an object in this array containing the address of the unvoted delegate, the amount of the unvote and the height at which the unvote was included in the chain.
  Objects in this array get removed when the corresponding [unlock command](#unlock) is executed. This array was called `unlocking` in [LIP 0023][lip-0023].
  This array is updated with [vote](#vote) and [unlock](#unlock) commands.
  The `pendingUnlocks` array is always kept ordered by lexicographical order of `delegateAddress`, ties broken by increasing `amount`, ties broken by increasing `unvoteHeight`.
  The size of the `pendingUnlocks` array is at most `MAX_NUMBER_PENDING_UNLOCKS`, any state transition that would increase it to above `MAX_NUMBER_PENDING_UNLOCKS` is invalid.
  NB: by construction, all elements of this array will have `amount != 0`.
* If any state transition would result in a voter substore entry to have `sentVotes == []` and `pendingUnlocks == []`, the entry is removed from the store.

#### Delegate Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `SUBSTORE_PREFIX_DELEGATE`.
* Each store key is a `ADDRESS_LENGTH`-byte `address`, representing a delegate address.
* Each store value is the serialization of an object following `delegateStoreSchema`.
* Notation: For the rest of this proposal let `delegateStore(address)` be the value stored in the delegate substore with store key `address`, deserialized using `delegateStoreSchema`.

##### JSON Schema

```java
delegateStoreSchema = {
    "type": "object",
    "required": [
        "name",
        "totalVotesReceived",
        "selfVotes",
        "lastGeneratedHeight",
        "isBanned",
        "pomHeights",
        "consecutiveMissedBlocks",
        "commission",
        "lastCommissionIncreaseHeight",
        "sharingCoefficients"
    ],
    "properties": {
        "name": {
            "dataType": "string",
            "fieldNumber": 1
        },
        "totalVotesReceived": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "selfVotes": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
        "lastGeneratedHeight": {
            "dataType": "uint32",
            "fieldNumber": 4
        },
        "isBanned": {
            "dataType": "boolean",
            "fieldNumber": 5
        },
        "pomHeights": {
            "type": "array",
            "fieldNumber": 6,
            "items": {"dataType": "uint32"}
        },
        "consecutiveMissedBlocks": {
            "dataType": "uint32",
            "fieldNumber": 7
        },
        "commission": {
            "dataType": "uint32",
            "fieldNumber": 8
        },
        "lastCommissionIncreaseHeight": {
            "dataType": "uint32",
            "fieldNumber": 9
        },
        "sharingCoefficients": {
            "type": "array",
            "fieldNumber": 10,
            "items":{
                "type": "object",
                "required": ["tokenID", "coefficient"],
                "properties": {
                    "tokenID": {
                        "dataType": "bytes",
                        "length": TOKEN_ID_LENGTH,
                        "fieldNumber": 1
                    },
                    "coefficient":{
                        "dataType": "bytes",
                        "maxLength": MAX_NUM_BYTES_Q96,
                        "fieldNumber": 2
                    }
                }
            }
        }
    }
}
```

##### Properties

In this section, we describe the properties of the delegate substore. Entries in this substore can be created during the execution of the genesis block. When the chain is running, entries in this substore are created by a [delegate registration command](#delegate-registration) and its value is set during the command execution. It contains information about the delegate whose address is the store key.

* `name`: a string representing the delegate name, with a minimum length of `1` character and a maximum length of `MAX_LENGTH_NAME`.
* `totalVotesReceived`: the sum of all votes received by a delegate.
* `selfVotes` : the sum of all votes the delegate cast for its own account.
* `lastGeneratedHeight`: the height at which the delegate last generated a block.
* `isBanned`: a Boolean value indicating if the delegate is banned or not. Banned delegates are never chosen to generate new blocks.
* `pomHeights`:  the heights at which a proof of misbehavior command was successfully executed with blocks generated by the delegate.
* `consecutiveMissedBlocks`: the number of consecutive missed blocks by the delegate. This value resets to 0 whenever a block generated by the delegate is included in the blockchain.

The following three properties are relevant only in case reward sharing is enabled. See the [Reward sharing LIP][lip-reward-sharing] for more details.

* `commission`: a number specifying the commission of the delegate. We use two decimals precision, i.e., the number will be an integer from 0 to 10000, where the commission percentage is commission/100.  
* `lastCommissionIncreaseHeight` : the height at which the delegate last increased the commission.
* `sharingCoefficients`: an array containing the value of the sharing coefficients of the delegate for each token.

#### Name Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `SUBSTORE_PREFIX_NAME`.
* Each store key is a utf8-encoded string `name`, representing a delegate name.
* Each store value is the serialization of an object following `nameStoreSchema`.
* Notation: For the rest of this proposal let `nameStore(name)` be the value stored in the name substore with store key `name`, deserialized using `nameStoreSchema`.

##### JSON Schema

```java
nameStoreSchema = {
    "type": "object",
    "required": ["delegateAddress"],
    "properties": {
        "delegateAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        }
    }
}
```

##### Properties

The name substore maintains all registered names, using the name as store key and storing the address of the validator that registered that name in the corresponding store value. Entries in this substore are created during the execution of [delegate registration command](#delegate-registration).

#### Eligible Delegates Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `SUBSTORE_PREFIX_ELIGIBLE_DELEGATES`.
* For the entry corresponding to a delegate, the store key is the concatenation of the delegate weight (represented using the big endian uint64 serialization) and the delegate address, i.e.,  `weight.to_bytes(8,'big') + address`.
* Each store value is the serialization of an object following `eligibleDelegatesStoreSchema`.
* Notation: For the rest of this proposal let `eligibleDelegatesStore(key)` be the value stored in the eligible delegates substore with store key `key`, deserialized using `eligibleDelegatesStoreSchema`.

##### JSON Schema

```java
eligibleDelegatesStoreSchema = {
    "type": "object",
    "required": ["lastPomHeight"],
    "properties": {
        "lastPomHeight": {
            "dataType": "uint32",
            "fieldNumber": 1
        }
    }
}
```

##### Properties

In this section, we describe the properties of the eligible delegates substore.

* `lastPomHeight`:  the height of the last proof of misbehavior transaction against the specified delegate. It's default value is 0.

This substore only maintains an entry for delegates that have weight more than `MIN_WEIGHT`, and that are not banned. It is updated via the [`updateDelegateEligibility` function](#updatedelegateeligibility).

#### Snapshot Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `SUBSTORE_PREFIX_SNAPSHOT`.
* Each store key is `roundNumber.to_bytes(4,'big')`, i.e., the big endian uint32 serialization of `roundNumber`, where `roundNumber` is the number of the round at the end of which the active delegates and weights are computed. These values will be used to compute the validator set for round `roundNumber + 2`.
* Each store value is the serialization of an object following `snapshotStoreSchema`.
* Notation: For the rest of this proposal let `snapshotStore(roundNumber)` be the value stored in the snapshot substore with store key `roundNumber.to_bytes(4,'big')`, deserialized using `snapshotStoreSchema`.

##### JSON Schema

```java
snapshotStoreSchema = {
    "type": "object",
    "required": ["delegateWeightSnapshot"],
    "properties": {
        "delegateWeightSnapshot": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["address", "weight"],
                "properties": {
                    "address": {
                        "dataType": "bytes",
                        "length": ADDRESS_LENGTH,
                        "fieldNumber": 1
                    },
                    "weight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        }
    }
}
```

The `delegateWeightSnapshot` array is ordered by decreasing `weight`, ties broken by reverse lexicographical ordering of `address`.

##### Properties

In this section, we describe the properties of the snapshot substore.

* `delegateWeightSnapshot`: all delegate addresses and weights of all non-banned delegates with more than `MIN_WEIGHT` delegate weight for the given round number.

The snapshot substore is initially empty.

#### Genesis Data Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `SUBSTORE_PREFIX_GENESIS_DATA`.
* The store key is set to empty bytes.
* The store value is the serialization of an object following `genesisDataStoreSchema`.
* Notation: For the rest of this proposal let:
  * `genesisDataStore.height` be the `height` property of the entry in the genesis data substore.
  * `genesisDataStore.initRounds` be the `initRounds` property of the entry in the genesis data substore.
  * `genesisDataStore.initDelegates` be the `initDelegates` property of the entry in the genesis data substore.

##### JSON Schema

```java
genesisDataStoreSchema = {
    "type": "object",
    "required": [
        "height",
        "initRounds",
        "initDelegates"
    ],
    "properties": {
        "height": {
            "dataType": "uint32",
            "fieldNumber": 1
        },
        "initRounds": {
            "dataType": "uint32",
            "fieldNumber": 2
        },
        "initDelegates": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "dataType": "bytes",
                      "length": ADDRESS_LENGTH
             }
        }
    }
}
```

##### Properties

The genesis data substore stores information from the genesis block. It is initialized when processing the genesis block.

* `height`: height of the genesis block.
* `initRounds`: the length of the [bootstrap period][lip-0034#bootstrap-period], also called initial rounds. `initRounds` must be at least `MIN_INIT_ROUNDS`.
* `initDelegates`: the addresses of the validators to be used during the bootstrap period. This property must have a non-empty value.

#### Previous Timestamp Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `SUBSTORE_PREFIX_PREVIOUS_TIMESTAMP`.
* The store key is set to empty bytes.
* The store value is the serialization of an object following `previousTimestampStoreSchema`
* Notation: For the rest of this proposal, let `previousTimestamp` be the `timestamp` property of the entry in the previous timestamp substore.

##### JSON Schema

```java
previousTimestampStoreSchema = {
    "type": "object",
    "required": ["timestamp"],
    "properties": {
        "timestamp": {
            "dataType": "uint32",
            "fieldNumber": 1
        }
    }
}
```

##### Properties

`timestamp`: The timestamp of the last block added to the chain.


### Commands

#### Delegate Registration

Transactions executing this command have:

* `module = MODULE_NAME_POS`,
* `command = COMMAND_NAME_DELEGATE_REGISTRATION`.

##### Parameters

```java
delegateRegistrationTransactionParams = {
    "type": "object",
    "required": [
        "name",
        "blsKey",
        "proofOfPossession",
        "generatorKey"
    ],
    "properties": {
        "name": {
            "dataType": "string",
            "fieldNumber": 1
        },
        "blsKey": {
            "dataType": "bytes",
            "length" : BLS_PUBLIC_KEY_LENGTH,
            "fieldNumber": 2
        },
        "proofOfPossession": {
            "dataType": "bytes",
            "length" : BLS_POP_LENGTH,
            "fieldNumber": 3
        },
        "generatorKey": {
            "dataType": "bytes",
            "length": ED25519_PUBLIC_KEY_LENGTH,
            "fieldNumber": 4
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:
    delegateAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH] # Derive delegateAddress from trs.senderPublicKey.    

    if there exists an entry delegateStore(delegateAddress) in delegate substore:
        raise Exception('This address has already registered a delegate.')
    if not isDelegateNameValid(trs.params.name):
        raise Exception('Invalid name')
    if there exists an entry nameStore(trs.params.name) in name substore:
        raise Exception('Name already used by a delegate.')
    if trs.fee < DELEGATE_REGISTRATION_FEE:
        raise Exception('Insufficient transaction fee.')
```

##### Execution

When a transaction `trs` executing a delegate registration command included in a block `b`, the logic below is followed:

```python
def execute(trs: Transaction) -> None:
    b = block including trs
    delegateAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH] # Derive delegateAddress from trs.senderPublicKey.
    delegateName = trs.params.name

    # This step also checks that the BLS key has not been used from another delegate.
    Validators.registerValidatorKeys(delegateAddress,
                                    trs.params.proofOfPossession,
                                    trs.params.generatorKey,
                                    trs.params.blsKey)

    # The new delegate pays the registration fee.
    Fee.payFee(DELEGATE_REGISTRATION_FEE)

    # Update delegate substore.
    delegateState = {
            "name": delegateName,
            "totalVotesReceived": 0,
            "selfVotes": 0,
            "lastGeneratedHeight": b.header.height,
            "isBanned": False,
            "pomHeights": [],
            "consecutiveMissedBlocks": 0,
            "commission": 10000,
            "lastCommissionIncreaseHeight": b.header.height,
            "sharingCoefficients": []
        }

    create an entry in the delegate substore with
        storeKey = delegateAddress,
        storeValue =  encode(delegateStoreSchema, delegateState)

    # Update name substore.
    create an entry in the name substore with
        storeKey = delegateName encoded as utf8,
        storeValue = encode(nameStoreSchema, {"delegateAddress": delegateAddress})

    # Emit event for the successful delegate registration.
    emitEvent(
            module=MODULE_NAME_POS,
            name=EVENT_NAME_DELEGATE_REGISTERED,
            data={
                "address": delegateAddress,
                "name": delegateName
            },
            topics=[delegateAddress]
        )
```

#### Vote

Transactions executing this command have:

* `module = MODULE_NAME_POS`
* `command = COMMAND_NAME_VOTE`

##### Parameters

```java
voteTransactionParams = {
    "type": "object",
    "required": ["votes"],
    "properties": {
        "votes": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["delegateAddress", "amount"],
                "properties": {
                    "delegateAddress" : {
                        "dataType": "bytes",
                        "length": ADDRESS_LENGTH,
                        "fieldNumber": 1
                    },
                    "amount": {
                        "dataType": "sint64",
                        "fieldNumber": 2
                    }
                }
            }
        }
    }
}
```

##### Verification

The `params` property of a vote transaction is valid if:

* `params.votes` has at most `2 * MAX_NUMBER_SENT_VOTES` elements. The reason of choosing this bound on the size is to allow a voter to unvote all voted delegates (which are at most `MAX_NUMBER_SENT_VOTES`) and vote for `MAX_NUMBER_SENT_VOTES` new ones in the same transaction.
* A given `delegateAddress` is included in at most one vote from the list of votes (regardless of the associated amounts).
* For all votes included in `params.votes`, we have:
  * `amount` value is a multiple of `BASE_VOTE_AMOUNT`, i.e., `amount % BASE_VOTE_AMOUNT == 0`. For the Lisk mainchain, where `BASE_VOTE_AMOUNT = 10^9` and `TOKEN_ID_POS = TOKEN_ID_LSK`, this corresponds to multiples of 10 LSK.
  * `amount != 0`.

##### Execution

When executing a vote transaction `trs`, the logic below is followed

```python
def execute(trs: Transaction) -> None:
    b = block including trs
    height = b.header.height
    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH] # Derive address from trs.senderPublicKey.

    # Sorting the votes guarantees that we first apply the votes with negative amounts.
    sortedVotes = trs.params.votes ordered by increasing value of amount

    for vote in sortedVotes:
        delegateAddress = vote.delegateAddress

        if delegateStore(delegateAddress) does not exist:
            emitVoteEvent(senderAddress, delegateAddress, vote.amount, VOTE_FAILED_NON_REGISTERED_DELEGATE)
            raise Exception('Invalid vote: no registered delegate with the specified address')

        if vote.amount < 0: # Case of unvote.
            sentVote = element in voterStore(senderAddress).sentVotes with sentVote.delegateAddress == delegateAddress
            if not sentVote or abs(vote.amount) > sentVote.amount:
                emitVoteEvent(senderAddress, delegateAddress, vote.amount, VOTE_FAILED_INVALID_UNVOTE_PARAMETERS)    
                raise Exception('Invalid unvote: The unvote amount exceeds the voted amount for this delegate')

            # Assign the rewards related to this vote to the sender.
            i = index of sentVote in voterStore(senderAddress).sentVotes
            assignVoteRewards(senderAddress, i)

            # Update voter substore.
            voterStore(senderAddress).sentVotes[i].amount += vote.amount

            if voterStore(senderAddress).sentVotes[i].amount == 0:
                remove sentVote from voterStore(senderAddress).sentVotes

            # Create unlock object for the unvote.
            unlockObject = {
                "delegateAddress" : delegateAddress,
                "amount" : abs(vote.amount),
                "unvoteHeight" : height
            }
            add unlockOject to voterStore(senderAddress).pendingUnlocks, keeping the array ordered by lexicographical order of delegateAddress,
                                                                         ties broken by increasing amount,
                                                                         ties broken by increasing unvoteHeight

            if len(voterStore(senderAddress).pendingUnlocks) > MAX_NUMBER_PENDING_UNLOCKS:
                emitVoteEvent(senderAddress, delegateAddress, vote.amount, VOTE_FAILED_TOO_MANY_PENDING_UNLOCKS)    
                raise Exception('Sender has reached the maximum number of pending unlocks.')

        if vote.amount > 0: # Case of regular vote.
            Token.lock(senderAddress, MODULE_NAME_POS, TOKEN_ID_POS, vote.amount) # Lock the voted amount.

            # User has already voted this delegate.
            if there exists an entry oldVote in voterStore(senderAddress).sentVotes with oldVote.delegateAddress = delegateAddress:
                i = index of oldVote in voterStore(senderAddress).sentVotes
                assignVoteRewards(senderAddress, i)

                # Update voter substore.
                voterStore(senderAddress).sentVotes[i].amount += vote.amount

            else: # New vote.
                add {"delegateAddress": delegateAddress, "amount": vote.amount,
                     "voteSharingCoefficients": delegateStore(vote.delegateAddress).sharingCoefficients}
                     to voterStore(senderAddress).sentVotes
                keeping the array ordered in lexicographical order of delegateAddress

            if len(voterStore(senderAddress).sentVotes) > MAX_NUMBER_SENT_VOTES:
                emitVoteEvent(senderAddress, delegateAddress, vote.amount, VOTE_FAILED_TOO_MANY_SENT_VOTES)
                raise Exception('This address has reached the maximum number of voted delegates.')

        # Update delegate substore.
        previousDelegateWeight = getDelegateWeight(delegateAddress)

        delegateStore(delegateAddress).totalVotesReceived += vote.amount
        if senderAddress == delegateAddress:
            delegateStore(delegateAddress).selfVotes += vote.amount

        emitVoteEvent(senderAddress, delegateAddress, vote.amount, VOTE_SUCCESSFUL)
        # Update eligible delegates substore.
        updateDelegateEligibility(delegateAddress, previousDelegateWeight)


def emitVoteEvent(senderAddress: Address, delegateAddress: Address, amount: uint64, result: uint32) -> None:
    if result == VOTE_SUCCESSFUL:
        emitEvent(
            module = MODULE_NAME_POS,
            name = EVENT_NAME_DELEGATE_VOTED,
            data={
                "senderAddress": senderAddress,
                "delegateAddress": delegateAddress,
                "amount": amount,
                "result": VOTE_SUCCESSFUL
            },
            topics = [senderAddress]
        )
    else:
        emitPersistentEvent(
            module = MODULE_NAME_POS,
            name = EVENT_NAME_DELEGATE_VOTED,
            data={
                "senderAddress": senderAddress,
                "delegateAddress": delegateAddress,
                "amount": amount,
                "result": result
            },
            topics = [senderAddress]
        )
```

Here, the [`updateDelegateEligibility` function](#updatedelegateeligibility) updates the eligible delegates substore according to the new weight of the voted delegate. The `assignVoteRewards` function is defined in the [reward sharing LIP][lip-reward-sharing]. The calls to this function are needed only in case reward sharing is enabled.

#### Unlock

Transactions executing this command have:

* `module = MODULE_NAME_POS`
* `command = COMMAND_NAME_UNLOCK`

##### Parameters

The `params` property of unlock transactions is empty.

##### Verification

No additional verification is performed for transactions executing this command.

##### Execution

```python
def execute(trs: Transaction) -> None:
    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH] # Derive address from trs.senderPublicKey.
    b = block including trs
    height = b.header.height

    for each unlockObject in voterStore(senderAddress).pendingUnlocks:
        # Check if unvoted amount can be unlocked.
        if (isUnlockable(unlockObject, senderAddress, height)
            and isCertificateGenerated(unlockObject)):

            delete unlockObject from voterStore(senderAddress).pendingUnlocks
            Token.unlock(senderAddress, MODULE_NAME_POS, TOKEN_ID_POS, unlockObject.amount)
            # Token module has its own event for successful/failed unlock so no need to add event here.
```

The definition and rationale for the `isCertificateGenerated` function is part of [LIP 0059][lip-0059]. The function `isUnlockable` is defined below. It's logic is the concatenation of the functions `hasWaited` and `isPunished` that are rationalized in [LIP 0023][lip-0023#explicit-unlock-mechanism] and [LIP 0024][lip-0024#rationale] respectively. This function has the following input parameters:

* `unlockObject`: an object with properties `delegateAddress` (the address of the previously voted delegate), `amount` (the unvote amount) and `unvoteHeight` (the height of the unvote).
* `senderAddress`: Address of the user sending the unlock transaction.
* `height`: the height of the block including the unlock transaction.

```python
def isUnlockable(unlockObject: UnlockObject, senderAddress: Address, height: uint32) -> bool:
    # First consider the case that delegate is not punished.
    delegateAddress = unlockObject.delegateAddress
    lockingPeriod = LOCKING_PERIOD_SELF_VOTES if delegateAddress == senderAddress else LOCKING_PERIOD_VOTES

    # If delegate is not punished, normal locking period for votes/selfvotes applies.
    if not isPunished(delegateAddress, height):       
        if height - unlockObject.unvoteHeight < lockingPeriod:
            return False

    else: # Delegate is punished.
        let lastPomHeight be the last element of delegateStore(delegateAddress).pomHeights
        # lastPomHeight is also the largest element of the pomHeights array.
        punishmentWindow = PUNISHMENT_WINDOW_SELF_VOTES if delegateAddress == senderAddress else PUNISHMENT_WINDOW_VOTES

        if height â€“ lastPomHeight < punishmentWindow and lastPomHeight < unlockObject.unvoteHeight + lockingPeriod:
            return False

    return True
```

In [LIP 0023][lip-0023] the [locking period][lip-0023#locking-period] for unvoted amounts was set to roughly 5.5 hours (2000 blocks) for the lisk mainchain. The sole protocol change in this LIP is to change this value to roughly 3 days, by setting `LOCKING_PERIOD_VOTES` to 26.000 blocks.    

#### Proof of Misbehavior

Transactions executing this command have:

* `module = MODULE_NAME_POS`
* `command = COMMAND_NAME_POM`

##### Parameters

```java
pomParams = {
    "type": "object",
    "required": ["header1", "header2"],
    "properties": {
        "header1": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "header2": {
            "dataType": "bytes",
            "fieldNumber": 2
        }
    }
}
```

##### Verification

Both properties of the parameters must follow the [block header schema `blockHeaderSchema`][lip-0055#block-header-json-schema] defined in LIP 0055. Validity of this transaction was previously specified in [LIP 0024][lip-0024#validity-of-a-pom-transaction]. For completeness, we include the pseudocode here.

```python
def verify(trs: Transaction) -> None:
    b = block including trs

    header1 = trs.params.header1
    header2 = trs.params.header2

    if header1 or header2 do not satisfy blockHeaderSchema schema:
        raise Exception('Invalid block header.')

    header1 = decode(blockHeaderSchema, header1)
    header2 = decode(blockHeaderSchema, header2)

    if max(abs(header1.height - b.header.height), abs(header2.height - b.header.height))  >= LOCKING_PERIOD_SELF_VOTES:
        raise Exception('Locking period has expired.')
    if isPunished(header1.address, b.header.height):
        raise Exception('Delegate is already punished.')
    if delegateStore(header1.address).isBanned:
        raise Exception('Delegate is banned.')
    if verifyBlockSignature(header1) == False or verifyBlockSignature(header2) == False:
        raise Exception('Invalid block signature')
    if areHeadersContradicting(header1, header2) == False:
        raise Exception('Block headers are not contradicting.')

```

The [verifyBlockSignature function](#verifyblocksignature) is an internal function defined below. The `areHeadersContradicting` function is defined in [LIP 0058][lip-0058].

##### Execution

Execution of this transaction was previously specified in [LIP 0024][lip-0024#applying-a-pom-transaction]. Here we update the specifications to be integrated in the [state model][lip-0040] used in Lisk.

```python
def execute(trs: Transaction) -> None:
    b = block including trs
    h = b.header.height
    senderAddress = SHA256(trs.senderPublicKey)[:ADDRESS_LENGTH] # Derive address from trs.senderPublicKey.

    header1 = decode(blockHeaderSchema, trs.params.header1)
    header2 = decode(blockHeaderSchema, trs.params.header2)

    punishedAddress = trs.params.header1.generatorAddress

    # Update delegate substore.
    delegateStore(punishedAddress).pomHeights.append(h)    

    # Emit event for the delegate punishment.
    emitEvent(
            module=MODULE_NAME_POS,
            name=EVENT_NAME_DELEGATE_PUNISHED,
            data={
                "address": delegateAddress
            },
            topics=[delegateAddress]
        )

    # Check if the delegate should be banned.
    if len(delegateStore(punishedAddress).pomHeights) == POM_LIMIT_BANNED:
        delegateStore(punishedAddress).isBanned = True
        # Emit event for the delegate banning.
        emitEvent(
                module=MODULE_NAME_POS,
                name=EVENT_NAME_DELEGATE_BANNED,
                data={
                    "address": delegateAddress
                },
                topics=[delegateAddress]
            )

    # Assign the PoM reward to the sender of the transaction.
    # The amount is taken from the punished delegate account.
    senderReward = min(POM_REWARD, delegateStore(punishedAddress).selfVotes)

    Token.unlock(punishedAddress, MODULE_NAME_POS, TOKEN_ID_POS, senderReward)
    Token.transfer(punishedAddress,
                   senderAddress,
                   TOKEN_ID_POS,
                   senderReward)
    # Update delegate and voter substores for punished delegate.
    oldWeight = getDelegateWeight(punishedAddress)
    delegateStore(punishedAddress).selfVotes -= senderReward
    delegateStore(punishedAddress).totalVotesReceived -= senderReward
    i = index of element in voterStore(punishedAddress).sentVotes array with item.delegateAddress == punishedAddress
    voterStore(punishedAddress).sentVotes[i].amount -= senderReward

    # Update eligibility of punished delegate, based on new weight and potential ban.
    updateDelegateEligibility(punishedAddress, oldWeight)
```

### Events

#### delegateRegistered

This event has `name = EVENT_NAME_DELEGATE_REGISTERED`. This event is emitted when a new delegate gets registered.

##### Topics

* `delegateAddress`: the address of the account registering a delegate.

##### Data

```java
delegateRegisteredDataSchema = {
    "type": "object",
    "required" = [
        "address",
        "name"
    ],
    "properties": {
        "address": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        },
        "name": {
            "dataType": "string",
            "fieldNumber": 2
        }
    }
}
```

#### vote

This event has `name = EVENT_NAME_DELEGATE_VOTED`. This event is emitted during the processing of each vote included in a vote transaction.

##### Topics

* `senderAddress`: the address of the account submitting the vote transaction.
* `delegateAddress`: the address of the account of the voted delegate.

##### Data

```java
voteataSchema = {
    "type": "object",
    "required" = [
        "senderAddress",
        "delegateAddress",
        "amount",
        "result"
    ],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        },
        "delegateAddress": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 2
        },
        "amount": {
            "dataType": "sint64",
            "fieldNumber": 3
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 4
        }
    }
}
```

#### delegatePunished

This event has `name = EVENT_NAME_DELEGATE_PUNISHED`. This event is emitted when a delegate gets punished.

##### Topics

* `delegateAddress`: the address of the account of the punished delegate.

##### Data

```java
delegatePunishedDataSchema = {
    "type": "object",
    "required" = [
        "address"
    ],
    "properties": {
        "address": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        }
    }
}
```

#### delegateBanned

This event has `name = EVENT_NAME_DELEGATE_BANNED`. This event is emitted when a delegate gets banned.

##### Topics

* `delegateAddress`: the address of the account of the banned delegate.

##### Data

```java
delegatePunishedDataSchema = {
    "type": "object",
    "required" = [
        "address"
    ],
    "properties": {
        "address": {
            "dataType": "bytes",
            "length": ADDRESS_LENGTH,
            "fieldNumber": 1
        }
    }
}
```

### Internal Functions

#### Round Number and End of Rounds

All blocks (with the exception of the genesis block) are part of a round. The first block after the genesis block is the first block of the first round, and so on. The round length, i.e. the number of blocks in a round, is specified in a configuration file and is denoted `ROUND_LENGTH`. In the block lifecycle, it will be useful to compute the round number to which a block belongs and if the block is the last block of its round. For this, we will use the following functions:

##### roundNumber

This function returns the round number to which the input height belongs.

```python
def roundNumber(h: uint32) -> uint32:
    return ceiling(h - genesisDataStore.height, ROUND_LENGTH)
```

Here, [`ceiling`](#ceiling) is an internal function defined below.

##### isEndOfRound

This function returns a boolean indicating if the input height is at the end of a round or not.

```python
def isEndOfRound(h: uint32) -> bool:
    if (h - genesisDataStore.height) % ROUND_LENGTH == 0:
        return True
    else:
        return False
```

#### ceiling

Returns the ceiling of the division between two positive integers.

```python
def ceiling(x: uint32,y: uint32) -> uint32:
    if y == 0:
        raise Exception('Can not divide by 0.')
    return (x+y-1)//y
```

#### getDelegateWeight

This function returns the weight of a given delegate (specified by the address).

```python
def getDelegateWeight(address: Address) -> uint64:
    return min(delegateStore(address).selfVotes * FACTOR_SELF_VOTES,
               delegateStore(address).totalVotesReceived)
```

#### shuffleValidatorsList

A function to reorder the list of validators as specified in [LIP 0003][lip-0003].

##### Parameters

The function has the following input parameters in the order given below:

* `validatorList`: An array of objects with of type `ValidatorObject`.
* `randomSeed`: A `SEED_LENGTH`-byte value representing a random seed.

##### Returns

This function returns the input list shuffled using the value of `randomSeed`.

##### Execution

```python
def shuffleValidatorsList(validatorList: list[ValidatorObject], randomSeed: bytes) -> list[ValidatorObject]:
    # Checking pairwise distinct property.
    if validatorList != set(validatorList):
        raise Exception('Validators list invalid (duplicate values detected)')

    roundHash = {}
    for item in validatorList:
        roundHash[item.address] = SHA256(randomSeed + item.address) # Hashing concatenation of randomSeed and address.

    # Reorder the validator list.
    shuffledValidatorList = sort validatorList where item1 < item2 if (roundHash(item1.address) < roundHash(item2.address))
                                 or ((roundHash[item1.address] == roundHash[item1.address]) and item1.address < item2.address)         

    return shuffledValidatorList
```

#### updateDelegateEligibility

A function that updates the eligible delegates substore to account for new changes of delegate properties.

##### Parameters

The function has the following input parameters:

* `address`: the address of a delegate.
* `oldWeight`: the weight of the delegate before the eligibility update.

##### Returns

This function does not return.

##### Execution

```python
def updateDelegateEligibility(address: Address, oldWeight: uint64) -> None:
    # Always start by removing the old entry from the eligible delegates substore.
    oldKey = oldWeight.to_bytes(8,'big') + address
    if the eligible delegate substore contains an entry for key = oldKey:
        remove this entry from the store

    # If the delegate is eligible, add an entry to the eligible delegates substore.
    weight = getDelegateWeight(address)
    if (weight >= MIN_WEIGHT and delegateStore(address).isBanned == False):

        newKey = weight.to_bytes(8,'big') + address
        lastPomHeight = delegateStore(delegateAddress).pomHeights[-1] if len(delegateStore(delegateAddress).pomHeights) else 0
        create an entry in the eligible delegates substore with
            storeKey = newKey,
            storeValue = encode(eligibleDelegatesStoreSchema, {lastPomHeight})
```

#### verifyBlockSignature

Checks whether a block header is validly signed.

##### Execution

```python
def verifyBlockSignature(header: Header) -> bool:
    generatorKey = Validators.getValidatorKeys(header.generatorAddress).generatorKey
    signature = block.header.signature

    # Remove the signature from the block header.
    delete header.signature
    # Serialize the block header without signature.
    serializedUnsignedBlockHeader = encode(unsignedBlockHeaderSchema, header)

    return verifyEd25519(generatorKey, "LSK_BH_", OWN_CHAIN_ID, serializedUnsignedBlockHeader, signature)
```

Here, the function `verifyEd25519` verifies the validity of a signature as specified in [LIP 0062][lip-0062#specification].

#### isDelegateNameValid

Checks whether a given string would be a valid delegate name.

##### Execution

```python
def isDelegateNameValid(delegateName: str) -> bool:
    # Name should contain only lower case letters, numbers and symbols `!@$&_.`
    # and should be at least 1 character long and at most MAX_LENGTH_NAME characters long.
    if (not(all(c.isdigit() or c.islower() or c in ['!','@','$','&','_','.'] for c in delegateName))
        or len(delegateName) < 1
        or len(delegateName) > MAX_LENGTH_NAME):

        return False

    return True
```

##### isPunished

This function returns a boolean indicating if a delegate is punished at a certain height of not.

```python
def isPunished(address: Address, height: uint32) -> bool:
    if delegateStore(address).pomHeights is empty:
        return False

    let lastPomHeight be the last element of delegateStore(address).pomHeights

    if height <= lastPomHeight + PUNISHMENT_WINDOW_SELF_VOTES:
        return True

    return False
```

#### getActiveDelegates

This function computes the set of active delegates and their BFT weight based on the input set of eligible delegates.

```python
def getActiveDelegates(validatorsTwoRoundsAgo: list[EligibleDelegateObject], roundNumber: uint32) -> list[ValidatorObject]:
    initRounds = genesisDataStore.initRounds
    initDelegates = genesisDataStore.initDelegates

    # During the first NUMBER_ACTIVE_DELEGATES rounds after the bootstrap period
    # the initial delegates are only partly replaced by elected delegates.
    # During this phase, there are no selected standby delegates.
    if roundNumber < initRounds + NUMBER_ACTIVE_DELEGATES:
        nbrInitValidators = initRounds + NUMBER_ACTIVE_DELEGATES - roundNumber
        nbrElectedValidators = NUMBER_ACTIVE_DELEGATES - nbrInitValidators

        # In the definition below, recall that validatorsTwoRoundsAgo is sorted by delegate weight.
        electedDelegateAddresses = [item.address for item in validatorsTwoRoundsAgo[:nbrElectedValidators]]

        remainingInitDelegates = [address for address in initDelegates if address not in electedDelegateAddresses]

        # Concatenation of elected validators and remaining initial delegates.
        activeDelegateAddresses = electedDelegateAddresses + remainingInitDelegates[:nbrInitValidators]
        activeDelegates = [{"address": item, "bftWeight": 1 } for item in activeDelegateAddresses]

    else:
        # If validatorsTwoRoundsAgo contains less than NUMBER_ACTIVE_DELEGATES entries
        # there will be less than NUMBER_ACTIVE_DELEGATES active delegates.
        # Recall that validatorsTwoRoundsAgo is sorted by delegate weight.
        activeDelegates = [{"address": item.address, "bftWeight": ceiling(item.weight, WEIGHT_SCALE_FACTOR) } for item in validatorsTwoRoundsAgo[:NUMBER_ACTIVE_DELEGATES]]
        # Apply capping in weights if necessary.
        if len(activeDelegates) >= ceiling(10000, MAX_BFT_WEIGHT_CAP):
            activeDelegates = capWeights(activeDelegates, MAX_BFT_WEIGHT_CAP)

    return activeDelegates
```

#### getSelectedStandbyDelegates

This function selects the standby delegates for a round and returns them together with their BFT weight.

```python
def getSelectedStandbyDelegates(standbyDelegates: list[EligibleDelegateObject], height: uint32) -> list[ValidatorObject]:
    # We now compute the randomness used for selecting the first standby delegate.
    randomSeed1 = random.getRandomBytes(
        height +1 - (ROUND_LENGTH*3)//2,
        ROUND_LENGTH
    )

    if NUMBER_STANDBY_DELEGATES == 2 and len(standbyDelegates) >=2:
        randomSeed2 = random.getRandomBytes(
            height +1 - 2*ROUND_LENGTH,
            ROUND_LENGTH
        )
        selectedStandbyDelegates = select 2 address from standbyDelegates
                                   as specified in LIP 0022, using the seeds randomSeed1 and randomSeed2
    elif NUMBER_STANDBY_DELEGATES >= 1 and len(standbyDelegates) >= 1:
        selectedStandbyDelegates = select 1 address from standbyDelegates
                                   as specified in LIP 0022, using the seed randomSeed1
    else: # No standby delegates.
        selectedStandbyDelegates = empty

    return [{"address": item.address, "bftWeight": 0} for item in selectedStandbyDelegates]
```

#### capWeights

This function caps the values of a sorted array to make sure that no element has value more than a certain percentage of the total value.

##### Parameters

* `validatorList`: An array of objects of type `ValidatorObject` array of integers, sorted in decreasing order of `weight`.
* `capValue`: Specifies the percentage in which the values are capped. Takes values from 0 - 10000 corresponding to double decimal precision integers which can be obtained by dividing it by 100, i.e., 1000 means 10%.

```python
def capWeights(validatorList: list[ValidatorObject], capValue: uint32) -> list[ValidatorObject]:
    if validatorList.sort(reverse = True, key = lambda y:y.bftWeight) != validatorList: # List should be ordered in decreasing order of weight.
        raise Exception('List is not sorted in decreasing order.')
    if capValue == 0 or capValue >= 10000:
        raise Exception('Invalid value for capping.')

    maxNumCappedElements = ceiling(10000, capValue) - 1
    if len(validatorList) <= maxNumCappedElements:
        raise Exception('List size not enough to apply capping with specified value.')

    partialSum = 0
    for i in range(maxNumCappedElements + 1, len(validatorList)):
        partialSum += validatorList[i].bftWeight

    for i in range(maxNumCappedElements, 0, -1):
       partialSum += validatorList[i].bftWeight
       cappedWeightRemainingElements = (capValue * partialSum) // (10000 - (capValue * i))
       if cappedWeightRemainingElements < validatorList[i-1].bftWeight:
           for k in range(i):
              validatorList[k].bftWeight = cappedWeightRemainingElements
           break

    return validatorList
```

The idea of the function above is that for the `validatorList` with elements in descending order of `bftWeight`, then you want the following equation to hold for element `i`:

```
x <= (capValue / 10000) ( i * x + sum( [validatorList[k].bftWeight for k in range(i,len(validatorList))])
```

Here `x` is the BFT weight at which the elements `validatorList[0].bftWeight, ..., validatorList[i-1].bftWeight` are capped. Solving the above equation for `x` yields the value of `cappedWeightRemainingElements` in the code. Note that if
`cappedWeightRemainingElements > validatorList[i-1].bftWeight`, then you do not need to cap `validatorList[i-1].bftWeight` and can reduce the index `i` by 1.

### Protocol Logic for Other Modules

More functions might be made available during implementation.

#### getVoter

Returns the stored information relative to the given address.

```python
def getVoter(address: Address)-> VoterStoreObject:
    return voterStore(address)
```

#### getDelegate

Returns the stored information relative to the given address.

```python
def getDelegate(address: Address)-> DelegateStoreObject:
    return delegateStore(address)
```

#### unbanDelegate

Removes the banning for a delegate, given that the reason of banning was not due to misbehaviors. For example, this applies in cases the delegate got banned due to inactivity or not registering valid BLS keys.

```python
def unbanDelegate(address: Address)-> None:
    if there does not exist an entry in delegate substore with key == address:
        raise Exception('No registered delegate with the specified address.')
    if  delegateStore(address).isBanned == False:
        raise Exception('The specified delegate is not banned.')
    if len(delegateStore(address).pomHeights) < POM_LIMIT_BANNED:
        delegateStore(address).isBanned = False
```

### Endpoints for Off-Chain Services

#### isNameAvailable

Asserts the availability of a given name for delegate registration.

```python
def isNameAvailable(name: str) -> bool:
    if (not isDelegateNameValid(name))
        or (nameStore(name) exists):
        return False
    else:
        return True
```

#### getPoSTokenID

```python
def getPoSTokenID() -> TokenID:
    return TOKEN_ID_POS
```

#### getVoter

Same as the [getVoter function](#getvoter) of the previous section.

#### getDelegate

Same as the [getDelegate function](#getdelegate) of the previous section.

#### getAllDelegates

Returns information of all delegates.

##### Execution

```python
def getAllDelegates()-> list[DelegateStoreObject]:
    return [decode(delegateStoreSchema,delegateStore(address)) for delegateStore(address) in delegate substore]
```

#### getLockedVotedAmount

Returns the total amount locked due to participation in voting (active votes and pending unlocks) for the given address.

```python
def getLockedVotedAmount(address: Address) -> uint64:
    lockedVotedAmount = 0
    for item in voterStore(address).sentVotes:
        lockedVotedAmount+= item.amount
    for item in voterStore(address).pendingUnlocks:
        lockedVotedAmount+= item.amount

    return lockedVotedAmount
```

#### getPendingUnlocks

Returns the list of pending unlocks for the given address.

##### Execution

```python
def getPendingUnlocks(address: Address)-> UnlockObject:
    return voterStore(address).pendingUnlocks
```

### Genesis Block Processing

The following steps are executed as part of the genesis block processing, see [LIP 0060][lip-0060]  for details.

#### Genesis Assets Schema

```java
genesisPoSStoreSchema = {
    "type": "object",
    "required": ["validators", "voters", "genesisData"],
    "properties": {
        "validators": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": [
                    "address",
                    "name",
                    "blsKey",
                    "proofOfPossession",
                    "generatorKey",
                    "lastGeneratedHeight",
                    "isBanned",
                    "pomHeights",
                    "consecutiveMissedBlocks",
                    "commission",
                    "lastCommissionIncreaseHeight",
                    "sharingCoefficients"
                ],
                "properties": {
                    "address": {
                        "dataType": "bytes",
                        "length": ADDRESS_LENGTH,
                        "fieldNumber": 1
                    },
                    "name": {
                        "dataType": "string",
                        "fieldNumber": 2
                    },
                    "blsKey": {
                        "dataType": "bytes",
                        "length" : BLS_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 3
                    },
                    "proofOfPossession": {
                        "dataType": "bytes",
                        "length" : BLS_POP_LENGTH,
                        "fieldNumber": 4
                    },
                    "generatorKey": {
                        "dataType": "bytes",
                        "length": ED25519_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 5
                    },
                    "lastGeneratedHeight": {
                        "dataType": "uint32",
                        "fieldNumber": 6
                    },
                    "isBanned": {
                        "dataType": "boolean",
                        "fieldNumber": 7
                    },
                    "pomHeights": {
                        "type": "array",
                        "fieldNumber": 8,
                        "items": { "dataType": "uint32" }
                    },
                    "consecutiveMissedBlocks": {
                        "dataType": "uint32",
                        "fieldNumber": 9
                    },
                    "commission": {
                        "dataType": "uint32",
                        "fieldNumber": 10
                    },
                    "lastCommissionIncreaseHeight": {
                        "dataType": "uint32",
                        "fieldNumber": 11
                    },
                    "sharingCoefficients": {
                        "type": "array",
                        "fieldNumber": 12,
                        "items":{
                            "type": "object",
                            "required": ["tokenID", "coefficient"],
                            "properties": {
                                "tokenID": {
                                    "dataType": "bytes",
                                    "length": TOKEN_ID_LENGTH,
                                    "fieldNumber": 1
                                },
                                "coefficient":{
                                    "dataType": "bytes",
                                    "maxLength": MAX_NUM_BYTES_Q96,
                                    "fieldNumber": 2
                                }
                            }
                        }
                    }                        
                }
            }
        },
        "voters": {
            "type": "array",
            "fieldNumber": 2,
            "items": {
                "type": "object",
                "required": ["address", "sentVotes", "pendingUnlocks"],
                "properties": {
                    "address": {
                        "dataType": "bytes",
                        "fieldNumber": 1
                    },
                    "sentVotes": {
                        "type": "array",
                        "fieldNumber": 2,
                        "items": {
                            "type": "object",
                            "required": ["delegateAddress", "amount", "voteSharingCoefficients"],
                            "properties": {
                                "delegateAddress": {
                                    "dataType": "bytes",
                                    "length": ADDRESS_LENGTH,
                                    "fieldNumber": 1
                                },
                                "amount": {
                                    "dataType": "uint64",
                                    "fieldNumber": 2
                                },
                                "voteSharingCoefficients": {
                                    "type": "array",
                                    "fieldNumber": 3,
                                    "items":{
                                        "type": "object",
                                        "required": ["tokenID", "coefficient"],
                                        "properties": {
                                            "tokenID": {
                                                "dataType": "bytes",
                                                "length": TOKEN_ID_LENGTH,
                                                "fieldNumber": 1
                                            },
                                            "coefficient":{
                                                "dataType": "bytes",
                                                "maxLength": MAX_NUM_BYTES_Q96,
                                                "fieldNumber": 2
                                            }
                                        }
                                    }
                                }                                
                            }
                        }
                    },
                    "pendingUnlocks": {
                        "type": "array",
                        "fieldNumber": 3,
                        "items": {
                            "type": "object",
                            "required": [
                                "delegateAddress",
                                "amount",
                                "unvoteHeight"
                            ],
                            "properties": {
                                "delegateAddress": {
                                    "dataType": "bytes",
                                    "length": ADDRESS_LENGTH,
                                    "fieldNumber": 1
                                },
                                "amount": {
                                    "dataType": "uint64",
                                    "fieldNumber": 2
                                },
                                "unvoteHeight": {
                                    "dataType": "uint32",
                                    "fieldNumber": 3
                                }
                            }
                        }
                    }
                }
            }
        },
        "genesisData": {
            "type": "object",
            "fieldNumber": 4,
            "required": ["initRounds", "initDelegates"],
            "properties": {
                "initRounds": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "initDelegates": {
                    "type": "array",
                    "fieldNumber": 2,
                    "items": {
                        "dataType": "bytes",
                        "length": ADDRESS_LENGTH
                    }
                }
            }
        }
    }
}
```

#### Genesis State Initialization

During the genesis state initialization stage, the following steps are executed. If any step fails, the block is discarded and has no further effect.

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the PoS module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisPoSStoreSchema` schema, given above.

* Initial checks on the properties of `genesisBlockAssetObject`:
  * `genesisBlockAssetObject` should satisfy the [`genesisPoSStoreSchema` schema](#genesis-assets-schema).
  * Across elements of the `validators` array, all `address` values must be unique, all `name` values must also be unique.
  * For all elements of the `validators` array, `name` values must satisfy `isDelegateNameValid(name) == True`.
  * For all elements of the `validators` array, `commission` values must satisfy `commission <= 10000`.
  * For all elements of the `validators` array, `lastCommissionIncreaseHeight` values must satisfy `lastCommissionIncreaseHeight <=` block header height of the genesis block.
  * For all elements of the `validators` array, the `sharingCoefficients` array must be ordered in lexicographic order of `tokenID`.
  * Across elements of the `voters` array, all `address` values must be unique.
  * For all elements of the `voters` array:
    * Either `sentVotes != []` or `pendingUnlocks != []`.
    * All `amounts` properties in elements of the `sentVotes` or the `pendingUnlocks` arrays must be non-zero.
    * Across elements of the `sentVotes` array, all `delegateAddress` values must be unique.
    * For each element `sentVote` in the `sentVotes` array, there is an element `validator` in the `validators` array with `validator.address == sentVote.delegateAddress`. Moreover, for each `item` in `sentVote.voteSharingCoefficients` array, there must be an entry `elem` in the `validator.sharingCoefficients` array such that `item.tokenID == elem.tokenID` and `item.coefficient <= elem.coefficient`.
    * For each element `sentVote` in the `sentVotes` array, the `voteSharingCoefficients` must be ordered in lexicographic order of `tokenID`.
    * For each element `sentVote` in the `sentVotes` array, for each item in `voteSharingCoefficients` array  must be ordered in lexicographic order of `tokenID`.
    * `sentVotes` has size is at most `MAX_NUMBER_SENT_VOTES`.
    * `sentVotes` must be in lexicographic order of `delegateAddress`.
    * `pendingUnlocks` has size is at most `MAX_NUMBER_PENDING_UNLOCKS`.
    * `pendingUnlocks` must be ordered by lexicographical order of `delegateAddress`, ties then broken by increasing `amount`, ties finally broken by increasing `unvoteHeight`.
    * For each element `pendingUnlock` in the `pendingUnlocks` array, there is an element `validator` in the `validators` array with `validator.address == pendingUnlock.delegateAddress`.
    * For each element `pendingUnlock` in the `pendingUnlocks` array, `unvoteHeight` value must satisfy `unvoteHeight <`block header height of the genesis block.
  * All values of the `genesisData.initDelegates` array must be unique and must be equal to `validator.address` for a `validator` element of `validators`.
  * The `genesisData.initDelegates` array must have length equal to `NUMBER_ACTIVE_DELEGATES` and be in lexicographical order.
  * `genesisData.initRounds` must be at least `MIN_INIT_ROUNDS`.
* For each entry `validator` in `genesisBlockAssetObject.validators`, create an entry in the delegate substore with:
  ```python
  totalVotesReceived = 0
  for voter in genesisBlockAssetObject.voters:
      for sentVote in voter.sentVotes:
          if sentVote.delegateAddress == validator.address:
              totalVotesReceived += sentVote.amount
              if voter.address == validator.address:
                  selfVotes = sentVote.amount

  delegateState = {
      "name": validator.name,
      "totalVotesReceived": totalVotesReceived,
      "selfVotes": selfVotes,
      "lastGeneratedHeight": validator.lastGeneratedHeight,
      "isBanned": validator.isBanned,
      "pomHeights": validator.pomHeights,
      "consecutiveMissedBlocks": validator.consecutiveMissedBlocks,
      "commission" : validator.commission,
      "lastCommissionIncreaseHeight": validator.lastCommissionIncreaseHeight,
      "sharingCoefficients": validator.sharingCoefficients  
  }
  storeKey = validator.address
  storeValue = encode(delegateStoreSchema, delegateState)
  ```

  Further, for every entry `validator` in `genesisBlockAssetObject.validators`, also create an entry in the name substore with:

  ```python
  delegateState = {
      "delegateAddress": validator.address
  }

  storeKey = validator.name utf8-encoded
  storeValue = encode(nameStoreSchema, delegateState)
  ```

* For each entry `voter` in `genesisBlockAssetObject.voters`, create an entry in the voter substore with:
  ```python

  voterState = {
      "sentVotes": voter.sentVotes,
      "pendingUnlocks": voter.pendingUnlocks
  }
  storeKey = voter.address
  storeValue =  encode(voterStoreSchema, voterState)
  ```
* Create an entry in the genesis data substore with:
  ```python
  genesisState = {
      "height": block header height of the genesis block,
      "initRounds": genesisBlockAssetObject.genesisData.initRounds,
      "initDelegates": genesisBlockAssetObject.genesisData.initDelegates
  }

  storeKey = EMPTY_BYTES
  storeValue = encode(genesisDataStoreSchema, genesisState)
  ```
* Create an entry in the previous timestamp substore with:
  ```python
  timestampState = {
      "timestamp": block header height of the genesis block
  }  
  storeKey = EMPTY_BYTES
  storeValue = encode(previousTimestampStoreSchema, timestampState)
  ```

#### Genesis State Finalization

To finalize the state of the genesis block the following logic is executed.  If any step fails, the block is discarded and has no further effect.

As in the previous point, let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the PoS module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisPoSStoreSchema` schema, given above. Moreover, let `b` be the genesis block. Then:

```python
# Register all validators in the Validators module.
# For the snapshot block for the migration from Lisk Core 3 to Lisk Core 4 on
# Lisk mainnet, apply a special rule. This must be done as validators in
# this snapshot block do not have a BLS key.
if the chain is the mainchain and b is the snapshot block for the migration:
    for validator in genesisBlockAssetObject.validators:
        Validators.registerValidatorWithoutBLSKey(
            validator.address,
            validator.generatorKey
        )

else:
# For any other genesis block, register validators with a BLS key.
    for validator in genesisBlockAssetObject.validators:
        Validators.registerValidatorKeys(
            validator.address,
            validator.proofOfPossession,
            validator.generatorKey,
            validator.blsKey
        )
        updateDelegateEligibility(validator.address, 0)

# Check that all sentVotes and pendingUnlocks correspond to locked tokens.
for address a key of the voter substore:
    if there exists an entry in delegate substore with key == address:
        if Token.getLockedAmount(address, MODULE_NAME_POS, TOKEN_ID_POS) < getLockedVotedAmount(address):
            raise Exception('Locked amount is incompatible with specified votes.')
    else:
        # For non-delegates, the only reason for locking is voting, so the values should match precisely.
        if Token.getLockedAmount(address, MODULE_NAME_POS, TOKEN_ID_POS) != getLockedVotedAmount(address):
            raise Exception('Locked values do not match.')

# Set the initial delegates.
# Recall that initDelegate is always in lexicographical order.
validatorList = [
    {"address": address, "bftWeight": 1}
    for address in genesisBlockAssetObject.genesisData.initDelegates
]

# Compute the thresholds for the BFT consensus protocol.
aggregateBFTWeight = 0
for validator in validatorList:
    aggregateBFTWeight += validator.bftWeight

precommitThreshold = (2 * aggregateBFTWeight) // 3 + 1
certificateThreshold = precommitThreshold

Validators.setValidatorParams(precommitThreshold, certificateThreshold, validatorList)
```

### Block Processing

The following steps are executed as part of the (non-genesis) block processing, see [LIP 0055][lip-0055] for details.

#### After Transactions Execution

After the transactions in a block `b` are executed, the properties related to missed blocks are updated according to [Delegate Productivity][lip-0023#delegate-productivity]. This logic is recapitulated below:

```python
def afterTransactionsExecute(b: Block) -> None:
    height = b.header.height

    # previousTimestamp is the value in the previous timestamp substore.
    missedBlocks = Validators.getGeneratorsBetweenTimestamps(previousTimestamp, b.header.timestamp)

    for address in missedBlocks:
        delegateStore(address).consecutiveMissedBlocks += missedBlocks[address]

        # The below rule was introduced in LIP 0023.
        if (delegateStore(address).consecutiveMissedBlocks > FAIL_SAFE_MISSED_BLOCKS
            and height - delegateStore(address).lastGeneratedHeight > FAIL_SAFE_INACTIVE_WINDOW):
            delegateStore(address).isBanned = True
            updateDelegateEligibility(address,getDelegateWeight(address))

    delegateStore(b.header.generatorAddress).consecutiveMissedBlocks = 0
    delegateStore(b.header.generatorAddress).lastGeneratedHeight = height

    # Update previousTimestamp substore.
    previousTimestamp = b.header.timestamp

    if isEndOfRound(height) == False:
        return

    # Block b is an end-of-round block. Need to update snapshot and select delegates for next round.
    # This must be done after the properties related to missed blocks are updated.

    # Punished delegates are excluded from the snapshot.
    eligibleDelegates = [
        {"address": key[-ADDRESS_LENGTH:], "weight": int.from_bytes(key[:-ADDRESS_LENGTH], 'big')}
        for key a substore key of the eligible delegates substore if
        eligibleDelegatesStore(key) < height - PUNISHMENT_WINDOW_SELF_VOTES or
        eligibleDelegatesStore(key) == 0
    ] ordered by weight, ties broken by reverse lexicographical ordering of address
    # Notice that the keys in the substore naturally have the right ordering
    # when being read from the end to the beginning of the store.

    roundNumber = roundNumber(height)

    snapshotState = {
            "delegateWeightSnapshot": eligibleDelegates
        }
    create an entry in the snapshot substore with
        storeKey = roundNumber.to_bytes(4,'big'),
        storeValue = encode(snapshotStoreSchema, snapshotState)
    delete any entries from the snapshot substore snapshotStore(x) for x <= roundNumber-3

    # Updates to Validators and BFT weights are only done after the bootstrap period.
    if roundNumber <= genesisDataStore.initRounds:
        return

    # Calculate the active delegates based on the snapshot taken two rounds ago.
    validatorsTwoRoundsAgo = [item for item in snapshotStore(roundNumber-2)]
    validatorList = getActiveDelegates(validatorsTwoRoundsAgo, roundNumber)

    # Select standby delegates if relevant.
    if roundNumber > initRounds + NUMBER_ACTIVE_DELEGATES:
        standbyDelegates = [validator for validator in validatorsTwoRoundsAgo
                            if validator["address"] not in validatorList]

        selectedStandbyDelegates = getSelectedStandbyDelegates(standbyDelegates, height)
        # Add selected standby delegates to validators.
        validatorList += selectedStandbyDelegates

    # If there are no eligible delegates, validatorList is empty.
    # In this case, the BFT parameters and validator list are not updated.
    if validatorList is empty:
        return

    # Compute the thresholds for the BFT consensus protocol.
    aggregateBFTWeight = 0
    for validator in validatorList:
        aggregateBFTWeight += validator.bftWeight

    precommitThreshold = (2 * aggregateBFTWeight) // 3 + 1
    certificateThreshold = precommitThreshold

    # Random seed to shuffle validators.
    randomSeed = random.getRandomBytes(
        height +1 - (ROUND_LENGTH*3)//2,
        ROUND_LENGTH
    )
    shuffledValidatorList = shuffleValidatorsList(validatorList, randomSeed)

    Validators.setValidatorParams(precommitThreshold, certificateThreshold, shuffledValidatorList)
```

## Backwards Compatibility

This LIP defines a new store interface for the PoS module, which in turn will become part of the state tree and will be authenticated by the state root. As such, it will induce a hardfork.

## Reference Implementation

TBA

[lip-0003]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0003.md
[lip-0022]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0022.md
[lip-0023]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0023.md
[lip-0023#locking-period]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0023.md#voting-by-locking-tokens
[lip-0023#explicit-unlock-mechanism]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0023.md#explicit-unlock-mechanism
[lip-0023#new-unlock-transaction]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0023.md#new-unlock-transaction
[lip-0023#new-vote-transaction]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0023.md#new-vote-transaction-1
[lip-0024#applying-a-pom-transaction]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0024.md#applying-a-pom-transaction
[lip-0024#rationale]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0024.md#rationale
[lip-0024#validity-of-a-pom-transaction]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0024.md#validity-of-a-pom-transaction
[lip-0034#bootstrap-period]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0034.md#bootstrap-period
[lip-0037#chain-identifiers]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0037.md#chain-identifiers
[lip-0038#public-key-registration]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0038.md#public-key-registration-and-proof-of-possession
[lip-0040]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0040.md
[lip-0043#chainid]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0043.md#chain-id
[lip-0044]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0044.md
[lip-0045#constants]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#notation-and-constants
[lip-0051]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0051.md
[lip-0051#tokenID]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0051.md#token-id-and-native-tokens
[lip-0053]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0053.md
[lip-0055]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md
[lip-0055#block-header-json-schema]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md#block-header-json-schema
[lip-0058]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0058.md
[lip-0059]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0059.md
[lip-0060]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0060.md
[lip-0062#specification]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0062.md#specification
[lip-0068]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0068.md
[lip-reward-sharing]: https://research.lisk.com/t/introduce-reward-sharing-mechanism/386
[lip-reward-sharing#efficient-calculation-of-rewards]: https://research.lisk.com/t/introduce-reward-sharing-mechanism/386#efficient-calculation-of-rewards-38
[lip-dynamic-block-rewards]: https://research.lisk.com/t/introduce-dynamic-block-rewards-module/387
