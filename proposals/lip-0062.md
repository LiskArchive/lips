```
LIP: 0062
Title: Use pre-hashing for signatures
Author: Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
Discussions-To: https://research.lisk.com/t/use-pre-hashing-for-signatures/329
Status: Draft
Type: Standards Track
Created: 2022-02-11
Updated: 2023-03-06
Requires: 0037
```

## Abstract

This LIP introduces pre-hashing for signatures in Lisk, this includes transactions, block headers and certificate signatures.
This allows signing to be performed on memory limited devices such as hardware wallets.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

Introducing memory efficient signing allows all objects used in the Lisk protocol to be signed on devices with limited memory.  Most of the current transactions have a small size and can be signed on existing devices. However, new transactions implemented in the interoperability module, or transactions implemented in decentralized applications are likely to be too large to be signed directly on such devices. This argument was overlooked in the past which led to the pre-hashing step being removed in [LIP 0008][lip-0008].

With the current proposal, signatures are computed against the hash of the message to be signed and hence always computed for a byte string of small constant size.

## Rationale

### Choice of Hash Function

Hashing before signing is a common practice and different protocols use different hash functions for this task. For the Lisk protocol, the natural choice of hash function is SHA-256. This function is used in multiple other parts of the protocol and hence it makes sense to not expose the protocol to another hash function.

Introduction of another hash function to the Lisk protocol was suggested in [LIP 0010](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0010.md), but was later withdrawn as SHA-256 is widely used and can be considered secure.

### On Removing Pre-hashing in LIP 0008

[LIP 0008][lip-0008] removed the pre-hashing step from the Lisk signing protocol. This was mainly done as this step was deemed unnecessary and removing it could improve the theoretical security of the signing process. However this is not reflected by a practical improvement in protocol security as the SHA-256 hash function is considered collision resistant and secure. This hash function is used in several critical parts of many applications, including Lisk, and any future findings that SHA-256 is insecure would require changing the protocol throughout.

## Specification

### Signing and Verifying with Ed25519

The Ed25519 signature for a binary message `message` and a secret key `sk` is generated by `signEd25519(sk, tag, chainID, message)` as defined below. `tag` must be the correct message tag for `message` as defined in [LIP 0037](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0037.md), and `chainID` the correct chain ID for the chain. The resulting signature `signature` in combination with the message `message` and the matching public key `pk` is verified by `verifyEd25519(pk, tag, chainID, message, signature)`.

```python
def signEd25519(sk: bytes, tag: bytes, chainID: bytes, message: bytes) -> bytes:
    taggedMessage = tag + chainID + message
    hashedMessage = sha256(taggedMessage)
    return Sign(sk, hashedMessage)
```
```python
def verifyEd25519(pk: bytes, tag: bytes, chainID: bytes, message: bytes, signature: bytes) -> bool:
    taggedMessage = tag + chainID + message
    hashedMessage = sha256(taggedMessage)
    return Verify(pk, hashedMessage, signature)
```

Here, <code>[Sign](https://tools.ietf.org/html/rfc8032#section-5.1.6)</code> and <code>[Verify](https://tools.ietf.org/html/rfc8032#section-5.1.7)</code> are the signing and verifying functions as specified in [RFC 8032](https://tools.ietf.org/html/rfc8032).

The `signEd25519` and `verifyEd25519` functions defined in [LIP 0037](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0037.md#signing-and-verifying-with-ed25519) are superseded by the functions defined in this LIP.

### Signing and Verifying with BLS

```python
def signBLS(sk: bytes, tag: bytes, chainID: bytes, message: bytes) -> bytes:
    taggedMessage = tag + chainID + message
    hashedMessage = sha256(taggedMessage)
    return CoreSign(sk, hashedMessage)
```
```python
def verifyBLS(pk: bytes, tag: bytes, chainID: bytes, message: bytes, signature: bytes) -> bool:
    taggedMessage = tag + chainID + message
    hashedMessage = sha256(taggedMessage)
    return CoreVerify(pk, hashedMessage, signature) == VALID
```
```python
def verifyAggSig(keysList: list[bytes], aggregationBits: bytes, signature: bytes, tag: bytes, chainID: bytes, message: bytes) -> bool:
    taggedMessage = tagMessage(tag, chainID, message)
    hashedMessage = sha256(taggedMessage)
    keys = []
    for i in range(8 * len(aggregationBits)):
        # if i-th bit of aggregationBits == 1
        if (aggregationBits[i // 8] >> (i % 8)) & 1:
            keys.append(keysList[i])
    return FastAggregateVerify(keys, hashedMessage, signature) == VALID
```

```python
def verifyWeightedAggSig(keysList: list[bytes], aggregationBits: bytes, signature: bytes, tag: bytes, chainID: bytes, weights: list[int], threshold: int, message: bytes) -> bool:
    taggedMessage = tagMessage(tag, chainID, message)
    hashedMessage = sha256(taggedMessage)
    keys = []
    weightSum = 0
    for i in range(8 * len(aggregationBits)):
        # if i-th bit of aggregationBits == 1
        if (aggregationBits[i // 8] >> (i % 8)) & 1:
            keys.append(keysList[i])
            weightSum += weights[i]
    if weightSum < threshold:
        return False
    return FastAggregateVerify(keys, hashedMessage, signature) == VALID
```

For the BLS signature scheme [used in Lisk](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0038.md#specification), [`CoreSign`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.6) and [`CoreVerify`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.7) are the signing and verifying functions, while [`FastAggregateVerify`](https://tools.ietf.org/html/draft-irtf-cfrg-bls-signature-04#section-3.3.4) is the function used to verify aggregated BLS signatures as specified in [BLS Signatures draft-irtf-cfrg-bls-signature-04](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04).

The `signBLS`, `verifyBLS`, `verifyAggSig`, and `verifyWeightedAggSig` functions defined in [LIP 0038](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0038.md#signing-and-verifying) are superseded by the functions defined in this LIP.

## Reference Implementation

TBD

## Backwards Compatibility

This LIP results in a hard fork as nodes following the proposed protocol will reject signatures according to the previous protocol, and nodes following the previous protocol will reject signatures according to the proposed protocol.

[lip-0008]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0008.md

## Appendix

### Test Vectors

The following tests supersede the corresponding tests given in [LIP 0038](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0038.md#test-vectors).

#### `signBLS`

```python
sk = 0x263dbd792f5b1be47ed85f8938c0f29586af0d3ac7b977f21c278fe1462040e3
tag = b"LSK_TX_"
chainID = 0x00000000
message = 0xbeaf
assert signBLS(sk, tag, chainID, message) == 0x80c3da661b5bb80bb841367255f7b087b969c075661895b7ac8b74b72360be54693b3485eff7d816924517a21ef1c3a30a8f9402572d5a63a7ff2f71ca6929a8c3d7f75fd72edd1aa478ecc09966a133e829600f0111a1e40bbe35db61e8c689
```

#### `verifyBLS`

```python
pk = 0xa491d1b0ecd9bb917989f0e74f0dea0422eac4a873e5e2644f368dffb9a6e20fd6e10c1b77654d067c0618f6e5a7f79a
tag = b"LSK_TX_"
chainID = 0x00000000
message = 0xbeaf
sig = 0x80c3da661b5bb80bb841367255f7b087b969c075661895b7ac8b74b72360be54693b3485eff7d816924517a21ef1c3a30a8f9402572d5a63a7ff2f71ca6929a8c3d7f75fd72edd1aa478ecc09966a133e829600f0111a1e40bbe35db61e8c689
assert verifyBLS(pk, tag, chainID, message, sig)
```
